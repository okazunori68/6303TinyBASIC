0000-                 14
0000-                 15      ; ********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0000-                 46
0020-                 47      RAM_START       .eq     $0020
1FFF-                 48      RAM_END         .eq     $1fff
E000-                 49      ROM_START       .eq     $e000
FFFF-                 50      ROM_END         .eq     $ffff
0FFF-                 51      STACK           .eq     $0fff
0000-                 52
1000-                 53      PROGRAM_START   .eq     $1000
0100-                 54      Rx_BUFFER       .eq     $0100   ; SCI Rx Buffer ($0100-0148,73byte)
0148-                 55      Rx_BUFFER_END   .eq     $0148   ; 73byte（72character）
0149-                 56      CSTACK          .eq     $0149   ; 計算スタック (Calculate stack, 40byte)
01C2-                 57      VARIABLE        .eq     $01c2   ; 変数26文字 ($01c2-01f5, 52byte)
0400-                 58      USERAREATOP     .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 59      USERAREABTM     .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 60
0000-                 61      ; ***********************************************************************
0000-                 62      ;   システム変数 System variables
0000-                 63      ; ***********************************************************************
0000-                 64              .sm     RAM
0020-                 65              .or     $20
0020-                 66
0020-                 67      ; Interrupt Vector Hooking
0020-                 68      VEC_TRAP        .bs     3
0023-                 69      VEC_SCI         .bs     3
0026-                 70      VEC_TOF         .bs     3
0029-                 71      VEC_OCF         .bs     3
002C-                 72      VEC_ICF         .bs     3
002F-                 73      VEC_IRQ         .bs     3
0032-                 74      VEC_SWI         .bs     3
0035-                 75      VEC_NMI         .bs     3
0038-                 76      BreakPointFlag  .bs     1
0039-                 77      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 78      ; General-Purpose Registers
003A-                 79      R0              .bs     2
003C-                 80      R1              .bs     2
003E-                 81
003E-                 82      ; ***********************************************************************
003E-                 83      ;   変数 Variables
003E-                 84      ; ***********************************************************************
003E-                 85              .sm     RAM
0080-                 86              .or     $80
0080-                 87
0080-                 88      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                 89      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                 90      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                 91      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                 92      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                 93      Divisor         .bs     2       ; 除数
0089-                 94      Remainder       .bs     2       ; 剰余
008B-                 95      VariableAddr    .bs     2       ; 変数のアドレス
008D-                 96      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                 97      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                 98      Source          .bs     2       ; 転送元アドレス
0092-                 99      Destination     .bs     2       ; 転送先アドレス
0094-                100      Bytes           .bs     2       ; 転送バイト数
0096-                101      LineNumber      .bs     2       ; 行番号
0098-                102      LineLength      .bs     2       ; 行の長さ
009A-                103      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                104      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                105      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                106
009F-                107      ; General-Purpose Registers
009F-                108      UR0             *
009F-                109      UR0H            .bs     1
00A0-                110      UR0L            .bs     1
00A1-                111      UR1             *
00A1-                112      UR1H            .bs     1
00A2-                113      UR1L            .bs     1
00A3-                114      UR2             *
00A3-                115      UR2H            .bs     1
00A4-                116      UR2L            .bs     1
00A5-                117      UR3             *
00A5-                118      UR3H            .bs     1
00A6-                119      UR3L            .bs     1
00A7-                120      ; Work area
00A7-                121      COMPARE         .bs     6       ; 文字列比較用バッファ
00AD-                122
00AD-                123      ; ***********************************************************************
00AD-                124      ;   Program Start
00AD-                125      ; ***********************************************************************
0000-                126              .sm     CODE
1000-                127              .or     PROGRAM_START
1000-                128
1000-                129      init_tinybasic:
1000-30              130 ( 1)         tsx
1001-DF 80           131 ( 4)         stx     <StackPointer
1003-                132
1003-                133
1003-                134      cold_start:
1003-                135            ; // プログラムエリアの初期化
1003-CE 04 00        136 ( 3)         ldx     #USERAREATOP
1006-DF 9A           137 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              138 ( 1)         clra
1009-5F              139 ( 1)         clrb
100A-ED 00           140 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           141 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                142            ; // 変数領域の初期化
100E-CE 01 C2        143 ( 3)         ldx     #VARIABLE
1011-ED 00           144 ( 5) .loop   std     0,x
1013-08              145 ( 1)         inx
1014-08              146 ( 1)         inx
1015-8C 01 F6        147 ( 3)         cpx     #VARIABLE+52
1018-26 F7           148 ( 3)         bne     :loop
101A-                149
101A-                150
101A-                151      tb_main:
101A-72 01 9C        152 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
101D-C6 3E           153 ( 2)         ldab    #'>'
101F-BD FF AC        154 ( 6)         jsr     write_char
1022-BD FF A9        155 ( 6)         jsr     read_line
1025-CE 01 00        156 ( 3)         ldx     #Rx_BUFFER      ; 実行位置アドレスをセット
1028-                157            ; // 行番号判定
1028-BD 12 DB        158 ( 6)         jsr     get_int_from_decimal
102B-24 0A           159 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
102D-83 00 00        160 ( 3)         subd    #0
1030-2E 08           161 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
1032-86 0C           162 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1034-7E 15 85        163 ( 3)         jmp     write_err_msg
1037-                164
1037-                165      execute_mode:
1037-7E 10 A0        166 ( 3)         jmp     exe_line
103A-                167
103A-                168      edit_mode:
103A-DF 8D           169 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
103C-DD 96           170 ( 4)         std     <LineNumber     ; 行番号を保存
103E-                171            ; // 行の長さを取得
103E-86 04           172 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1040-E6 00           173 ( 4) .loop   ldab    0,x
1042-27 04           174 ( 3)         beq     :1
1044-4C              175 ( 1)         inca                    ; 行の長さを+1
1045-08              176 ( 1)         inx                     ; バッファアドレスを+1
1046-20 F8           177 ( 3)         bra     :loop
1048-97 99           178 ( 3) .1      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
104A-                179            ; // 転送の準備
104A-DE 9A           180 ( 4)         ldx     <PrgmEndAddr    ; X <- プログラムの最終アドレス
104C-DC 9A           181 ( 4)         ldd     <PrgmEndAddr
104E-D3 98           182 ( 4)         addd    <LineLength     ; D <- 行の長さを足した最終アドレス
1050-18              183 ( 2)         xgdx
1051-8C 0D FD        184 ( 3)         cpx     #USERAREABTM    ; ユーザーエリアを超えていないかチェック
1054-18              185 ( 2)         xgdx
1055-24 24           186 ( 3)         bcc     :err14          ; "Memory size over"
1057-DD 9A           187 ( 4)         std     <PrgmEndAddr    ; 新しい最終アドレスを設定
1059-                188            ; // 行番号と行の長さを転送
1059-DC 96           189 ( 4)         ldd     <LineNumber     ; 行番号を取得
105B-ED 00           190 ( 5)         std     0,x
105D-08              191 ( 1)         inx
105E-08              192 ( 1)         inx
105F-D6 99           193 ( 3)         ldab    <LineLength+1   ; 行の長さを取得
1061-E7 00           194 ( 4)         stab    0,x
1063-                195            ; // mem_copyの引数を設定
1063-08              196 ( 1)         inx
1064-DF 92           197 ( 4)         stx     <Destination    ; 転送先アドレス（行の長さの直後）を設定
1066-4F              198 ( 1)         clra                    ; LineLengthの上位バイトをゼロにする
1067-C0 03           199 ( 2)         subb    #3              ; LineLengthから行番号・行の長さの3バイト分を引く
1069-DD 94           200 ( 4)         std     <Bytes          ; 転送バイト数を設定
106B-DC 8D           201 ( 4)         ldd     <ExePointer     ; 行番号の直後を指しているバッファアドレスを復帰
106D-DD 90           202 ( 4)         std     <Source         ; 転送元アドレスを設定
106F-BD 14 D4        203 ( 6)         jsr     mem_copy
1072-                204            ; // 終端行の挿入
1072-DE 9A           205 ( 4)         ldx     <PrgmEndAddr
1074-4F              206 ( 1)         clra
1075-5F              207 ( 1)         clrb
1076-ED 00           208 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
1078-7E 10 1A        209 ( 3)         jmp     tb_main
107B-86 0E           210 ( 2) .err14  ldaa    #14              ; "Memory size over"
107D-7E 15 85        211 ( 3)         jmp     write_err_msg
1080-                212
1080-                213
1080-                214      ; -----------------------------------------------------------------------
1080-                215      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1080-                216      ; Is a multi statement mark?
1080-                217      ;【引数】X:実行位置アドレス
1080-                218      ;【使用】B, X
1080-                219      ;【返値】なし
1080-                220      ; -----------------------------------------------------------------------
1080-                221      is_multi:
1080-BD 13 A4        222 ( 6)         jsr     skip_space
1083-27 0B           223 ( 3)         beq     eol_process
1085-C1 3A           224 ( 2)         cmpb    #':'
1087-26 03           225 ( 3)         bne     :err00
1089-08              226 ( 1)         inx
108A-20 14           227 ( 3)         bra     exe_line
108C-4F              228 ( 1) .err00  clra                    ; "Syntax error"
108D-7E 15 85        229 ( 3)         jmp     write_err_msg
1090-                230
1090-                231
1090-                232      ; -----------------------------------------------------------------------
1090-                233      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
1090-                234      ;  - directモードであればそのまま終了
1090-                235      ;  - runモードであれば次の行のポインタを設定してrts
1090-                236      ; End-of-line processing
1090-                237      ;  - If in direct mode, terminate execution
1090-                238      ;  - If run mode, set the pointer to the next line and rts
1090-                239      ;【引数】なし
1090-                240      ;【使用】A, B, X
1090-                241      ;【返値】なし
1090-                242      ; -----------------------------------------------------------------------
1090-                243      eol_process:
1090-                244            ; // runモードであれば次の行のポインタを設定してrts
1090-7D 00 9C        245 ( 4)         tst     <ExeStateFlag
1093-26 08           246 ( 3)         bne     :end
1095-DE 9D           247 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
1097-E6 02           248 ( 4)         ldab    2,x             ; 行の長さを取得
1099-3A              249 ( 1)         abx                     ; 次の行の先頭アドレスを取得
109A-DF 9D           250 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
109C-39              251 ( 5)         rts
109D-7E 10 1A        252 ( 3) .end    jmp     tb_main         ; directモードであればそのまま終了
10A0-                253
10A0-                254
10A0-                255      ; -----------------------------------------------------------------------
10A0-                256      ; 一行実行
10A0-                257      ; Execute one line
10A0-                258      ;【引数】X:実行位置アドレス
10A0-                259      ;【使用】A, B, X
10A0-                260      ;【返値】なし
10A0-                261      ; -----------------------------------------------------------------------
10A0-                262      exe_line:
10A0-BD 13 A4        263 ( 6)         jsr     skip_space
10A3-27 EB           264 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
10A5-                265            ; // 代入文のチェック
10A5-BD 13 8F        266 ( 6)         jsr     is_variable     ; 変数か？
10A8-24 12           267 ( 3)         bcc     :cmd            ; No. テーブル検索へ
10AA-86 01           268 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
10AC-58              269 ( 1)         aslb                    ; B = 変数領域の下位バイト
10AD-DD 8B           270 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
10AF-BD 13 A4        271 ( 6)         jsr     skip_space      ; Yes. 代入文か？
10B2-C1 3D           272 ( 2)         cmpb    #'='
10B4-26 24           273 ( 3)         bne     :err00          ; No. エラー処理へ
10B6-08              274 ( 1)         inx                     ; Yes. 代入実行
10B7-BD 13 E1        275 ( 6)         jsr     assign_to_var
10BA-20 C4           276 ( 3)         bra     is_multi
10BC-                277            ; // コマンド・ステートメントのチェック
10BC-EC 00           278 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
10BE-DD A7           279 ( 4)         std     <COMPARE
10C0-EC 02           280 ( 5)         ldd     2,x
10C2-DD A9           281 ( 4)         std     <COMPARE+2
10C4-EC 04           282 ( 5)         ldd     4,x
10C6-DD AB           283 ( 4)         std     <COMPARE+4
10C8-DF 8D           284 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
10CA-7D 00 9C        285 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
10CD-27 05           286 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
10CF-CE 15 49        287 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
10D2-20 03           288 ( 3)         bra     :2
10D4-CE 15 65        289 ( 3) .1      ldx     #SMT_TABLE
10D7-BD 15 0C        290 ( 6) .2      jsr     search_table    ; テーブル検索実行
10DA-4F              291 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
10DB-7E 15 85        292 ( 3)         jmp     write_err_msg
10DE-                293
10DE-                294
10DE-                295      ; -----------------------------------------------------------------------
10DE-                296      ; 式を評価する
10DE-                297      ; Evaluate the expression
10DE-                298      ;【引数】B:アスキーコード X:実行位置アドレス
10DE-                299      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
10DE-                300      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
10DE-                301      ;        偽(C=0) / X:現在の実行位置アドレス
10DE-                302      ; -----------------------------------------------------------------------
10DE-                303      eval_expression:
00A3-                304      .SP     .eq     UR2
00A5-                305      .X      .eq     UR3
10DE-                306            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
10DE-DF A5           307 ( 4)         stx     <:X
10E0-30              308 ( 1)         tsx
10E1-DF A3           309 ( 4)         stx     <:SP
10E3-DE A5           310 ( 4)         ldx     <:X
10E5-                311            ; // 計算スタックの初期化
10E5-CC 01 72        312 ( 3)         ldd     #CSTACK+40+1    ; 40byte分
10E8-DD 82           313 ( 4)         std     <CStackPtr
10EA-                314            ; // 式評価開始
10EA-8D 08           315 ( 5)         bsr     expr_4th
10EC-                316            ; // 計算結果をスタックトップから取り出す
10EC-3C              317 ( 5)         pshx
10ED-DE 82           318 ( 4)         ldx     <CStackPtr
10EF-EC 00           319 ( 5)         ldd     0,x
10F1-38              320 ( 4)         pulx
10F2-0D              321 ( 1)         sec                     ; true:C=1
10F3-39              322 ( 5)         rts
10F4-                323
10F4-                324      expr_4th:
10F4-8D 50           325 ( 5)         bsr     expr_3rd
10F6-BD 13 A4        326 ( 6) .loop   jsr     skip_space
10F9-C1 3D           327 ( 2)         cmpb    #'='            ; '='?
10FB-26 08           328 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
10FD-08              329 ( 1)         inx
10FE-8D 46           330 ( 5)         bsr     expr_3rd
1100-BD 12 8E        331 ( 6)         jsr     CS_eq           ; EQual to
1103-20 F1           332 ( 3)         bra     :loop
1105-C1 3C           333 ( 2) .ltsign cmpb    #'<'            ; '<'?
1107-26 22           334 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1109-08              335 ( 1)         inx
110A-E6 00           336 ( 4)         ldab    0,x
110C-C1 3E           337 ( 2)         cmpb    #'>'            ; '<>'?
110E-26 08           338 ( 3)         bne     :lte
1110-08              339 ( 1)         inx
1111-8D 33           340 ( 5)         bsr     expr_3rd
1113-BD 12 AF        341 ( 6)         jsr     CS_ne           ; Not Equal to
1116-20 DE           342 ( 3)         bra     :loop
1118-C1 3D           343 ( 2) .lte    cmpb    #'='            ; '<='?
111A-26 08           344 ( 3)         bne     :lt
111C-08              345 ( 1)         inx
111D-8D 27           346 ( 5)         bsr     expr_3rd
111F-BD 12 A4        347 ( 6)         jsr     CS_lte          ; Less Than or Equal to
1122-20 D2           348 ( 3)         bra     :loop
1124-8D 20           349 ( 5) .lt     bsr     expr_3rd
1126-BD 12 99        350 ( 6)         jsr     CS_lt           ; Less Than
1129-20 CB           351 ( 3)         bra     :loop
112B-C1 3E           352 ( 2) .gtsign cmpb    #'>'            ; '>'?
112D-26 16           353 ( 3)         bne     :end
112F-08              354 ( 1)         inx
1130-E6 00           355 ( 4)         ldab    0,x
1132-C1 3D           356 ( 2)         cmpb    #'='            ; '>='?
1134-26 08           357 ( 3)         bne     :gt
1136-08              358 ( 1)         inx
1137-8D 0D           359 ( 5)         bsr     expr_3rd
1139-BD 12 C5        360 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
113C-20 B8           361 ( 3)         bra     :loop
113E-8D 06           362 ( 5) .gt     bsr     expr_3rd
1140-BD 12 BA        363 ( 6)         jsr     CS_gt           ; Greater Than
1143-20 B1           364 ( 3)         bra     :loop
1145-39              365 ( 5) .end    rts
1146-                366
1146-                367      expr_3rd:
1146-8D 1C           368 ( 5)         bsr     expr_2nd
1148-BD 13 A4        369 ( 6) .loop   jsr     skip_space
114B-C1 2B           370 ( 2)         cmpb    #'+'
114D-26 08           371 ( 3)         bne     :minus
114F-08              372 ( 1)         inx
1150-8D 12           373 ( 5)         bsr     expr_2nd
1152-BD 11 D9        374 ( 6)         jsr     CS_add
1155-20 F1           375 ( 3)         bra     :loop
1157-C1 2D           376 ( 2) .minus  cmpb    #'-'
1159-26 08           377 ( 3)         bne     :end
115B-08              378 ( 1)         inx
115C-8D 06           379 ( 5)         bsr     expr_2nd
115E-BD 11 E2        380 ( 6)         jsr     CS_sub
1161-20 E5           381 ( 3)         bra     :loop
1163-39              382 ( 5) .end    rts
1164-                383
1164-                384      expr_2nd:
1164-8D 28           385 ( 5)         bsr     expr_1st
1166-BD 13 A4        386 ( 6) .loop   jsr     skip_space
1169-C1 2A           387 ( 2)         cmpb    #'*'
116B-26 08           388 ( 3)         bne     :div
116D-08              389 ( 1)         inx
116E-8D 1E           390 ( 5)         bsr     expr_1st
1170-BD 11 EB        391 ( 6)         jsr     CS_mul
1173-20 F1           392 ( 3)         bra     :loop
1175-C1 2F           393 ( 2) .div    cmpb    #'/'
1177-26 08           394 ( 3)         bne     :mod
1179-08              395 ( 1)         inx
117A-8D 12           396 ( 5)         bsr     expr_1st
117C-BD 12 08        397 ( 6)         jsr     CS_div
117F-20 E5           398 ( 3)         bra     :loop
1181-C1 25           399 ( 2) .mod    cmpb    #'%'
1183-26 08           400 ( 3)         bne     :end
1185-08              401 ( 1)         inx
1186-8D 06           402 ( 5)         bsr     expr_1st
1188-BD 12 24        403 ( 6)         jsr     CS_mod
118B-20 D9           404 ( 3)         bra     :loop
118D-39              405 ( 5) .end    rts
118E-                406
118E-                407      expr_1st:
00A3-                408      .SP     .eq     UR2
00A5-                409      .X      .eq     UR3
118E-BD 13 A4        410 ( 6)         jsr     skip_space
1191-BD 12 DB        411 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
1194-24 02           412 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
1196-20 1D           413 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1198-BD 13 8F        414 ( 6) .var    jsr     is_variable     ; 変数か？
119B-24 0A           415 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
119D-                416            ; // 変数値の取得
119D-3C              417 ( 5)         pshx                    ; 実行位置アドレスを退避
119E-86 01           418 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
11A0-58              419 ( 1)         aslb                    ; B = 変数領域の下位バイト
11A1-18              420 ( 2)         xgdx                    ; X = 変数のアドレス
11A2-EC 00           421 ( 5)         ldd     0,x             ; D <- 変数の値
11A4-38              422 ( 4)         pulx                    ; 実行位置アドレスを復帰
11A5-20 0E           423 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
11A7-C1 28           424 ( 2) .paren  cmpb    #'('
11A9-26 1A           425 ( 3)         bne     :err
11AB-08              426 ( 1)         inx
11AC-BD 10 F4        427 ( 6)         jsr     expr_4th
11AF-C1 29           428 ( 2)         cmpb    #')'
11B1-26 12           429 ( 3)         bne     :err
11B3-08              430 ( 1)         inx
11B4-39              431 ( 5)         rts
11B5-3C              432 ( 5) .push   pshx                    ; 実行位置アドレスを退避
11B6-DE 82           433 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11B8-09              434 ( 1)         dex
11B9-09              435 ( 1)         dex
11BA-8C 01 47        436 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
11BD-25 0D           437 ( 3)         bcs     :err06
11BF-ED 00           438 ( 5)         std     0,x
11C1-DF 82           439 ( 4)         stx     <CStackPtr
11C3-38              440 ( 4)         pulx                    ; 実行位置アドレスを復帰
11C4-39              441 ( 5)         rts
11C5-                442            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
11C5-DE A3           443 ( 4) .err    ldx     <:SP
11C7-35              444 ( 1)         txs
11C8-DE A5           445 ( 4)         ldx     <:X
11CA-0C              446 ( 1)         clc                     ; false:C=0
11CB-39              447 ( 5)         rts
11CC-86 06           448 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
11CE-7E 15 85        449 ( 3)         jmp     write_err_msg
11D1-                450
11D1-                451      ;
11D1-                452      ; Arithmetic operator
11D1-                453      ;
11D1-                454      CS_store:
11D1-08              455 ( 1)         inx
11D2-08              456 ( 1)         inx
11D3-ED 00           457 ( 5)         std     0,x
11D5-DF 82           458 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
11D7-38              459 ( 4)         pulx                    ; 実行位置アドレスを復帰
11D8-39              460 ( 5)         rts
11D9-                461
11D9-3C              462 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
11DA-DE 82           463 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11DC-EC 02           464 ( 5)         ldd     2,x
11DE-E3 00           465 ( 5)         addd    0,x
11E0-20 EF           466 ( 3)         bra     CS_store
11E2-                467
11E2-3C              468 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
11E3-DE 82           469 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11E5-EC 02           470 ( 5)         ldd     2,x
11E7-A3 00           471 ( 5)         subd    0,x
11E9-20 E6           472 ( 3)         bra     CS_store
11EB-                473
11EB-                474      CS_mul:
009F-                475      .Result         .eq     UR0
11EB-3C              476 ( 5)         pshx                    ; 実行位置アドレスを退避
11EC-DE 82           477 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11EE-                478              ; B * D
11EE-A6 03           479 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
11F0-E6 01           480 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
11F2-3D              481 ( 7)         mul                     ; B * D
11F3-DD 9F           482 ( 4)         std     <:Result        ;「B*D」を保存
11F5-                483              ; A * D
11F5-EC 01           484 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
11F7-3D              485 ( 7)         mul                     ; A * D
11F8-DB 9F           486 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
11FA-D7 9F           487 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
11FC-                488              ; C * B
11FC-A6 00           489 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
11FE-E6 03           490 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
1200-3D              491 ( 7)         mul                     ; C * B
1201-DB 9F           492 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1203-17              493 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1204-D6 A0           494 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
1206-20 C9           495 ( 3)         bra     CS_store
1208-                496
1208-                497      ;
1208-                498      ; 符号付き割り算の考え方
1208-                499      ; ・剰余は除数の符号と同一
1208-                500      ;   ・ 7 / 3  = 商  2、剰余  1
1208-                501      ;   ・-7 / 3  = 商 -3、剰余  2
1208-                502      ;   ・ 7 / -3 = 商 -3、剰余 -2
1208-                503      ;   ・-7 / -3 = 商  2、剰余 -1
1208-                504      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
1208-                505      ;       2.ただし、除数がゼロの場合は1は足さない
1208-                506      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
1208-                507      ;         除数の絶対値から剰余の絶対値を引く
1208-                508      ;       2.その結果を除数と同じ符号にする
1208-                509      ;       3.ただし、除数がゼロの場合は剰余もゼロ
1208-                510      ;
1208-3C              511 ( 5) CS_div: pshx                    ; 実行位置アドレスを退避
1209-DE 82           512 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
120B-8D 37           513 ( 5)         bsr     div_uint        ; 除算実行
120D-18              514 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
120E-7D 00 85        515 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1211-27 0D           516 ( 3)         beq     :end            ; '+'なら終了
1213-8C 00 00        517 ( 3)         cpx     #0              ; 剰余はゼロか？
1216-27 03           518 ( 3)         beq     :sign
1218-C3 00 01        519 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
121B-43              520 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
121C-53              521 ( 1)         comb
121D-C3 00 01        522 ( 3)         addd    #1
1220-DE 82           523 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1222-20 AD           524 ( 3)         bra     CS_store
1224-                525
1224-3C              526 ( 5) CS_mod: pshx                    ; 実行位置アドレスを退避
1225-DE 82           527 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1227-8D 1B           528 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1229-DD 89           529 ( 4)         std     <Remainder      ; 剰余はゼロか？
122B-27 13           530 ( 3)         beq     :end            ; ゼロであれば終了
122D-7D 00 85        531 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
1230-27 04           532 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
1232-DC 87           533 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1234-93 89           534 ( 4)         subd    <Remainder
1236-7D 00 86        535 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1239-27 05           536 ( 3)         beq     :end            ; '+'なら終了
123B-43              537 ( 1)         coma                    ; '-'なら2の補数にする
123C-53              538 ( 1)         comb
123D-C3 00 01        539 ( 3)         addd    #1
1240-DE 82           540 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1242-20 8D           541 ( 3)         bra     CS_store
1244-                542
1244-                543      div_uint:
009F-                544      .Counter        .eq     UR0H
1244-EC 00           545 ( 5)         ldd     0,x             ; ゼロ除算チェック
1246-27 41           546 ( 3)         beq     :err08          ; 除数がゼロならエラー
1248-5F              547 ( 1)         clrb
1249-D7 85           548 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
124B-D7 86           549 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
124D-C6 10           550 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
124F-D7 9F           551 ( 3)         stab    <:Counter
1251-                552              ; // 剰余の符号フラグの設定
1251-EC 00           553 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1253-2A 03           554 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1255-7C 00 86        555 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1258-                556              ; // 商の符号フラグの設定
1258-A8 02           557 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
125A-2A 03           558 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
125C-7C 00 85        559 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
125F-                560              ; // 除数を絶対値にする
125F-EC 00           561 ( 5) .2      ldd     0,x             ; D <- 除数
1261-2A 05           562 ( 3)         bpl     :3
1263-43              563 ( 1)         coma                    ; 除数が負なら絶対値にする
1264-53              564 ( 1)         comb
1265-C3 00 01        565 ( 3)         addd    #1
1268-DD 87           566 ( 4) .3      std     <Divisor        ; 除数を保存
126A-                567              ; // 非除数を絶対値にする
126A-EC 02           568 ( 5)         ldd     2,x             ; D <- 被除数
126C-2A 05           569 ( 3)         bpl     :4
126E-43              570 ( 1)         coma                    ; 被除数が負なら絶対値にする
126F-53              571 ( 1)         comb
1270-C3 00 01        572 ( 3)         addd    #1
1273-                573              ; // 除算実行
1273-18              574 ( 2) .4      xgdx                    ; X <- 被除数
1274-4F              575 ( 1)         clra                    ; D（WORK）をクリア
1275-5F              576 ( 1)         clrb
1276-18              577 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
1277-05              578 ( 1)         asld
1278-18              579 ( 2)         xgdx
1279-59              580 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
127A-49              581 ( 1)         rola
127B-93 87           582 ( 4)         subd    <Divisor        ; WORK - 除数
127D-08              583 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
127E-24 03           584 ( 3)         bcc     :5              ; WORKから除数を引けた？
1280-D3 87           585 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1282-09              586 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1283-7A 00 9F        587 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1286-26 EE           588 ( 3)         bne     :loop
1288-39              589 ( 5)         rts
1289-86 08           590 ( 2) .err08  ldaa    #8              ; "Zero Divide"
128B-7E 15 85        591 ( 3)         jmp     write_err_msg
128E-                592
128E-3C              593 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
128F-DE 82           594 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1291-EC 02           595 ( 5)         ldd     2,x
1293-A3 00           596 ( 5)         subd    0,x
1295-27 39           597 ( 3)         beq     CS_true
1297-20 3D           598 ( 3)         bra     CS_false
1299-                599
1299-3C              600 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
129A-DE 82           601 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
129C-EC 02           602 ( 5)         ldd     2,x
129E-A3 00           603 ( 5)         subd    0,x
12A0-2D 2E           604 ( 3)         blt     CS_true
12A2-20 32           605 ( 3)         bra     CS_false
12A4-                606
12A4-3C              607 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
12A5-DE 82           608 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12A7-EC 02           609 ( 5)         ldd     2,x
12A9-A3 00           610 ( 5)         subd    0,x
12AB-2F 23           611 ( 3)         ble     CS_true
12AD-20 27           612 ( 3)         bra     CS_false
12AF-                613
12AF-3C              614 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
12B0-DE 82           615 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12B2-EC 02           616 ( 5)         ldd     2,x
12B4-A3 00           617 ( 5)         subd    0,x
12B6-26 18           618 ( 3)         bne     CS_true
12B8-20 1C           619 ( 3)         bra     CS_false
12BA-                620
12BA-3C              621 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
12BB-DE 82           622 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12BD-EC 02           623 ( 5)         ldd     2,x
12BF-A3 00           624 ( 5)         subd    0,x
12C1-2E 0D           625 ( 3)         bgt     CS_true
12C3-20 11           626 ( 3)         bra     CS_false
12C5-                627
12C5-3C              628 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
12C6-DE 82           629 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12C8-EC 02           630 ( 5)         ldd     2,x
12CA-A3 00           631 ( 5)         subd    0,x
12CC-2C 02           632 ( 3)         bge     CS_true
12CE-20 06           633 ( 3)         bra     CS_false
12D0-                634
12D0-                635      CS_true:
12D0-CC 00 01        636 ( 3)         ldd     #1
12D3-7E 11 D1        637 ( 3)         jmp     CS_store
12D6-                638
12D6-                639      CS_false:
12D6-4F              640 ( 1)         clra
12D7-5F              641 ( 1)         clrb
12D8-7E 11 D1        642 ( 3)         jmp     CS_store
12DB-                643
12DB-                644      ; -----------------------------------------------------------------------
12DB-                645      ; テキストバッファの10進文字列から数値を取得する
12DB-                646      ; Get a integer from a decimal string in a text buffer
12DB-                647      ;【引数】X:バッファアドレス
12DB-                648      ;【使用】A, B, X, UR0, UR1
12DB-                649      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
12DB-                650      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
12DB-                651      ; -----------------------------------------------------------------------
12DB-                652      get_int_from_decimal:
009F-                653      .RetValue       .eq     UR0     ; Return Value
00A1-                654      .TempValue      .eq     UR1     ; Temporary Value
12DB-4F              655 ( 1)         clra
12DC-5F              656 ( 1)         clrb
12DD-DD 9F           657 ( 4)         std     <:RetValue
12DF-97 A1           658 ( 3)         staa    <:TempValue
12E1-97 84           659 ( 3)         staa    <SignFlag
12E3-E6 00           660 ( 4)         ldab    0,x             ; 1文字取得
12E5-C1 2D           661 ( 2)         cmpb    #'-'            ; マイナス記号か？
12E7-26 05           662 ( 3)         bne     :1
12E9-7C 00 84        663 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
12EC-20 0B           664 ( 3)         bra     :next
12EE-C1 2B           665 ( 2) .1      cmpb    #'+'            ; プラス記号か？
12F0-27 07           666 ( 3)         beq     :next
12F2-BD FF C1        667 ( 6)         jsr     is_decimal_char ; 数字か？
12F5-24 36           668 ( 3)         bcc     :false          ; No. C=1で終了
12F7-20 13           669 ( 3)         bra     :first
12F9-08              670 ( 1) .next   inx                     ; 符号の次の1文字を取得
12FA-E6 00           671 ( 4)         ldab    0,x
12FC-BD FF C1        672 ( 6)         jsr     is_decimal_char ; 数字か？
12FF-24 40           673 ( 3)         bcc     :err04          ; No. エラー処理へ
1301-20 09           674 ( 3)         bra     :first          ; Yes. これが最初の数字
1303-DD 9F           675 ( 4) .loop   std     <:RetValue      ; 結果を退避
1305-E6 00           676 ( 4)         ldab    0,x             ; 1文字取得
1307-BD FF C1        677 ( 6)         jsr     is_decimal_char ; 数字か？
130A-24 14           678 ( 3)         bcc     :end
130C-C0 30           679 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
130E-D7 A2           680 ( 3)         stab    <:TempValue+1
1310-                681            ; // RetValue * 10 + TempValue
1310-DC 9F           682 ( 4)         ldd     <:RetValue
1312-05              683 ( 1)         asld                    ; * 2
1313-05              684 ( 1)         asld                    ; * 4
1314-D3 9F           685 ( 4)         addd    <:RetValue      ; * 5
1316-05              686 ( 1)         asld                    ; * 10
1317-D3 A1           687 ( 4)         addd    <:TempValue     ; += TempValue
1319-08              688 ( 1)         inx                     ; ポインタを進める
131A-25 20           689 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
131C-2B 10           690 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
131E-20 E3           691 ( 3)         bra     :loop
1320-DC 9F           692 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
1322-7D 00 84        693 ( 4)         tst     <SignFlag       ; 符号チェック
1325-27 05           694 ( 3)         beq     :true
1327-43              695 ( 1)         coma                    ; 負なら2の補数に
1328-53              696 ( 1)         comb
1329-C3 00 01        697 ( 3)         addd    #1
132C-0D              698 ( 1) .true   sec
132D-39              699 ( 5) .false  rts
132E-                700
132E-                701      .overflow
132E-                702            ; // -32,768かどうかの判定
132E-18              703 ( 2)         xgdx
132F-8C 80 00        704 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
1332-18              705 ( 2)         xgdx
1333-26 07           706 ( 3)         bne     :err02          ; No. 範囲外
1335-7D 00 84        707 ( 4)         tst     <SignFlag       ; 符号チェック
1338-27 02           708 ( 3)         beq     :err02          ; 正ならば範囲外
133A-20 C7           709 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
133C-                710
133C-86 02           711 ( 2) .err02  ldaa    #2              ; "Out of range"
133E-7E 15 85        712 ( 3)         jmp     write_err_msg
1341-86 04           713 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1343-7E 15 85        714 ( 3)         jmp     write_err_msg
1346-                715
1346-                716
1346-                717      ; -----------------------------------------------------------------------
1346-                718      ; Dレジスタの数値をコンソールに出力する
1346-                719      ; Write Decimal Character converted from Integer
1346-                720      ;【引数】D:Integer
1346-                721      ;【使用】A, B, X
1346-                722      ;【返値】なし
1346-                723      ; -----------------------------------------------------------------------
1346-                724      write_integer:
009F-                725      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00A0-                726      .Counter        .eq     UR0L    ; 桁カウンター
1346-2A 0C           727 ( 3)         bpl     :plus           ; 符号判定
1348-37              728 ( 4)         pshb                    ; 負数なら'-'を出力する
1349-C6 2D           729 ( 2)         ldab    #'-'
134B-BD FF AC        730 ( 6)         jsr     write_char
134E-33              731 ( 3)         pulb
134F-43              732 ( 1)         coma                    ; 絶対値にする（2の補数にする）
1350-53              733 ( 1)         comb
1351-C3 00 01        734 ( 3)         addd    #1
1354-7F 00 9F        735 ( 5) .plus   clr     <:ZeroSuppress
1357-CE 13 87        736 ( 3)         ldx     #:CONST
135A-7F 00 A0        737 ( 5) .loop   clr     <:Counter
135D-A3 00           738 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
135F-25 05           739 ( 3)         bcs     :write
1361-7C 00 A0        740 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1364-20 F7           741 ( 3)         bra     :digit
1366-                742
1366-E3 00           743 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1368-37              744 ( 4)         pshb
1369-D6 A0           745 ( 3)         ldab    <:Counter
136B-27 03           746 ( 3)         beq     :1              ; この桁はゼロか？
136D-7C 00 9F        747 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
1370-7D 00 9F        748 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1373-27 05           749 ( 3)         beq     :2              ; No. この桁は表示しない
1375-CB 30           750 ( 2)         addb    #$30            ; Yes. この桁を表示する
1377-BD FF AC        751 ( 6)         jsr     write_char
137A-33              752 ( 3) .2      pulb
137B-08              753 ( 1)         inx                     ; 次の引く数へ
137C-08              754 ( 1)         inx
137D-8C 13 8F        755 ( 3)         cpx     #:CONST+8
1380-26 D8           756 ( 3)         bne     :loop
1382-CB 30           757 ( 2)         addb    #$30            ; 一の桁の数値を表示
1384-7E FF AC        758 ( 3)         jmp     write_char
1387-                759      ; Dから引いていく数
1387-27 10           760      .CONST  .dw     $2710           ; 10,000
1389-03 E8           761              .dw     $03e8           ; 1,000
138B-00 64           762              .dw     $0064           ; 100
138D-00 0A           763              .dw     $000a           ; 10
138F-                764
138F-                765
138F-                766      ; -----------------------------------------------------------------------
138F-                767      ; テキストバッファの英文字が変数か判定する
138F-                768      ; Is a character retrieved from a text buffer a variable?
138F-                769      ;【引数】X:バッファアドレス
138F-                770      ;【使用】A, B, X
138F-                771      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
138F-                772      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
138F-                773      ; -----------------------------------------------------------------------
138F-                774      is_variable:
138F-E6 00           775 ( 4)         ldab    0,x
1391-BD FF BE        776 ( 6)         jsr     is_alphabetic_char
1394-24 0D           777 ( 3)         bcc     :end
1396-17              778 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1397-E6 01           779 ( 4)         ldab    1,x                     ; 2文字目を取得
1399-BD FF BE        780 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
139C-16              781 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
139D-24 02           782 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
139F-0C              783 ( 1)         clc                             ; Yes. 変数ではない。C=0
13A0-39              784 ( 5)         rts
13A1-08              785 ( 1) .var    inx                             ; ポインタを進める
13A2-0D              786 ( 1)         sec                             ; C=1
13A3-39              787 ( 5) .end    rts
13A4-                788
13A4-                789
13A4-                790      ; -----------------------------------------------------------------------
13A4-                791      ; 空白を読み飛ばす
13A4-                792      ; Skip Space
13A4-                793      ;【引数】X:実行位置アドレス
13A4-                794      ;【使用】B, X
13A4-                795      ;【返値】B:アスキーコード（$00の時Z=1）
13A4-                796      ;        X:実行位置アドレス
13A4-                797      ; -----------------------------------------------------------------------
13A4-                798      skip_space:
13A4-E6 00           799 ( 4)         ldab    0,x
13A6-27 07           800 ( 3)         beq     :end
13A8-C1 20           801 ( 2)         cmpb    #SPACE
13AA-22 03           802 ( 3)         bhi     :end
13AC-08              803 ( 1)         inx
13AD-20 F5           804 ( 3)         bra     skip_space
13AF-39              805 ( 5) .end    rts
13B0-                806
13B0-                807
13B0-                808      ; -----------------------------------------------------------------------
13B0-                809      ; 引用符付きの文字列を出力する
13B0-                810      ; Write Quoted Stirng
13B0-                811      ;【引数】B:アスキーコード X:実行位置アドレス
13B0-                812      ;【使用】A, B, X
13B0-                813      ;【返値】真(C=1) / X:次の実行位置アドレス
13B0-                814      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
13B0-                815      ; -----------------------------------------------------------------------
13B0-                816      write_quoted_str:
13B0-C1 22           817 ( 2)         cmpb    #$22            ; 一重引用符か？
13B2-27 04           818 ( 3)         beq     :1
13B4-C1 27           819 ( 2)         cmpb    #$27            ; 二重引用符か？
13B6-26 19           820 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
13B8-17              821 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
13B9-                822            ; // 終端の引用符をチェック
13B9-3C              823 ( 5)         pshx
13BA-08              824 ( 1) .check  inx
13BB-E6 00           825 ( 4)         ldab    0,x
13BD-27 14           826 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
13BF-11              827 ( 1)         cba
13C0-26 F8           828 ( 3)         bne     :check
13C2-38              829 ( 4)         pulx
13C3-                830            ; // 文字列の出力
13C3-08              831 ( 1) .loop   inx
13C4-E6 00           832 ( 4)         ldab    0,x
13C6-11              833 ( 1)         cba                     ; 保存した引用符との比較
13C7-27 05           834 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
13C9-BD FF AC        835 ( 6)         jsr     write_char
13CC-20 F5           836 ( 3)         bra     :loop
13CE-08              837 ( 1) .true   inx
13CF-0D              838 ( 1)         sec
13D0-39              839 ( 5)         rts
13D1-0C              840 ( 1) .false  clc
13D2-39              841 ( 5)         rts
13D3-86 0A           842 ( 2) .err10  ldaa    #10             ; "Print statement error"
13D5-7E 15 85        843 ( 3)         jmp     write_err_msg
13D8-                844
13D8-                845
13D8-                846      ; -----------------------------------------------------------------------
13D8-                847      ; タブを出力する
13D8-                848      ; Write tabs
13D8-                849      ;【引数】なし
13D8-                850      ;【使用】B
13D8-                851      ;【返値】なし
13D8-                852      ; -----------------------------------------------------------------------
13D8-                853      write_tab:
13D8-BD FF B5        854 ( 6) .top    jsr     write_space
13DB-7B 07 39        855 ( 4)         tim     #7,<TabCount
13DE-26 F8           856 ( 3)         bne     :top
13E0-39              857 ( 5)         rts
13E1-                858
13E1-                859
13E1-                860      ; -----------------------------------------------------------------------
13E1-                861      ; 式を評価して変数に値を代入する
13E1-                862      ; Evaluate an expression and assign a value to a variable
13E1-                863      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
13E1-                864      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
13E1-                865      ;【返値】D:Integer X:次の実行位置アドレス
13E1-                866      ; -----------------------------------------------------------------------
13E1-                867      assign_to_var:
13E1-BD 13 A4        868 ( 6)         jsr     skip_space
13E4-BD 10 DE        869 ( 6)         jsr     eval_expression
13E7-24 07           870 ( 3)         bcc     :err04
13E9-3C              871 ( 5)         pshx                    ; 実行位置アドレスを退避
13EA-DE 8B           872 ( 4)         ldx     <VariableAddr
13EC-ED 00           873 ( 5)         std     0,x             ; 変数に結果を保存
13EE-38              874 ( 4)         pulx                    ; 実行位置アドレスを復帰
13EF-39              875 ( 5)         rts
13F0-86 04           876 ( 2) .err04  ldaa    #4              ; "Illegal expression"
13F2-7E 15 85        877 ( 3)         jmp     write_err_msg
13F5-                878
13F5-                879
13F5-                880      ; -----------------------------------------------------------------------
13F5-                881      ; runコマンドを実行する
13F5-                882      ; Execute 'run' command
13F5-                883      ;【引数】なし
13F5-                884      ;【使用】A, B, X
13F5-                885      ;【返値】なし
13F5-                886      ; -----------------------------------------------------------------------
13F5-                887      exe_run:
13F5-                888            ; // 変数領域の初期化
13F5-CE 01 C2        889 ( 3)         ldx     #VARIABLE
13F8-4F              890 ( 1)         clra
13F9-5F              891 ( 1)         clrb
13FA-ED 00           892 ( 5) .1      std     0,x
13FC-08              893 ( 1)         inx
13FD-08              894 ( 1)         inx
13FE-8C 01 F6        895 ( 3)         cpx     #VARIABLE+52
1401-26 F7           896 ( 3)         bne     :1
1403-7F 00 9C        897 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
1406-CE 04 00        898 ( 3)         ldx     #USERAREATOP
1409-DF 9D           899 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
140B-EC 00           900 ( 5)         ldd     0,x
140D-27 08           901 ( 3)         beq     :end            ; 行番号が$0000なら終了
140F-08              902 ( 1)         inx
1410-08              903 ( 1)         inx
1411-08              904 ( 1)         inx
1412-BD 10 A0        905 ( 6)         jsr     exe_line        ; 一行実行
1415-20 F2           906 ( 3)         bra     :loop
1417-7E 10 1A        907 ( 3) .end    jmp     tb_main
141A-                908
141A-                909
141A-                910      ; -----------------------------------------------------------------------
141A-                911      ; listコマンドを実行する
141A-                912      ; Execute 'list' command
141A-                913      ;【引数】なし
141A-                914      ;【使用】A, B, X
141A-                915      ;【返値】なし
141A-                916      ; -----------------------------------------------------------------------
141A-                917      exe_list:
141A-CE 04 00        918 ( 3)         ldx     #USERAREATOP
141D-                919            ; // 行番号出力
141D-EC 00           920 ( 5) .loop   ldd     0,x
141F-27 11           921 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
1421-3C              922 ( 5)         pshx
1422-BD 13 46        923 ( 6)         jsr     write_integer
1425-38              924 ( 4)         pulx
1426-                925            ; // 本文出力
1426-08              926 ( 1)         inx                     ; 本文までスキップ
1427-08              927 ( 1)         inx
1428-08              928 ( 1)         inx
1429-BD FF AF        929 ( 6)         jsr     write_line
142C-BD FF B2        930 ( 6)         jsr     write_crlf
142F-08              931 ( 1)         inx                     ; 次の行番号へ
1430-20 EB           932 ( 3)         bra     :loop
1432-7E 10 1A        933 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1435-                934
1435-                935
1435-                936      ; -----------------------------------------------------------------------
1435-                937      ; Print文を実行する
1435-                938      ; Execute 'print' statement
1435-                939      ;【引数】X:実行位置アドレス
1435-                940      ;【使用】B, X（下位ルーチンでA）
1435-                941      ;【返値】なし
1435-                942      ; -----------------------------------------------------------------------
1435-                943      exe_print:
1435-72 01 8F        944 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1438-BD 13 A4        945 ( 6) .loop   jsr     skip_space
143B-27 37           946 ( 3)         beq     :finish         ; 終端文字なら改行して終了
143D-BD 13 B0        947 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1440-25 1B           948 ( 3)         bcs     :nlon
1442-BD 10 DE        949 ( 6)         jsr     eval_expression
1445-25 11           950 ( 3)         bcs     :int
1447-                951            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
1447-                952            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
1447-C1 3B           953 ( 2) .check  cmpb    #';'
1449-27 23           954 ( 3)         beq     :nloff
144B-C1 2C           955 ( 2)         cmpb    #','
144D-27 1C           956 ( 3)         beq     :tab
144F-C1 3A           957 ( 2)         cmpb    #':'
1451-27 21           958 ( 3)         beq     :finish
1453-86 04           959 ( 2)         ldaa    #4              ; "Illegal expression"
1455-7E 15 85        960 ( 3)         jmp     write_err_msg
1458-3C              961 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1459-BD 13 46        962 ( 6)         jsr     write_integer   ; 評価した式を出力
145C-38              963 ( 4)         pulx                    ; 実行位置アドレスを復帰
145D-72 01 8F        964 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1460-BD 13 A4        965 ( 6)         jsr     skip_space
1463-C1 3B           966 ( 2)         cmpb    #';'
1465-27 07           967 ( 3)         beq     :nloff
1467-C1 2C           968 ( 2)         cmpb    #','
1469-26 09           969 ( 3)         bne     :finish
146B-BD 13 D8        970 ( 6) .tab    jsr     write_tab       ; タブ出力
146E-7F 00 8F        971 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
1471-08              972 ( 1)         inx                     ; 次の文字へ
1472-20 C4           973 ( 3)         bra     :loop
1474-7D 00 8F        974 ( 4) .finish tst     <NewLineFlag
1477-27 03           975 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1479-BD FF B2        976 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
147C-7E 10 80        977 ( 3) .end    jmp     is_multi
147F-                978
147F-                979
147F-                980      ; -----------------------------------------------------------------------
147F-                981      ; input文を実行する
147F-                982      ; Execute 'input' statement
147F-                983      ; -----------------------------------------------------------------------
147F-                984      exe_input:
147F-BD 13 A4        985 ( 6)         jsr     skip_space
1482-27 31           986 ( 3)         beq     :end            ; 終端文字なら改行して終了
1484-BD 13 B0        987 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1487-24 0A           988 ( 3)         bcc     :1
1489-E6 00           989 ( 4)         ldab    0,x
148B-C1 3B           990 ( 2)         cmpb    #';'
148D-26 29           991 ( 3)         bne     :err00
148F-08              992 ( 1)         inx
1490-BD 13 A4        993 ( 6)         jsr     skip_space
1493-BD 13 8F        994 ( 6) .1      jsr     is_variable
1496-24 20           995 ( 3)         bcc     :err00
1498-86 01           996 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
149A-58              997 ( 1)         aslb                    ; B = 変数領域の下位バイト
149B-DD 8B           998 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
149D-                999            ; // 変数の後に余計な文字がないか確認
149D-               1000            ; // 例えば "input a+b" など
149D-DF 8D          1001 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
149F-BD 13 A4       1002 ( 6)         jsr     skip_space
14A2-27 06          1003 ( 3)         beq     :read           ; 終端文字なら入力へ
14A4-C1 3A          1004 ( 2)         cmpb    #':'            ; ":"なら入力へ
14A6-26 10          1005 ( 3)         bne     :err00          ; それ以外の文字ならエラー
14A8-DE 8D          1006 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
14AA-BD FF A9       1007 ( 6) .read   jsr     read_line
14AD-CE 01 00       1008 ( 3)         ldx     #Rx_BUFFER
14B0-BD 13 E1       1009 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
14B3-DE 8D          1010 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
14B5-7E 10 80       1011 ( 3) .end    jmp     is_multi
14B8-4F             1012 ( 1) .err00  clra                    ; "Syntax error"
14B9-7E 15 85       1013 ( 3)         jmp     write_err_msg
14BC-               1014
14BC-               1015
14BC-               1016      ; -----------------------------------------------------------------------
14BC-               1017      ; if文を実行する
14BC-               1018      ; Execute 'if' statement
14BC-               1019      ;【引数】X:実行位置アドレス
14BC-               1020      ;【使用】B, X
14BC-               1021      ;【返値】なし
14BC-               1022      ; -----------------------------------------------------------------------
14BC-BD 13 A4       1023 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
14BF-27 0B          1024 ( 3)         beq     :end            ; 終端文字なら終了
14C1-BD 10 DE       1025 ( 6)         jsr     eval_expression ; 式評価
14C4-24 09          1026 ( 3)         bcc     :err04
14C6-5D             1027 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
14C7-27 03          1028 ( 3)         beq     :end
14C9-7E 10 A0       1029 ( 3)         jmp     exe_line        ; True
14CC-7E 10 90       1030 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
14CF-86 04          1031 ( 2) .err04  ldaa    #4              ; "Illegal expression"
14D1-7E 15 85       1032 ( 3)         jmp     write_err_msg
14D4-               1033
14D4-               1034
14D4-               1035      ; ------------------------------------------------
14D4-               1036      ; ブロック転送
14D4-               1037      ; Copy memory
14D4-               1038      ;【引数】Source:転送元アドレス
14D4-               1039      ;        Destination:転送先アドレス
14D4-               1040      ;        Bytes:転送バイト数
14D4-               1041      ;【使用】A, B, X, R0
14D4-               1042      ;【返値】なし
14D4-               1043      ; ------------------------------------------------
14D4-               1044      mem_copy:
009F-               1045      .Offset .eq     UR0
14D4-DC 94          1046 ( 4)         ldd     <Bytes
14D6-27 33          1047 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
14D8-               1048            ; // オフセットの計算
14D8-DC 92          1049 ( 4)         ldd     <Destination    ; dst - src
14DA-93 90          1050 ( 4)         subd    <Source
14DC-DD 9F          1051 ( 4)         std     <:Offset        ; offset = dst - src
14DE-               1052            ; // 終了判定用のアドレスを計算
14DE-DC 90          1053 ( 4)         ldd     <Source
14E0-D3 94          1054 ( 4)         addd    <Bytes          ; src + bytes = 転元終了アドレス
14E2-DD 92          1055 ( 4)         std     <Destination    ; 転送終了アドレスを代入
14E4-               1056            ; // 転送開始
14E4-DE 90          1057 ( 4)         ldx     <Source         ; 転送開始アドレスを代入
14E6-               1058            ; // 転送するバイト数が奇数か偶数か判断。
14E6-               1059            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
14E6-DC 94          1060 ( 4)         ldd     <Bytes
14E8-04             1061 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
14E9-24 0E          1062 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
14EB-               1063            ; // Byte転送
14EB-A6 00          1064 ( 4)         ldaa    0,x             ; A <- [source]
14ED-18             1065 ( 2)         xgdx                    ; D = address, X = data
14EE-D3 9F          1066 ( 4)         addd    <:Offset        ; src - offset = dst
14F0-18             1067 ( 2)         xgdx                    ; D = data, X = address
14F1-A7 00          1068 ( 4)         staa    0,x             ; [dst] <- A
14F3-18             1069 ( 2)         xgdx                    ; D = address, X = data
14F4-93 9F          1070 ( 4)         subd    <:Offset        ; dst + offset = src
14F6-18             1071 ( 2)         xgdx                    ; D = data, X = address
14F7-20 0D          1072 ( 3)         bra     :odd
14F9-               1073            ; // Word転送
14F9-EC 00          1074 ( 5) .loop   ldd     0,x
14FB-18             1075 ( 2)         xgdx
14FC-D3 9F          1076 ( 4)         addd    <:Offset
14FE-18             1077 ( 2)         xgdx
14FF-ED 00          1078 ( 5)         std     0,x
1501-18             1079 ( 2)         xgdx
1502-93 9F          1080 ( 4)         subd    <:Offset
1504-18             1081 ( 2)         xgdx
1505-08             1082 ( 1)         inx
1506-08             1083 ( 1) .odd    inx
1507-9C 92          1084 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
1509-26 EE          1085 ( 3)         bne     :loop
150B-39             1086 ( 5) .end    rts
150C-               1087
150C-               1088
150C-               1089      ; -----------------------------------------------------------------------
150C-               1090      ; テーブル検索
150C-               1091      ; Search the keyword table
150C-               1092      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
150C-               1093      ;【使用】A, B, X
150C-               1094      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
150C-               1095      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
150C-               1096      ; -----------------------------------------------------------------------
150C-               1097      search_table:
150C-EC 05          1098 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
150E-91 A7          1099 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1510-26 2F          1100 ( 3)         bne     :false
1512-D1 A8          1101 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
1514-26 2B          1102 ( 3)         bne     :false
1516-EC 07          1103 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
1518-4D             1104 ( 1)         tsta                    ; $00（終端記号）か？
1519-27 1B          1105 ( 3)         beq     :true
151B-91 A9          1106 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
151D-26 22          1107 ( 3)         bne     :false
151F-5D             1108 ( 1)         tstb                    ; $00（終端記号）か？
1520-27 14          1109 ( 3)         beq     :true
1522-D1 AA          1110 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
1524-26 1B          1111 ( 3)         bne     :false
1526-EC 09          1112 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
1528-4D             1113 ( 1)         tsta                    ; $00（終端記号）か？
1529-27 0B          1114 ( 3)         beq     :true
152B-91 AB          1115 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
152D-26 12          1116 ( 3)         bne     :false
152F-5D             1117 ( 1)         tstb                    ; $00（終端記号）か？
1530-27 04          1118 ( 3)         beq     :true
1532-D1 AC          1119 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
1534-26 0B          1120 ( 3)         bne     :false
1536-E6 02          1121 ( 4) .true   ldab    2,x             ; B = 語長
1538-EE 03          1122 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
153A-31             1123 ( 1)         ins                     ; 元のリターンアドレスを削除
153B-31             1124 ( 1)         ins
153C-3C             1125 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
153D-DE 8D          1126 ( 4)         ldx     <ExePointer
153F-3A             1127 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1540-39             1128 ( 5)         rts                     ; 命令ルーチンにジャンプ
1541-EE 00          1129 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1543-26 C7          1130 ( 3)         bne     :top
1545-DE 8D          1131 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
1547-0C             1132 ( 1)         clc                     ; false: C=0
1548-39             1133 ( 5)         rts
1549-               1134
1549-               1135
1549-               1136      ; ***********************************************************************
1549-               1137      ;   キーワードテーブル Keyword table
1549-               1138      ; ***********************************************************************
1549-               1139      ; レコードの構造 Record structure
1549-               1140      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1549-               1141      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
1549-               1142      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
1549-               1143      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1549-               1144      ; キーワードは2文字以上6文字以下
1549-               1145      CMD_TABLE
1549-15 52          1146      .run            .dw     :new
154B-03             1147                      .db     3
154C-13 F5          1148                      .dw     exe_run
154E-72 75 6E 00    1149                      .az     "run"
1552-15 5B          1150      .new            .dw     :list
1554-03             1151                      .db     3
1555-10 03          1152                      .dw     cold_start
1557-6E 65 77 00    1153                      .az     "new"
155B-15 65          1154      .list           .dw     SMT_TABLE:print
155D-04             1155                      .db     4
155E-14 1A          1156                      .dw     exe_list
1560-6C 69 73 74 
     00             1157                      .az     "list"
1565-               1158      SMT_TABLE
1565-15 70          1159      .print          .dw     :input
1567-05             1160                      .db     5
1568-14 35          1161                      .dw     exe_print
156A-70 72 69 6E 
     74 00          1162                      .az     "print"
1570-15 7B          1163      .input          .dw     :if
1572-05             1164                      .db     5
1573-14 7F          1165                      .dw     exe_input
1575-69 6E 70 75 
     74 00          1166                      .az     "input"
157B-15 83          1167      .if             .dw     :bottom
157D-02             1168                      .db     2
157E-14 BC          1169                      .dw     exe_if
1580-69 66 00       1170                      .az     "if"
1583-00 00          1171      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
1585-               1172
1585-               1173
1585-               1174      ; -----------------------------------------------------------------------
1585-               1175      ; エラーメッセージを表示する
1585-               1176      ; Write Error Messege
1585-               1177      ;【引数】A: エラーコード
1585-               1178      ;【使用】A, B, X
1585-               1179      ;【返値】なし
1585-               1180      ; -----------------------------------------------------------------------
1585-               1181      write_err_msg:
1585-7D 00 39       1182 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
1588-27 03          1183 ( 3)         beq     :1
158A-BD FF B2       1184 ( 6)         jsr     write_crlf
158D-CE 15 A6       1185 ( 3) .1      ldx     #ERRMSG
1590-BD FF AF       1186 ( 6)         jsr     write_line
1593-16             1187 ( 1)         tab
1594-CE 15 AE       1188 ( 3)         ldx     #ERRCODE
1597-3A             1189 ( 1)         abx
1598-EE 00          1190 ( 5)         ldx     0,x
159A-BD FF AF       1191 ( 6)         jsr     write_line
159D-BD FF B2       1192 ( 6)         jsr     write_crlf
15A0-DE 80          1193 ( 4)         ldx     <StackPointer
15A2-35             1194 ( 1)         txs
15A3-7E 10 1A       1195 ( 3)         jmp     tb_main
15A6-               1196
15A6-45 52 52 4F 
     52 3A 20 00    1197      ERRMSG  .az     "ERROR: "
15AE-15 BE          1198      ERRCODE .dw     .err00
15B0-15 CB          1199              .dw     .err02
15B2-15 DE          1200              .dw     .err04
15B4-15 F1          1201              .dw     .err06
15B6-16 0A          1202              .dw     .err08
15B8-16 16          1203              .dw     .err10
15BA-16 2C          1204              .dw     .err12
15BC-16 40          1205              .dw     .err14
15BE-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1206      .err00  .az     "Syntax error"
15CB-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1207      .err02  .az     "Out of range value"
15DE-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1208      .err04  .az     "Illegal expression"
15F1-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1209      .err06  .az     "Calculate stack overflow"
160A-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1210      .err08  .az     "Zero Divide"
1616-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1211      .err10  .az     "Print statement error"
162C-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1212      .err12  .az     "Invalid line number"
1640-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1213      .err14  .az     "Memory size over"
1651-               1214
1651-               1215
1651-               1216      ; ***********************************************************************
1651-               1217      ;   デバック用ルーチン Debugging routines
1651-               1218      ; ***********************************************************************
1651-               1219      ; -----------------------------------------------------------------------
1651-               1220      ; ユーザーレジスタを表示する
1651-               1221      ; Display user registers
1651-               1222      ; -----------------------------------------------------------------------
1651-36             1223 ( 4) PUTUR:  psha
1652-37             1224 ( 4)         pshb
1653-3C             1225 ( 5)         pshx
1654-CE 16 87       1226 ( 3)         ldx     #:MSGUR0
1657-BD FF AF       1227 ( 6)         jsr     write_line
165A-DC 9F          1228 ( 4)         ldd     <UR0
165C-BD FF BB       1229 ( 6)         jsr     write_word
165F-CE 16 8C       1230 ( 3)         ldx     #:MSGUR1
1662-BD FF AF       1231 ( 6)         jsr     write_line
1665-DC A1          1232 ( 4)         ldd     <UR1
1667-BD FF BB       1233 ( 6)         jsr     write_word
166A-CE 16 92       1234 ( 3)         ldx     #:MSGUR2
166D-BD FF AF       1235 ( 6)         jsr     write_line
1670-DC A3          1236 ( 4)         ldd     <UR2
1672-BD FF BB       1237 ( 6)         jsr     write_word
1675-CE 16 98       1238 ( 3)         ldx     #:MSGUR3
1678-BD FF AF       1239 ( 6)         jsr     write_line
167B-DC A5          1240 ( 4)         ldd     <UR3
167D-BD FF BB       1241 ( 6)         jsr     write_word
1680-BD FF B2       1242 ( 6)         jsr     write_crlf
1683-38             1243 ( 4)         pulx
1684-33             1244 ( 3)         pulb
1685-32             1245 ( 3)         pula
1686-39             1246 ( 5)         rts
1687-55 52 30 3D 
     00             1247      .MSGUR0          .az     "UR0="
168C-20 55 52 31 
     3D 00          1248      .MSGUR1          .az     " UR1="
1692-20 55 52 32 
     3D 00          1249      .MSGUR2          .az     " UR2="
1698-20 55 52 33 
     3D 00          1250      .MSGUR3          .az     " UR3="
