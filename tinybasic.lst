0000-                 14
0000-                 15      ; ***********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ***********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ***********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0011-                 46      XON             .eq     $11     ; DC1
0013-                 47      XOFF            .eq     $13     ; DC3
0000-                 48
0020-                 49      RAM_START       .eq     $0020
1FFF-                 50      RAM_END         .eq     $1fff
E000-                 51      ROM_START       .eq     $e000
FFFF-                 52      ROM_END         .eq     $ffff
1000-                 53      PROGRAM_START   .eq     $1000   ; プログラム開始アドレス
0FFF-                 54      STACK           .eq     $0fff
0000-                 55
0400-                 56      USER_AREA_TOP   .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 57      USER_AREA_BTM   .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 58
0000-                 59      ; ***********************************************************************
0000-                 60      ;   システム変数 System variables
0000-                 61      ; ***********************************************************************
0000-                 62              .sm     RAM
0020-                 63              .or     $20
0020-                 64
0020-                 65      ; Interrupt Vector Hooking
0020-                 66      VEC_TRAP        .bs     3
0023-                 67      VEC_SCI         .bs     3
0026-                 68      VEC_TOF         .bs     3
0029-                 69      VEC_OCF         .bs     3
002C-                 70      VEC_ICF         .bs     3
002F-                 71      VEC_IRQ         .bs     3
0032-                 72      VEC_SWI         .bs     3
0035-                 73      VEC_NMI         .bs     3
0038-                 74      BreakPointFlag  .bs     1
0039-                 75      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 76      RxBffrQty       .bs     1       ; 受信バッファデータ数
003B-                 77      RxBffrReadPtr   .bs     2       ; 受信バッファ読み込みポインタ
003D-                 78      RxBffrWritePtr  .bs     2       ; 受信バッファ書き込みポインタ
003F-                 79      ; General-Purpose Registers
003F-                 80      R0              .bs     2
0041-                 81      R1              .bs     2
0043-                 82
0043-                 83      ; ***********************************************************************
0043-                 84      ;   システムワークエリア System work area
0043-                 85      ; ***********************************************************************
0043-                 86              .sm     RAM
0100-                 87              .or     $0100
0100-                 88      ; 各種バッファ
0100-                 89      Rx_BUFFER       .bs     64      ; 受信バッファ（$0100-$013f）
013F-                 90      Rx_BUFFER_END   .eq     *-1
0040-                 91      Rx_BFFR_SIZE    .eq     Rx_BUFFER_END-Rx_BUFFER+1
0140-                 92      TEXT_BFFR       .bs     73      ; テキストバッファ（$0140-$188: 73byte）
0188-                 93      TEXT_BFFR_END   .eq     *-1
0049-                 94      TEXT_BFFR_SIZE  .eq     TEXT_BFFR_END-TEXT_BFFR+1
0189-                 95
0189-                 96      ; ***********************************************************************
0189-                 97      ;   変数 Variables
0189-                 98      ; ***********************************************************************
0189-                 99              .sm     RAM
0080-                100              .or     $80
0080-                101
0080-                102      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                103      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                104      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                105      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                106      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                107      Divisor         .bs     2       ; 除数
0089-                108      Remainder       .bs     2       ; 剰余
008B-                109      VariableAddr    .bs     2       ; 変数のアドレス
008D-                110      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                111      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                112      Source          .bs     2       ; 転送元アドレス
0092-                113      Destination     .bs     2       ; 転送先アドレス
0094-                114      Bytes           .bs     2       ; 転送バイト数
0096-                115      LineNumber      .bs     2       ; 行番号
0098-                116      LineLength      .bs     2       ; 行の長さ
009A-                117      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                118      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                119      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                120      ModuloMode      .bs     1       ; 剰余演算フラグ 0 = tranc, 1以上 = floor
00A0-                121      ToSubFlag       .bs     1       ; 分岐モードフラグ 0 = goto, 1 = gosub
00A1-                122      SStackPtr       .bs     2       ; サブルーチンスタック（Subroutine stack）ポインタ
00A3-                123
00A3-                124      ; General-Purpose Registers
00A3-                125      UR0             *
00A3-                126      UR0H            .bs     1
00A4-                127      UR0L            .bs     1
00A5-                128      UR1             *
00A5-                129      UR1H            .bs     1
00A6-                130      UR1L            .bs     1
00A7-                131      UR2             *
00A7-                132      UR2H            .bs     1
00A8-                133      UR2L            .bs     1
00A9-                134      UR3             *
00A9-                135      UR3H            .bs     1
00AA-                136      UR3L            .bs     1
00AB-                137      ; Work area
00AB-                138      COMPARE         .bs     6       ; 文字列比較用バッファ
00B1-                139
00B1-                140      ; ***********************************************************************
00B1-                141      ;   ワークエリア work area
00B1-                142      ; ***********************************************************************
00B1-                143              .sm     RAM
0200-                144              .or     $0200
0200-                145      CSTACK          .bs     40      ; 計算スタック (Calculate stack)
0227-                146      CSTACK_BTM      .eq     *-1
0028-                147      CSTACK_SIZE     .eq     CSTACK_BTM-CSTACK+1
0228-                148      SSTACK          .bs     40      ; サブルーチンスタック (Subroutine stack)
024F-                149      SSTACK_BTM      .eq     *-1
0028-                150      SSTACK_SIZE     .eq     SSTACK_BTM-SSTACK+1
02C2-                151              .or     $02c2
02C2-                152      VARIABLE        .bs     52      ; 変数26文字 ($01c2-01f5)
02F5-                153      VARIABLE_END    .eq     *-1
0034-                154      VARIABLE_SIZE   .eq     VARIABLE_END-VARIABLE+1
02F6-                155
02F6-                156      ; ***********************************************************************
02F6-                157      ;   Program Start
02F6-                158      ; ***********************************************************************
0000-                159              .sm     CODE
1000-                160              .or     PROGRAM_START
1000-                161
1000-                162      init_tinybasic:
1000-30              163 ( 1)         tsx
1001-DF 80           164 ( 4)         stx     <StackPointer
1003-                165
1003-                166
1003-                167      cold_start:
1003-                168            ; // プログラムエリアの初期化
1003-CE 04 00        169 ( 3)         ldx     #USER_AREA_TOP
1006-DF 9A           170 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              171 ( 1)         clra
1009-5F              172 ( 1)         clrb
100A-ED 00           173 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           174 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                175            ; // 各種フラグの初期化
100E-97 9F           176 ( 3)         staa    <ModuloMode     ; 剰余演算をtrunc（0への切捨て除算）にする
1010-97 A0           177 ( 3)         staa    <ToSubFlag      ; 分岐モードを0 = gotoにする
1012-                178            ; // 変数領域の初期化
1012-CE 02 C2        179 ( 3)         ldx     #VARIABLE
1015-ED 00           180 ( 5) .loop   std     0,x
1017-08              181 ( 1)         inx
1018-08              182 ( 1)         inx
1019-8C 02 F6        183 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
101C-26 F7           184 ( 3)         bne     :loop
101E-                185            ; // スタックポインタの初期化
101E-CE 02 50        186 ( 3)         ldx     #SSTACK_BTM+1
1021-DF A1           187 ( 4)         stx     <SStackPtr
1023-                188
1023-                189
1023-                190      tb_main:
1023-72 01 9C        191 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
1026-C6 3E           192 ( 2)         ldab    #'>'
1028-BD FF AC        193 ( 6)         jsr     write_char
102B-BD FF A9        194 ( 6)         jsr     read_line
102E-CE 01 40        195 ( 3)         ldx     #TEXT_BFFR      ; 実行位置アドレスをセット
1031-                196            ; // 行番号判定
1031-BD 14 27        197 ( 6)         jsr     get_int_from_decimal
1034-24 0A           198 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
1036-83 00 00        199 ( 3)         subd    #0
1039-2E 08           200 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
103B-86 0C           201 ( 2) .err12  ldaa    #12             ; "Invalid line number"
103D-7E 17 DC        202 ( 3)         jmp     write_err_msg
1040-                203
1040-                204      ; 実行モード（ダイレクトモード）
1040-                205      execute_mode:
1040-7E 11 6B        206 ( 3)         jmp     exe_line
1043-                207
1043-                208      ; 行編集モード
1043-                209      ; 空行か否か、空行でなければ同じ行番号か否かで処理を振り分ける
1043-                210      edit_mode:
1043-DF 8D           211 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1045-DD 96           212 ( 4)         std     <LineNumber     ; 行番号を保存
1047-                213            ; // 空行チェック
1047-BD 14 F0        214 ( 6)         jsr     skip_space
104A-26 02           215 ( 3)         bne     :1
104C-20 1B           216 ( 3)         bra     delete_line     ; 空行だったら削除ルーチンへ
104E-                217      .1    ; // 入力行の長さチェック（Aレジスタに文字数）
104E-DE 8D           218 ( 4)         ldx     <ExePointer     ; バッファアドレスを復帰
1050-86 04           219 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1052-E6 00           220 ( 4) .loop   ldab    0,x
1054-27 04           221 ( 3)         beq     :2
1056-4C              222 ( 1)         inca                    ; 行の長さを+1
1057-08              223 ( 1)         inx                     ; バッファアドレスを+1
1058-20 F8           224 ( 3)         bra     :loop
105A-97 99           225 ( 3) .2      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
105C-                226            ; // 同じ行があるかどうか確認
105C-CE 04 00        227 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
105F-BD 15 41        228 ( 6)         jsr     scan_line_num   ; 行番号検索
1062-DF 9D           229 ( 4)         stx     <ExeLineAddr    ; 検索した行アドレスをExeLineAddrに退避しておく
1064-24 29           230 ( 3)         bcc     not_same_line_num
1066-7E 10 EF        231 ( 3)         jmp     same_line_num
1069-                232
1069-                233      ; 一行削除
1069-                234      delete_line:
1069-CE 04 00        235 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
106C-BD 15 41        236 ( 6)         jsr     scan_line_num   ; 行番号検索
106F-24 1B           237 ( 3)         bcc     :end            ; 同じ行がなければ何もしない
1071-                238            ; // 転送先アドレスの設定（既存の行の先頭アドレス）
1071-DF 92           239 ( 4)         stx     <Destination
1073-                240            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1073-E6 02           241 ( 4)         ldab    2,x
1075-D7 99           242 ( 3)         stab    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存しておく
1077-3A              243 ( 1)         abx
1078-DF 90           244 ( 4)         stx     <Source
107A-                245            ; // 転送バイト数の設定（プログラム終端アドレス - 次の行の先頭アドレス + 2）
107A-DC 9A           246 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
107C-93 90           247 ( 4)         subd    <Source         ; - 次の行の先頭アドレス
107E-C3 00 02        248 ( 3)         addd    #2              ; + 2
1081-DD 94           249 ( 4)         std     <Bytes
1083-                250            ; // ブロック転送
1083-BD 16 BC        251 ( 6)         jsr     mem_move
1086-                252            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス - 行の長さ）
1086-DC 9A           253 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1088-93 98           254 ( 4)         subd    <LineLength     ; - 行の長さ
108A-DD 9A           255 ( 4)         std     <PrgmEndAddr
108C-7E 10 23        256 ( 3) .end    jmp     tb_main
108F-                257
108F-                258      ; 同じ行番号がなかった場合の処理
108F-                259      not_same_line_num:
108F-                260            ; // D:次に大きな行番号 X:次に大きな行の先頭アドレス
108F-83 00 00        261 ( 3)         subd    #0              ; tstd
1092-27 22           262 ( 3)         beq     :add            ; 最終行より後ろ（D=$0000）だったら入力行挿入
1094-                263            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
1094-DC 9A           264 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1096-D3 98           265 ( 4)         addd    <LineLength     ; + 行の長さ
1098-8D 48           266 ( 5)         bsr     check_pgrm_end
109A-DD 9A           267 ( 4)         std     <PrgmEndAddr
109C-                268            ; // 転送元アドレスの設定（次に大きな行の先頭アドレス）
109C-DF 90           269 ( 4)         stx     <Source
109E-                270            ; // 転送先アドレスの設定（次に大きな行の先頭アドレス + 行の長さ）
109E-D6 99           271 ( 3)         ldab    <LineLength+1   ; 行の長さ
10A0-3A              272 ( 1)         abx                     ; + 次に大きな行の先頭アドレス
10A1-DF 92           273 ( 4)         stx     <Destination
10A3-                274            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
10A3-DC 9A           275 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10A5-93 90           276 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
10A7-C3 00 02        277 ( 3)         addd    #2              ; + 2
10AA-DD 94           278 ( 4)         std     <Bytes
10AC-                279            ; // ブロック転送
10AC-BD 16 BC        280 ( 6)         jsr     mem_move
10AF-                281            ; // 入力行の挿入
10AF-DE 9D           282 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
10B1-8D 16           283 ( 5)         bsr     insert_new_line
10B3-7E 10 23        284 ( 3)         jmp     tb_main
10B6-                285      .add
10B6-                286            ; // D:$0000 X:プログラム終端アドレス
10B6-                287            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10B6-DC 9A           288 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10B8-D3 98           289 ( 4)         addd    <LineLength     ; + 行の長さ
10BA-8D 26           290 ( 5)         bsr     check_pgrm_end
10BC-DD 9A           291 ( 4)         std     <PrgmEndAddr
10BE-                292            ; // 入力行の挿入
10BE-8D 09           293 ( 5)         bsr     insert_new_line
10C0-                294            ; // 終端行の挿入
10C0-DE 9A           295 ( 4)         ldx     <PrgmEndAddr
10C2-4F              296 ( 1)         clra
10C3-5F              297 ( 1)         clrb
10C4-ED 00           298 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
10C6-7E 10 23        299 ( 3)         jmp     tb_main
10C9-                300
10C9-                301      ; 入力行の転送
10C9-                302      insert_new_line:
10C9-DC 96           303 ( 4)         ldd     <LineNumber     ; 行番号を転送
10CB-ED 00           304 ( 5)         std     0,x
10CD-08              305 ( 1)         inx
10CE-08              306 ( 1)         inx
10CF-D6 99           307 ( 3)         ldab    <LineLength+1   ; 行の長さを転送
10D1-E7 00           308 ( 4)         stab    0,x
10D3-08              309 ( 1)         inx
10D4-                310            ; // 転送先アドレスの設定（現在の位置）
10D4-DF 92           311 ( 4)         stx     <Destination
10D6-                312            ; // 転送バイト数の設定（行の長さ - 3（行番号 - 長さ））
10D6-4F              313 ( 1)         clra                    ; 行の長さ（A=0,B=下位8bit）
10D7-C0 03           314 ( 2)         subb    #3              ; - 3
10D9-DD 94           315 ( 4)         std     <Bytes
10DB-                316            ; // 転送元アドレスの設定（入力された行）
10DB-DC 8D           317 ( 4)         ldd     <ExePointer     ; バッファアドレスを復帰（行番号の直後を指している）
10DD-DD 90           318 ( 4)         std     <Source
10DF-                319            ; // ブロック転送
10DF-7E 16 BC        320 ( 3)         jmp     mem_move        ; 飛び先でrts
10E2-                321
10E2-                322      ; プログラムエリアを超えていないか確認
10E2-                323      check_pgrm_end:
10E2-18              324 ( 2)         xgdx
10E3-8C 0D FD        325 ( 3)         cpx     #USER_AREA_BTM
10E6-18              326 ( 2)         xgdx
10E7-24 01           327 ( 3)         bcc     :err14
10E9-39              328 ( 5)         rts
10EA-86 0E           329 ( 2) .err14  ldaa    #14              ; "Memory size over"
10EC-7E 17 DC        330 ( 3)         jmp     write_err_msg
10EF-                331
10EF-                332      ; 同じ行番号があった場合、既存の行との長さの差で処理を振り分ける
10EF-                333      same_line_num:
10EF-                334            ; // D:行番号 X:既存の行の開始アドレス
10EF-96 99           335 ( 3)         ldaa    <LineLength+1   ; 入力行の長さを取得
10F1-A0 02           336 ( 4)         suba    2,x             ; **Aレジスタ** = 入力行の長さ - 既存行の長さ
10F3-2B 2E           337 ( 3)         bmi     short_length    ; 入力行の長さ < 既存行の長さ
10F5-27 27           338 ( 3)         beq     same_length     ; 入力行の長さ = 既存行の長さ
10F7-                339
10F7-                340      ; 入力行が既存の行より長い場合
10F7-                341      long_length:                    ; 入力行の長さ > 既存行の長さ
10F7-                342            ; // 転送元アドレスの設定（次の行の先頭アドレス）
10F7-E6 02           343 ( 4)         ldab    2,x
10F9-3A              344 ( 1)         abx
10FA-DF 90           345 ( 4)         stx     <Source
10FC-                346            ; // 転送先アドレスの設定（次の行の先頭アドレス + 入力行の長さ - 既存行の長さ）
10FC-16              347 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
10FD-4F              348 ( 1)         clra
10FE-DD A5           349 ( 4)         std     <UR1            ; 入力行の長さ - 既存行の長さを後で使うためにUR1に保存
1100-3A              350 ( 1)         abx                     ; 次の行の先頭アドレス + （入力行の長さ - 既存行の長さ）
1101-DF 92           351 ( 4)         stx     <Destination
1103-                352            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1103-DC 9A           353 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1105-93 90           354 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1107-C3 00 02        355 ( 3)         addd    #2              ; + 2
110A-DD 94           356 ( 4)         std     <Bytes
110C-                357            ; // 新しいプログラム終端アドレスの設定
110C-                358            ; // （プログラム終端アドレス + 入力行の長さ - 既存行の長さ）
110C-DC 9A           359 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
110E-D3 A5           360 ( 4)         addd    <UR1            ; + 入力行の長さ - 既存行の長さ
1110-8D D0           361 ( 5)         bsr     check_pgrm_end
1112-DD 9A           362 ( 4)         std     <PrgmEndAddr
1114-                363            ; // ブロック転送
1114-BD 16 BC        364 ( 6)         jsr     mem_move
1117-                365            ; // 入力行の挿入
1117-DE 9D           366 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1119-8D AE           367 ( 5)         bsr     insert_new_line
111B-7E 10 23        368 ( 3)         jmp     tb_main
111E-                369
111E-                370      ; 入力行と既存の行が同じ長さの場合
111E-                371      same_length:
111E-8D A9           372 ( 5)         bsr     insert_new_line
1120-7E 10 23        373 ( 3)         jmp     tb_main
1123-                374
1123-                375      ; 入力行が既存の行より短い場合
1123-                376      short_Length:
1123-                377            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1123-E6 02           378 ( 4)         ldab    2,x
1125-3A              379 ( 1)         abx
1126-DF 90           380 ( 4)         stx     <Source
1128-                381            ; // 転送先アドレスの設定（次の行の先頭アドレス - 既存行の長さ + 入力行の長さ）
1128-16              382 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
1129-50              383 ( 1)         negb                    ; 絶対値にする
112A-4F              384 ( 1)         clra
112B-DD A5           385 ( 4)         std     <UR1            ; 既存行の長さ - 入力行の長さ
112D-18              386 ( 2)         xgdx
112E-93 A5           387 ( 4)         subd    <UR1            ; 次の行の先頭アドレス - （既存行の長さ - 入力行の長さ）
1130-DD 92           388 ( 4)         std     <Destination
1132-                389            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1132-DC 9A           390 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1134-93 90           391 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1136-C3 00 02        392 ( 3)         addd    #2              ; + 2
1139-DD 94           393 ( 4)         std     <Bytes
113B-                394            ; // ブロック転送
113B-BD 16 BC        395 ( 6)         jsr     mem_move
113E-                396            ; // 新しいプログラム終端アドレスの設定
113E-                397            ; // （プログラム終端アドレス - 既存行の長さ + 入力行の長さ）
113E-DC 9A           398 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1140-93 A5           399 ( 4)         subd    <UR1            ; - （既存行の長さ - 入力行の長さ）
1142-DD 9A           400 ( 4)         std     <PrgmEndAddr
1144-                401            ; // 入力行の挿入
1144-DE 9D           402 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1146-8D 81           403 ( 5)         bsr     insert_new_line
1148-7E 10 23        404 ( 3)         jmp     tb_main
114B-                405
114B-                406
114B-                407      ; -----------------------------------------------------------------------
114B-                408      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
114B-                409      ; Is a multi statement mark?
114B-                410      ;【引数】X:実行位置アドレス
114B-                411      ;【使用】B, X
114B-                412      ;【返値】なし
114B-                413      ; -----------------------------------------------------------------------
114B-                414      is_multi:
114B-BD 14 F0        415 ( 6)         jsr     skip_space
114E-27 0B           416 ( 3)         beq     eol_process
1150-C1 3A           417 ( 2)         cmpb    #':'
1152-26 03           418 ( 3)         bne     :err00
1154-08              419 ( 1)         inx
1155-20 14           420 ( 3)         bra     exe_line
1157-4F              421 ( 1) .err00  clra                    ; "Syntax error"
1158-7E 17 DC        422 ( 3)         jmp     write_err_msg
115B-                423
115B-                424
115B-                425      ; -----------------------------------------------------------------------
115B-                426      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
115B-                427      ;  - directモードであればそのまま終了
115B-                428      ;  - runモードであれば次の行のポインタを設定してrts
115B-                429      ; End-of-line processing
115B-                430      ;  - If in direct mode, terminate execution
115B-                431      ;  - If run mode, set the pointer to the next line and rts
115B-                432      ;【引数】なし
115B-                433      ;【使用】A, B, X
115B-                434      ;【返値】なし
115B-                435      ; -----------------------------------------------------------------------
115B-                436      eol_process:
115B-                437            ; // runモードであれば次の行のポインタを設定してrts
115B-7D 00 9C        438 ( 4)         tst     <ExeStateFlag
115E-26 08           439 ( 3)         bne     :end
1160-DE 9D           440 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
1162-E6 02           441 ( 4)         ldab    2,x             ; 行の長さを取得
1164-3A              442 ( 1)         abx                     ; 次の行の先頭アドレスを取得
1165-DF 9D           443 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
1167-39              444 ( 5)         rts
1168-7E 10 23        445 ( 3) .end    jmp     tb_main         ; directモードであればそのまま終了
116B-                446
116B-                447
116B-                448      ; -----------------------------------------------------------------------
116B-                449      ; 一行実行
116B-                450      ; Execute one line
116B-                451      ;【引数】X:実行位置アドレス
116B-                452      ;【使用】A, B, X
116B-                453      ;【返値】なし
116B-                454      ; -----------------------------------------------------------------------
116B-                455      exe_line:
116B-BD 14 F0        456 ( 6)         jsr     skip_space
116E-27 EB           457 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
1170-                458            ; // 代入文のチェック
1170-BD 14 DB        459 ( 6)         jsr     is_variable     ; 変数か？
1173-24 12           460 ( 3)         bcc     :cmd            ; No. テーブル検索へ
1175-86 02           461 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1177-58              462 ( 1)         aslb                    ; B = 変数領域の下位バイト
1178-DD 8B           463 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
117A-BD 14 F0        464 ( 6)         jsr     skip_space      ; Yes. 代入文か？
117D-C1 3D           465 ( 2)         cmpb    #'='
117F-26 24           466 ( 3)         bne     :err00          ; No. エラー処理へ
1181-08              467 ( 1)         inx                     ; Yes. 代入実行
1182-BD 15 2D        468 ( 6)         jsr     assign_to_var
1185-20 C4           469 ( 3)         bra     is_multi
1187-                470            ; // コマンド・ステートメントのチェック
1187-EC 00           471 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
1189-DD AB           472 ( 4)         std     <COMPARE
118B-EC 02           473 ( 5)         ldd     2,x
118D-DD AD           474 ( 4)         std     <COMPARE+2
118F-EC 04           475 ( 5)         ldd     4,x
1191-DD AF           476 ( 4)         std     <COMPARE+4
1193-DF 8D           477 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
1195-7D 00 9C        478 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
1198-27 05           479 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
119A-CE 17 6A        480 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
119D-20 03           481 ( 3)         bra     :2
119F-CE 17 86        482 ( 3) .1      ldx     #SMT_TABLE
11A2-BD 17 2D        483 ( 6) .2      jsr     search_table    ; テーブル検索実行
11A5-4F              484 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
11A6-7E 17 DC        485 ( 3)         jmp     write_err_msg
11A9-                486
11A9-                487
11A9-                488      ; -----------------------------------------------------------------------
11A9-                489      ; 式を評価する
11A9-                490      ; Evaluate the expression
11A9-                491      ;【引数】B:アスキーコード X:実行位置アドレス
11A9-                492      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
11A9-                493      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
11A9-                494      ;        偽(C=0) / X:現在の実行位置アドレス
11A9-                495      ; -----------------------------------------------------------------------
11A9-                496      eval_expression:
00A7-                497      .SP     .eq     UR2
00A9-                498      .X      .eq     UR3
11A9-                499            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
11A9-DF A9           500 ( 4)         stx     <:X
11AB-30              501 ( 1)         tsx
11AC-DF A7           502 ( 4)         stx     <:SP
11AE-DE A9           503 ( 4)         ldx     <:X
11B0-                504            ; // 計算スタックの初期化
11B0-CC 02 28        505 ( 3)         ldd     #CSTACK_BTM+1
11B3-DD 82           506 ( 4)         std     <CStackPtr
11B5-                507            ; // 式評価開始
11B5-8D 08           508 ( 5)         bsr     expr_4th
11B7-                509            ; // 計算結果をスタックトップから取り出す
11B7-3C              510 ( 5)         pshx
11B8-DE 82           511 ( 4)         ldx     <CStackPtr
11BA-EC 00           512 ( 5)         ldd     0,x
11BC-38              513 ( 4)         pulx
11BD-0D              514 ( 1)         sec                     ; true:C=1
11BE-39              515 ( 5)         rts
11BF-                516
11BF-                517      expr_4th:
11BF-8D 50           518 ( 5)         bsr     expr_3rd
11C1-BD 14 F0        519 ( 6) .loop   jsr     skip_space
11C4-C1 3D           520 ( 2)         cmpb    #'='            ; '='?
11C6-26 08           521 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
11C8-08              522 ( 1)         inx
11C9-8D 46           523 ( 5)         bsr     expr_3rd
11CB-BD 13 DA        524 ( 6)         jsr     CS_eq           ; EQual to
11CE-20 F1           525 ( 3)         bra     :loop
11D0-C1 3C           526 ( 2) .ltsign cmpb    #'<'            ; '<'?
11D2-26 22           527 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
11D4-08              528 ( 1)         inx
11D5-E6 00           529 ( 4)         ldab    0,x
11D7-C1 3E           530 ( 2)         cmpb    #'>'            ; '<>'?
11D9-26 08           531 ( 3)         bne     :lte
11DB-08              532 ( 1)         inx
11DC-8D 33           533 ( 5)         bsr     expr_3rd
11DE-BD 13 FB        534 ( 6)         jsr     CS_ne           ; Not Equal to
11E1-20 DE           535 ( 3)         bra     :loop
11E3-C1 3D           536 ( 2) .lte    cmpb    #'='            ; '<='?
11E5-26 08           537 ( 3)         bne     :lt
11E7-08              538 ( 1)         inx
11E8-8D 27           539 ( 5)         bsr     expr_3rd
11EA-BD 13 F0        540 ( 6)         jsr     CS_lte          ; Less Than or Equal to
11ED-20 D2           541 ( 3)         bra     :loop
11EF-8D 20           542 ( 5) .lt     bsr     expr_3rd
11F1-BD 13 E5        543 ( 6)         jsr     CS_lt           ; Less Than
11F4-20 CB           544 ( 3)         bra     :loop
11F6-C1 3E           545 ( 2) .gtsign cmpb    #'>'            ; '>'?
11F8-26 16           546 ( 3)         bne     :end
11FA-08              547 ( 1)         inx
11FB-E6 00           548 ( 4)         ldab    0,x
11FD-C1 3D           549 ( 2)         cmpb    #'='            ; '>='?
11FF-26 08           550 ( 3)         bne     :gt
1201-08              551 ( 1)         inx
1202-8D 0D           552 ( 5)         bsr     expr_3rd
1204-BD 14 11        553 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
1207-20 B8           554 ( 3)         bra     :loop
1209-8D 06           555 ( 5) .gt     bsr     expr_3rd
120B-BD 14 06        556 ( 6)         jsr     CS_gt           ; Greater Than
120E-20 B1           557 ( 3)         bra     :loop
1210-39              558 ( 5) .end    rts
1211-                559
1211-                560      expr_3rd:
1211-8D 1C           561 ( 5)         bsr     expr_2nd
1213-BD 14 F0        562 ( 6) .loop   jsr     skip_space
1216-C1 2B           563 ( 2)         cmpb    #'+'
1218-26 08           564 ( 3)         bne     :minus
121A-08              565 ( 1)         inx
121B-8D 12           566 ( 5)         bsr     expr_2nd
121D-BD 12 A4        567 ( 6)         jsr     CS_add
1220-20 F1           568 ( 3)         bra     :loop
1222-C1 2D           569 ( 2) .minus  cmpb    #'-'
1224-26 08           570 ( 3)         bne     :end
1226-08              571 ( 1)         inx
1227-8D 06           572 ( 5)         bsr     expr_2nd
1229-BD 12 AD        573 ( 6)         jsr     CS_sub
122C-20 E5           574 ( 3)         bra     :loop
122E-39              575 ( 5) .end    rts
122F-                576
122F-                577      expr_2nd:
122F-8D 28           578 ( 5)         bsr     expr_1st
1231-BD 14 F0        579 ( 6) .loop   jsr     skip_space
1234-C1 2A           580 ( 2)         cmpb    #'*'
1236-26 08           581 ( 3)         bne     :div
1238-08              582 ( 1)         inx
1239-8D 1E           583 ( 5)         bsr     expr_1st
123B-BD 12 B6        584 ( 6)         jsr     CS_mul
123E-20 F1           585 ( 3)         bra     :loop
1240-C1 2F           586 ( 2) .div    cmpb    #'/'
1242-26 08           587 ( 3)         bne     :mod
1244-08              588 ( 1)         inx
1245-8D 12           589 ( 5)         bsr     expr_1st
1247-BD 12 D3        590 ( 6)         jsr     CS_div
124A-20 E5           591 ( 3)         bra     :loop
124C-C1 25           592 ( 2) .mod    cmpb    #'%'
124E-26 08           593 ( 3)         bne     :end
1250-08              594 ( 1)         inx
1251-8D 06           595 ( 5)         bsr     expr_1st
1253-BD 12 EC        596 ( 6)         jsr     CS_mod
1256-20 D9           597 ( 3)         bra     :loop
1258-39              598 ( 5) .end    rts
1259-                599
1259-                600      expr_1st:
00A7-                601      .SP     .eq     UR2
00A9-                602      .X      .eq     UR3
1259-BD 14 F0        603 ( 6)         jsr     skip_space
125C-BD 14 27        604 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
125F-24 02           605 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
1261-20 1D           606 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1263-BD 14 DB        607 ( 6) .var    jsr     is_variable     ; 変数か？
1266-24 0A           608 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
1268-                609            ; // 変数値の取得
1268-3C              610 ( 5)         pshx                    ; 実行位置アドレスを退避
1269-86 02           611 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
126B-58              612 ( 1)         aslb                    ; B = 変数領域の下位バイト
126C-18              613 ( 2)         xgdx                    ; X = 変数のアドレス
126D-EC 00           614 ( 5)         ldd     0,x             ; D <- 変数の値
126F-38              615 ( 4)         pulx                    ; 実行位置アドレスを復帰
1270-20 0E           616 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
1272-C1 28           617 ( 2) .paren  cmpb    #'('
1274-26 1A           618 ( 3)         bne     :err
1276-08              619 ( 1)         inx
1277-BD 11 BF        620 ( 6)         jsr     expr_4th
127A-C1 29           621 ( 2)         cmpb    #')'
127C-26 12           622 ( 3)         bne     :err
127E-08              623 ( 1)         inx
127F-39              624 ( 5)         rts
1280-3C              625 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1281-DE 82           626 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1283-09              627 ( 1)         dex
1284-09              628 ( 1)         dex
1285-8C 01 FE        629 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
1288-25 0D           630 ( 3)         bcs     :err06
128A-ED 00           631 ( 5)         std     0,x
128C-DF 82           632 ( 4)         stx     <CStackPtr
128E-38              633 ( 4)         pulx                    ; 実行位置アドレスを復帰
128F-39              634 ( 5)         rts
1290-                635            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
1290-DE A7           636 ( 4) .err    ldx     <:SP
1292-35              637 ( 1)         txs
1293-DE A9           638 ( 4)         ldx     <:X
1295-0C              639 ( 1)         clc                     ; false:C=0
1296-39              640 ( 5)         rts
1297-86 06           641 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
1299-7E 17 DC        642 ( 3)         jmp     write_err_msg
129C-                643
129C-                644      ;
129C-                645      ; Arithmetic operator
129C-                646      ;
129C-                647      CS_store:
129C-08              648 ( 1)         inx
129D-08              649 ( 1)         inx
129E-ED 00           650 ( 5)         std     0,x
12A0-DF 82           651 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
12A2-38              652 ( 4)         pulx                    ; 実行位置アドレスを復帰
12A3-39              653 ( 5)         rts
12A4-                654
12A4-3C              655 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
12A5-DE 82           656 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12A7-EC 02           657 ( 5)         ldd     2,x
12A9-E3 00           658 ( 5)         addd    0,x
12AB-20 EF           659 ( 3)         bra     CS_store
12AD-                660
12AD-3C              661 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
12AE-DE 82           662 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12B0-EC 02           663 ( 5)         ldd     2,x
12B2-A3 00           664 ( 5)         subd    0,x
12B4-20 E6           665 ( 3)         bra     CS_store
12B6-                666
12B6-                667      CS_mul:
00A3-                668      .Result         .eq     UR0
12B6-3C              669 ( 5)         pshx                    ; 実行位置アドレスを退避
12B7-DE 82           670 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12B9-                671              ; B * D
12B9-A6 03           672 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
12BB-E6 01           673 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
12BD-3D              674 ( 7)         mul                     ; B * D
12BE-DD A3           675 ( 4)         std     <:Result        ;「B*D」を保存
12C0-                676              ; A * D
12C0-EC 01           677 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
12C2-3D              678 ( 7)         mul                     ; A * D
12C3-DB A3           679 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
12C5-D7 A3           680 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
12C7-                681              ; C * B
12C7-A6 00           682 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
12C9-E6 03           683 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
12CB-3D              684 ( 7)         mul                     ; C * B
12CC-DB A3           685 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
12CE-17              686 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
12CF-D6 A4           687 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
12D1-20 C9           688 ( 3)         bra     CS_store
12D3-                689
12D3-                690      ;
12D3-                691      ; trunc : 符号付き割り算の考え方
12D3-                692      ; ・剰余は被除数の符号と同一
12D3-                693      ;   ・ 7 / 3  = 商  2、剰余  1
12D3-                694      ;   ・-7 / 3  = 商 -2、剰余 -1
12D3-                695      ;   ・ 7 / -3 = 商 -2、剰余  1
12D3-                696      ;   ・-7 / -3 = 商  2、剰余 -1
12D3-                697      ;
12D3-7D 00 9F        698 ( 4) CS_div: tst     <ModuloMode
12D6-26 7A           699 ( 3)         bne     CS_div2
12D8-3C              700 ( 5)         pshx                    ; 実行位置アドレスを退避
12D9-DE 82           701 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12DB-8D 2B           702 ( 5)         bsr     div_uint        ; 除算実行
12DD-18              703 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
12DE-7D 00 85        704 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
12E1-27 05           705 ( 3)         beq     :end            ; '+'なら終了
12E3-43              706 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
12E4-53              707 ( 1)         comb
12E5-C3 00 01        708 ( 3)         addd    #1
12E8-DE 82           709 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
12EA-20 B0           710 ( 3)         bra     CS_store
12EC-                711
12EC-7D 00 9F        712 ( 4) CS_mod: tst     <ModuloMode
12EF-26 7E           713 ( 3)         bne     CS_mod2
12F1-3C              714 ( 5)         pshx                    ; 実行位置アドレスを退避
12F2-DE 82           715 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12F4-8D 12           716 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
12F6-DD 89           717 ( 4)         std     <Remainder      ; 剰余はゼロか？
12F8-27 0A           718 ( 3)         beq     :end            ; ゼロであれば終了
12FA-7D 00 86        719 ( 4)         tst     <RemSignFlag    ; 剰余の符号チェック
12FD-27 05           720 ( 3)         beq     :end            ; '+'なら終了
12FF-43              721 ( 1) .sign   coma                    ; '-'なら2の補数にする
1300-53              722 ( 1)         comb
1301-C3 00 01        723 ( 3)         addd    #1
1304-DE 82           724 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1306-20 94           725 ( 3)         bra     CS_store
1308-                726
1308-                727      div_uint:
00A3-                728      .Counter        .eq     UR0H
1308-EC 00           729 ( 5)         ldd     0,x             ; ゼロ除算チェック
130A-27 41           730 ( 3)         beq     :err08          ; 除数がゼロならエラー
130C-5F              731 ( 1)         clrb
130D-D7 85           732 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
130F-D7 86           733 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1311-C6 10           734 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1313-D7 A3           735 ( 3)         stab    <:Counter
1315-                736              ; // 剰余の符号フラグの設定
1315-EC 02           737 ( 5)         ldd     2,x             ; Dレジスタに被除数を代入
1317-2A 03           738 ( 3)         bpl     :1              ; 被除数が正であれば剰余の符号は正（0）
1319-7C 00 86        739 ( 6)         inc     <RemSignFlag    ; 被除数が負であれば剰余の符号は負（1）
131C-                740              ; // 商の符号フラグの設定
131C-A8 00           741 ( 4) .1      eora    0,x             ; 被除数の符号と除数の符号のXORを取る
131E-2A 03           742 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
1320-7C 00 85        743 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
1323-                744              ; // 除数を絶対値にする
1323-EC 00           745 ( 5) .2      ldd     0,x             ; D <- 除数
1325-2A 05           746 ( 3)         bpl     :3
1327-43              747 ( 1)         coma                    ; 除数が負なら絶対値にする
1328-53              748 ( 1)         comb
1329-C3 00 01        749 ( 3)         addd    #1
132C-DD 87           750 ( 4) .3      std     <Divisor        ; 除数を保存
132E-                751              ; // 被除数を絶対値にする
132E-EC 02           752 ( 5)         ldd     2,x             ; D <- 被除数
1330-2A 05           753 ( 3)         bpl     :4
1332-43              754 ( 1)         coma                    ; 被除数が負なら絶対値にする
1333-53              755 ( 1)         comb
1334-C3 00 01        756 ( 3)         addd    #1
1337-                757              ; // 除算実行
1337-18              758 ( 2) .4      xgdx                    ; X <- 被除数
1338-4F              759 ( 1)         clra                    ; D（WORK）をクリア
1339-5F              760 ( 1)         clrb
133A-18              761 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
133B-05              762 ( 1)         asld
133C-18              763 ( 2)         xgdx
133D-59              764 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
133E-49              765 ( 1)         rola
133F-93 87           766 ( 4)         subd    <Divisor        ; WORK - 除数
1341-08              767 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
1342-24 03           768 ( 3)         bcc     :5              ; WORKから除数を引けた？
1344-D3 87           769 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1346-09              770 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1347-7A 00 A3        771 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
134A-26 EE           772 ( 3)         bne     :loop
134C-39              773 ( 5)         rts
134D-86 08           774 ( 2) .err08  ldaa    #8              ; "Zero Divide"
134F-7E 17 DC        775 ( 3)         jmp     write_err_msg
1352-                776
1352-                777      ;
1352-                778      ; floor : 符号付き割り算の考え方
1352-                779      ; ・剰余は除数の符号と同一
1352-                780      ;   ・ 7 / 3  = 商  2、剰余  1
1352-                781      ;   ・-7 / 3  = 商 -3、剰余  2
1352-                782      ;   ・ 7 / -3 = 商 -3、剰余 -2
1352-                783      ;   ・-7 / -3 = 商  2、剰余 -1
1352-                784      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
1352-                785      ;       2.ただし、除数がゼロの場合は1は足さない
1352-                786      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
1352-                787      ;         除数の絶対値から剰余の絶対値を引く
1352-                788      ;       2.その結果を除数と同じ符号にする
1352-                789      ;       3.ただし、除数がゼロの場合は剰余もゼロ
1352-                790      ;
1352-                791      CS_div2:
1352-3C              792 ( 5)         pshx                    ; 実行位置アドレスを退避
1353-DE 82           793 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1355-8D 39           794 ( 5)         bsr     div_uint2       ; 除算実行
1357-18              795 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1358-7D 00 85        796 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
135B-27 0D           797 ( 3)         beq     :end            ; '+'なら終了
135D-8C 00 00        798 ( 3)         cpx     #0              ; 剰余はゼロか？
1360-27 03           799 ( 3)         beq     :sign
1362-C3 00 01        800 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
1365-43              801 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1366-53              802 ( 1)         comb
1367-C3 00 01        803 ( 3)         addd    #1
136A-DE 82           804 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
136C-7E 12 9C        805 ( 3)         jmp     CS_store
136F-                806
136F-                807      CS_mod2:
136F-3C              808 ( 5)         pshx                    ; 実行位置アドレスを退避
1370-DE 82           809 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1372-8D 1C           810 ( 5)         bsr     div_uint2        ; 除算実行。D = 剰余
1374-DD 89           811 ( 4)         std     <Remainder      ; 剰余はゼロか？
1376-27 13           812 ( 3)         beq     :end            ; ゼロであれば終了
1378-7D 00 85        813 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
137B-27 04           814 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
137D-DC 87           815 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
137F-93 89           816 ( 4)         subd    <Remainder
1381-7D 00 86        817 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1384-27 05           818 ( 3)         beq     :end            ; '+'なら終了
1386-43              819 ( 1)         coma                    ; '-'なら2の補数にする
1387-53              820 ( 1)         comb
1388-C3 00 01        821 ( 3)         addd    #1
138B-DE 82           822 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
138D-7E 12 9C        823 ( 3)         jmp     CS_store
1390-                824
1390-                825      div_uint2:
00A3-                826      .Counter        .eq     UR0H
1390-EC 00           827 ( 5)         ldd     0,x             ; ゼロ除算チェック
1392-27 41           828 ( 3)         beq     :err08          ; 除数がゼロならエラー
1394-5F              829 ( 1)         clrb
1395-D7 85           830 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1397-D7 86           831 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1399-C6 10           832 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
139B-D7 A3           833 ( 3)         stab    <:Counter
139D-                834              ; // 剰余の符号フラグの設定
139D-EC 00           835 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
139F-2A 03           836 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
13A1-7C 00 86        837 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
13A4-                838              ; // 商の符号フラグの設定
13A4-A8 02           839 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
13A6-2A 03           840 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
13A8-7C 00 85        841 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
13AB-                842              ; // 除数を絶対値にする
13AB-EC 00           843 ( 5) .2      ldd     0,x             ; D <- 除数
13AD-2A 05           844 ( 3)         bpl     :3
13AF-43              845 ( 1)         coma                    ; 除数が負なら絶対値にする
13B0-53              846 ( 1)         comb
13B1-C3 00 01        847 ( 3)         addd    #1
13B4-DD 87           848 ( 4) .3      std     <Divisor        ; 除数を保存
13B6-                849              ; // 被除数を絶対値にする
13B6-EC 02           850 ( 5)         ldd     2,x             ; D <- 被除数
13B8-2A 05           851 ( 3)         bpl     :4
13BA-43              852 ( 1)         coma                    ; 被除数が負なら絶対値にする
13BB-53              853 ( 1)         comb
13BC-C3 00 01        854 ( 3)         addd    #1
13BF-                855              ; // 除算実行
13BF-18              856 ( 2) .4      xgdx                    ; X <- 被除数
13C0-4F              857 ( 1)         clra                    ; D（WORK）をクリア
13C1-5F              858 ( 1)         clrb
13C2-18              859 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
13C3-05              860 ( 1)         asld
13C4-18              861 ( 2)         xgdx
13C5-59              862 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
13C6-49              863 ( 1)         rola
13C7-93 87           864 ( 4)         subd    <Divisor        ; WORK - 除数
13C9-08              865 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
13CA-24 03           866 ( 3)         bcc     :5              ; WORKから除数を引けた？
13CC-D3 87           867 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
13CE-09              868 ( 1)         dex                     ; XレジスタのLSBを0に戻す
13CF-7A 00 A3        869 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
13D2-26 EE           870 ( 3)         bne     :loop
13D4-39              871 ( 5)         rts
13D5-86 08           872 ( 2) .err08  ldaa    #8              ; "Zero Divide"
13D7-7E 17 DC        873 ( 3)         jmp     write_err_msg
13DA-                874
13DA-3C              875 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
13DB-DE 82           876 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13DD-EC 02           877 ( 5)         ldd     2,x
13DF-A3 00           878 ( 5)         subd    0,x
13E1-27 39           879 ( 3)         beq     CS_true
13E3-20 3D           880 ( 3)         bra     CS_false
13E5-                881
13E5-3C              882 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
13E6-DE 82           883 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13E8-EC 02           884 ( 5)         ldd     2,x
13EA-A3 00           885 ( 5)         subd    0,x
13EC-2D 2E           886 ( 3)         blt     CS_true
13EE-20 32           887 ( 3)         bra     CS_false
13F0-                888
13F0-3C              889 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
13F1-DE 82           890 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13F3-EC 02           891 ( 5)         ldd     2,x
13F5-A3 00           892 ( 5)         subd    0,x
13F7-2F 23           893 ( 3)         ble     CS_true
13F9-20 27           894 ( 3)         bra     CS_false
13FB-                895
13FB-3C              896 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
13FC-DE 82           897 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13FE-EC 02           898 ( 5)         ldd     2,x
1400-A3 00           899 ( 5)         subd    0,x
1402-26 18           900 ( 3)         bne     CS_true
1404-20 1C           901 ( 3)         bra     CS_false
1406-                902
1406-3C              903 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
1407-DE 82           904 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1409-EC 02           905 ( 5)         ldd     2,x
140B-A3 00           906 ( 5)         subd    0,x
140D-2E 0D           907 ( 3)         bgt     CS_true
140F-20 11           908 ( 3)         bra     CS_false
1411-                909
1411-3C              910 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
1412-DE 82           911 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1414-EC 02           912 ( 5)         ldd     2,x
1416-A3 00           913 ( 5)         subd    0,x
1418-2C 02           914 ( 3)         bge     CS_true
141A-20 06           915 ( 3)         bra     CS_false
141C-                916
141C-                917      CS_true:
141C-CC 00 01        918 ( 3)         ldd     #1
141F-7E 12 9C        919 ( 3)         jmp     CS_store
1422-                920
1422-                921      CS_false:
1422-4F              922 ( 1)         clra
1423-5F              923 ( 1)         clrb
1424-7E 12 9C        924 ( 3)         jmp     CS_store
1427-                925
1427-                926      ; -----------------------------------------------------------------------
1427-                927      ; テキストバッファの10進文字列から数値を取得する
1427-                928      ; Get a integer from a decimal string in a text buffer
1427-                929      ;【引数】X:バッファアドレス
1427-                930      ;【使用】A, B, X, UR0, UR1
1427-                931      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
1427-                932      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
1427-                933      ; -----------------------------------------------------------------------
1427-                934      get_int_from_decimal:
00A3-                935      .RetValue       .eq     UR0     ; Return Value
00A5-                936      .TempValue      .eq     UR1     ; Temporary Value
1427-4F              937 ( 1)         clra
1428-5F              938 ( 1)         clrb
1429-DD A3           939 ( 4)         std     <:RetValue
142B-97 A5           940 ( 3)         staa    <:TempValue
142D-97 84           941 ( 3)         staa    <SignFlag
142F-E6 00           942 ( 4)         ldab    0,x             ; 1文字取得
1431-C1 2D           943 ( 2)         cmpb    #'-'            ; マイナス記号か？
1433-26 05           944 ( 3)         bne     :1
1435-7C 00 84        945 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
1438-20 0B           946 ( 3)         bra     :next
143A-C1 2B           947 ( 2) .1      cmpb    #'+'            ; プラス記号か？
143C-27 07           948 ( 3)         beq     :next
143E-BD FF C1        949 ( 6)         jsr     is_decimal_char ; 数字か？
1441-24 36           950 ( 3)         bcc     :false          ; No. C=1で終了
1443-20 13           951 ( 3)         bra     :first
1445-08              952 ( 1) .next   inx                     ; 符号の次の1文字を取得
1446-E6 00           953 ( 4)         ldab    0,x
1448-BD FF C1        954 ( 6)         jsr     is_decimal_char ; 数字か？
144B-24 40           955 ( 3)         bcc     :err04          ; No. エラー処理へ
144D-20 09           956 ( 3)         bra     :first          ; Yes. これが最初の数字
144F-DD A3           957 ( 4) .loop   std     <:RetValue      ; 結果を退避
1451-E6 00           958 ( 4)         ldab    0,x             ; 1文字取得
1453-BD FF C1        959 ( 6)         jsr     is_decimal_char ; 数字か？
1456-24 14           960 ( 3)         bcc     :end
1458-C0 30           961 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
145A-D7 A6           962 ( 3)         stab    <:TempValue+1
145C-                963            ; // RetValue * 10 + TempValue
145C-DC A3           964 ( 4)         ldd     <:RetValue
145E-05              965 ( 1)         asld                    ; * 2
145F-05              966 ( 1)         asld                    ; * 4
1460-D3 A3           967 ( 4)         addd    <:RetValue      ; * 5
1462-05              968 ( 1)         asld                    ; * 10
1463-D3 A5           969 ( 4)         addd    <:TempValue     ; += TempValue
1465-08              970 ( 1)         inx                     ; ポインタを進める
1466-25 20           971 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
1468-2B 10           972 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
146A-20 E3           973 ( 3)         bra     :loop
146C-DC A3           974 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
146E-7D 00 84        975 ( 4)         tst     <SignFlag       ; 符号チェック
1471-27 05           976 ( 3)         beq     :true
1473-43              977 ( 1)         coma                    ; 負なら2の補数に
1474-53              978 ( 1)         comb
1475-C3 00 01        979 ( 3)         addd    #1
1478-0D              980 ( 1) .true   sec
1479-39              981 ( 5) .false  rts
147A-                982
147A-                983      .overflow
147A-                984            ; // -32,768かどうかの判定
147A-18              985 ( 2)         xgdx
147B-8C 80 00        986 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
147E-18              987 ( 2)         xgdx
147F-26 07           988 ( 3)         bne     :err02          ; No. 範囲外
1481-7D 00 84        989 ( 4)         tst     <SignFlag       ; 符号チェック
1484-27 02           990 ( 3)         beq     :err02          ; 正ならば範囲外
1486-20 C7           991 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
1488-                992
1488-86 02           993 ( 2) .err02  ldaa    #2              ; "Out of range"
148A-7E 17 DC        994 ( 3)         jmp     write_err_msg
148D-86 04           995 ( 2) .err04  ldaa    #4              ; "Illegal expression"
148F-7E 17 DC        996 ( 3)         jmp     write_err_msg
1492-                997
1492-                998
1492-                999      ; -----------------------------------------------------------------------
1492-               1000      ; Dレジスタの数値をコンソールに出力する
1492-               1001      ; Write Decimal Character converted from Integer
1492-               1002      ;【引数】D:Integer
1492-               1003      ;【使用】A, B, X
1492-               1004      ;【返値】なし
1492-               1005      ; -----------------------------------------------------------------------
1492-               1006      write_integer:
00A3-               1007      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00A4-               1008      .Counter        .eq     UR0L    ; 桁カウンター
1492-2A 0C          1009 ( 3)         bpl     :plus           ; 符号判定
1494-37             1010 ( 4)         pshb                    ; 負数なら'-'を出力する
1495-C6 2D          1011 ( 2)         ldab    #'-'
1497-BD FF AC       1012 ( 6)         jsr     write_char
149A-33             1013 ( 3)         pulb
149B-43             1014 ( 1)         coma                    ; 絶対値にする（2の補数にする）
149C-53             1015 ( 1)         comb
149D-C3 00 01       1016 ( 3)         addd    #1
14A0-7F 00 A3       1017 ( 5) .plus   clr     <:ZeroSuppress
14A3-CE 14 D3       1018 ( 3)         ldx     #:CONST
14A6-7F 00 A4       1019 ( 5) .loop   clr     <:Counter
14A9-A3 00          1020 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
14AB-25 05          1021 ( 3)         bcs     :write
14AD-7C 00 A4       1022 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
14B0-20 F7          1023 ( 3)         bra     :digit
14B2-               1024
14B2-E3 00          1025 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
14B4-37             1026 ( 4)         pshb
14B5-D6 A4          1027 ( 3)         ldab    <:Counter
14B7-27 03          1028 ( 3)         beq     :1              ; この桁はゼロか？
14B9-7C 00 A3       1029 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
14BC-7D 00 A3       1030 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
14BF-27 05          1031 ( 3)         beq     :2              ; No. この桁は表示しない
14C1-CB 30          1032 ( 2)         addb    #$30            ; Yes. この桁を表示する
14C3-BD FF AC       1033 ( 6)         jsr     write_char
14C6-33             1034 ( 3) .2      pulb
14C7-08             1035 ( 1)         inx                     ; 次の引く数へ
14C8-08             1036 ( 1)         inx
14C9-8C 14 DB       1037 ( 3)         cpx     #:CONST+8
14CC-26 D8          1038 ( 3)         bne     :loop
14CE-CB 30          1039 ( 2)         addb    #$30            ; 一の桁の数値を表示
14D0-7E FF AC       1040 ( 3)         jmp     write_char
14D3-               1041      ; Dから引いていく数
14D3-27 10          1042      .CONST  .dw     $2710           ; 10,000
14D5-03 E8          1043              .dw     $03e8           ; 1,000
14D7-00 64          1044              .dw     $0064           ; 100
14D9-00 0A          1045              .dw     $000a           ; 10
14DB-               1046
14DB-               1047
14DB-               1048      ; -----------------------------------------------------------------------
14DB-               1049      ; テキストバッファの英文字が変数か判定する
14DB-               1050      ; Is a character retrieved from a text buffer a variable?
14DB-               1051      ;【引数】X:バッファアドレス
14DB-               1052      ;【使用】A, B, X
14DB-               1053      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
14DB-               1054      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
14DB-               1055      ; -----------------------------------------------------------------------
14DB-               1056      is_variable:
14DB-E6 00          1057 ( 4)         ldab    0,x
14DD-BD FF BE       1058 ( 6)         jsr     is_alphabetic_char
14E0-24 0D          1059 ( 3)         bcc     :end
14E2-17             1060 ( 1)         tba                             ; 1文字目のアスキーコードを退避
14E3-E6 01          1061 ( 4)         ldab    1,x                     ; 2文字目を取得
14E5-BD FF BE       1062 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
14E8-16             1063 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
14E9-24 02          1064 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
14EB-0C             1065 ( 1)         clc                             ; Yes. 変数ではない。C=0
14EC-39             1066 ( 5)         rts
14ED-08             1067 ( 1) .var    inx                             ; ポインタを進める
14EE-0D             1068 ( 1)         sec                             ; C=1
14EF-39             1069 ( 5) .end    rts
14F0-               1070
14F0-               1071
14F0-               1072      ; -----------------------------------------------------------------------
14F0-               1073      ; 空白を読み飛ばす
14F0-               1074      ; Skip Space
14F0-               1075      ;【引数】X:実行位置アドレス
14F0-               1076      ;【使用】B, X
14F0-               1077      ;【返値】B:アスキーコード（$00の時Z=1）
14F0-               1078      ;        X:実行位置アドレス
14F0-               1079      ; -----------------------------------------------------------------------
14F0-               1080      skip_space:
14F0-E6 00          1081 ( 4)         ldab    0,x
14F2-27 07          1082 ( 3)         beq     :end
14F4-C1 20          1083 ( 2)         cmpb    #SPACE
14F6-22 03          1084 ( 3)         bhi     :end
14F8-08             1085 ( 1)         inx
14F9-20 F5          1086 ( 3)         bra     skip_space
14FB-39             1087 ( 5) .end    rts
14FC-               1088
14FC-               1089
14FC-               1090      ; -----------------------------------------------------------------------
14FC-               1091      ; 引用符付きの文字列を出力する
14FC-               1092      ; Write Quoted Stirng
14FC-               1093      ;【引数】B:アスキーコード X:実行位置アドレス
14FC-               1094      ;【使用】A, B, X
14FC-               1095      ;【返値】真(C=1) / X:次の実行位置アドレス
14FC-               1096      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
14FC-               1097      ; -----------------------------------------------------------------------
14FC-               1098      write_quoted_str:
14FC-C1 22          1099 ( 2)         cmpb    #$22            ; 一重引用符か？
14FE-27 04          1100 ( 3)         beq     :1
1500-C1 27          1101 ( 2)         cmpb    #$27            ; 二重引用符か？
1502-26 19          1102 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
1504-17             1103 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
1505-               1104            ; // 終端の引用符をチェック
1505-3C             1105 ( 5)         pshx
1506-08             1106 ( 1) .check  inx
1507-E6 00          1107 ( 4)         ldab    0,x
1509-27 14          1108 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
150B-11             1109 ( 1)         cba
150C-26 F8          1110 ( 3)         bne     :check
150E-38             1111 ( 4)         pulx
150F-               1112            ; // 文字列の出力
150F-08             1113 ( 1) .loop   inx
1510-E6 00          1114 ( 4)         ldab    0,x
1512-11             1115 ( 1)         cba                     ; 保存した引用符との比較
1513-27 05          1116 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
1515-BD FF AC       1117 ( 6)         jsr     write_char
1518-20 F5          1118 ( 3)         bra     :loop
151A-08             1119 ( 1) .true   inx
151B-0D             1120 ( 1)         sec
151C-39             1121 ( 5)         rts
151D-0C             1122 ( 1) .false  clc
151E-39             1123 ( 5)         rts
151F-86 0A          1124 ( 2) .err10  ldaa    #10             ; "Print statement error"
1521-7E 17 DC       1125 ( 3)         jmp     write_err_msg
1524-               1126
1524-               1127
1524-               1128      ; -----------------------------------------------------------------------
1524-               1129      ; タブを出力する
1524-               1130      ; Write tabs
1524-               1131      ;【引数】なし
1524-               1132      ;【使用】B
1524-               1133      ;【返値】なし
1524-               1134      ; -----------------------------------------------------------------------
1524-               1135      write_tab:
1524-BD FF B5       1136 ( 6) .top    jsr     write_space
1527-7B 07 39       1137 ( 4)         tim     #7,<TabCount
152A-26 F8          1138 ( 3)         bne     :top
152C-39             1139 ( 5)         rts
152D-               1140
152D-               1141
152D-               1142      ; -----------------------------------------------------------------------
152D-               1143      ; 式を評価して変数に値を代入する
152D-               1144      ; Evaluate an expression and assign a value to a variable
152D-               1145      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
152D-               1146      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
152D-               1147      ;【返値】D:Integer X:次の実行位置アドレス
152D-               1148      ; -----------------------------------------------------------------------
152D-               1149      assign_to_var:
152D-BD 14 F0       1150 ( 6)         jsr     skip_space
1530-BD 11 A9       1151 ( 6)         jsr     eval_expression
1533-24 07          1152 ( 3)         bcc     :err04
1535-3C             1153 ( 5)         pshx                    ; 実行位置アドレスを退避
1536-DE 8B          1154 ( 4)         ldx     <VariableAddr
1538-ED 00          1155 ( 5)         std     0,x             ; 変数に結果を保存
153A-38             1156 ( 4)         pulx                    ; 実行位置アドレスを復帰
153B-39             1157 ( 5)         rts
153C-86 04          1158 ( 2) .err04  ldaa    #4              ; "Illegal expression"
153E-7E 17 DC       1159 ( 3)         jmp     write_err_msg
1541-               1160
1541-               1161
1541-               1162      ; -----------------------------------------------------------------------
1541-               1163      ; 同じ行番号を検索する
1541-               1164      ; Scan equal line number
1541-               1165      ;【引数】LineNumber:検索対象の行番号 X:検索を開始する行頭アドレス
1541-               1166      ;【使用】A, B, X
1541-               1167      ;【返値】真(C=1) / D:行番号 X:その行の開始アドレス
1541-               1168      ;        偽(C=0) / D:次に大きな行番号 X:次に大きな行の開始アドレス
1541-               1169      ;                  またはD:$0000 X:プログラム終了アドレス
1541-               1170      ; -----------------------------------------------------------------------
1541-               1171      scan_line_num:
1541-EC 00          1172 ( 5) .loop   ldd     0,x             ; D:行番号
1543-27 0F          1173 ( 3)         beq     :false          ; プログラム終端まで来たので偽
1545-18             1174 ( 2)         xgdx
1546-9C 96          1175 ( 4)         cpx     <LineNumber
1548-18             1176 ( 2)         xgdx
1549-27 07          1177 ( 3)         beq     :true           ; 同一の行番号が見つかったので真
154B-2E 07          1178 ( 3)         bgt     :false          ; 対象の行番号より大きくなったので偽
154D-E6 02          1179 ( 4)         ldab    2,x
154F-3A             1180 ( 1)         abx
1550-20 EF          1181 ( 3)         bra     :loop
1552-0D             1182 ( 1) .true   sec
1553-39             1183 ( 5)         rts
1554-0C             1184 ( 1) .false  clc
1555-39             1185 ( 5)         rts
1556-               1186
1556-               1187
1556-               1188      ; -----------------------------------------------------------------------
1556-               1189      ; runコマンドを実行する
1556-               1190      ; Execute 'run' command
1556-               1191      ;【引数】なし
1556-               1192      ;【使用】A, B, X
1556-               1193      ;【返値】なし
1556-               1194      ; -----------------------------------------------------------------------
1556-               1195      exe_run:
1556-               1196            ; // 変数領域の初期化
1556-CE 02 C2       1197 ( 3)         ldx     #VARIABLE
1559-4F             1198 ( 1)         clra
155A-5F             1199 ( 1)         clrb
155B-ED 00          1200 ( 5) .1      std     0,x
155D-08             1201 ( 1)         inx
155E-08             1202 ( 1)         inx
155F-8C 02 F6       1203 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
1562-26 F7          1204 ( 3)         bne     :1
1564-7F 00 9C       1205 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
1567-CE 04 00       1206 ( 3)         ldx     #USER_AREA_TOP
156A-DF 9D          1207 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
156C-EC 00          1208 ( 5)         ldd     0,x
156E-27 08          1209 ( 3)         beq     :end            ; 行番号が$0000なら終了
1570-08             1210 ( 1)         inx
1571-08             1211 ( 1)         inx
1572-08             1212 ( 1)         inx
1573-BD 11 6B       1213 ( 6)         jsr     exe_line        ; 一行実行
1576-20 F2          1214 ( 3)         bra     :loop
1578-7E 10 23       1215 ( 3) .end    jmp     tb_main
157B-               1216
157B-               1217
157B-               1218      ; -----------------------------------------------------------------------
157B-               1219      ; listコマンドを実行する
157B-               1220      ; Execute 'list' command
157B-               1221      ;【引数】なし
157B-               1222      ;【使用】A, B, X
157B-               1223      ;【返値】なし
157B-               1224      ; -----------------------------------------------------------------------
157B-               1225      exe_list:
157B-CE 04 00       1226 ( 3)         ldx     #USER_AREA_TOP
157E-               1227            ; // 行番号出力
157E-EC 00          1228 ( 5) .loop   ldd     0,x
1580-27 11          1229 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
1582-3C             1230 ( 5)         pshx
1583-BD 14 92       1231 ( 6)         jsr     write_integer
1586-38             1232 ( 4)         pulx
1587-               1233            ; // 本文出力
1587-08             1234 ( 1)         inx                     ; 本文までスキップ
1588-08             1235 ( 1)         inx
1589-08             1236 ( 1)         inx
158A-BD FF AF       1237 ( 6)         jsr     write_line
158D-BD FF B2       1238 ( 6)         jsr     write_crlf
1590-08             1239 ( 1)         inx                     ; 次の行番号へ
1591-20 EB          1240 ( 3)         bra     :loop
1593-7E 10 23       1241 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1596-               1242
1596-               1243
1596-               1244      ; -----------------------------------------------------------------------
1596-               1245      ; Print文を実行する
1596-               1246      ; Execute 'print' statement
1596-               1247      ;【引数】X:実行位置アドレス
1596-               1248      ;【使用】B, X（下位ルーチンでA）
1596-               1249      ;【返値】なし
1596-               1250      ; -----------------------------------------------------------------------
1596-               1251      exe_print:
1596-72 01 8F       1252 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1599-BD 14 F0       1253 ( 6) .loop   jsr     skip_space
159C-27 37          1254 ( 3)         beq     :finish         ; 終端文字なら改行して終了
159E-BD 14 FC       1255 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
15A1-25 1B          1256 ( 3)         bcs     :nlon
15A3-BD 11 A9       1257 ( 6)         jsr     eval_expression
15A6-25 11          1258 ( 3)         bcs     :int
15A8-               1259            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
15A8-               1260            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
15A8-C1 3B          1261 ( 2) .check  cmpb    #';'
15AA-27 23          1262 ( 3)         beq     :nloff
15AC-C1 2C          1263 ( 2)         cmpb    #','
15AE-27 1C          1264 ( 3)         beq     :tab
15B0-C1 3A          1265 ( 2)         cmpb    #':'
15B2-27 21          1266 ( 3)         beq     :finish
15B4-86 04          1267 ( 2)         ldaa    #4              ; "Illegal expression"
15B6-7E 17 DC       1268 ( 3)         jmp     write_err_msg
15B9-3C             1269 ( 5) .int    pshx                    ; 実行位置アドレスを退避
15BA-BD 14 92       1270 ( 6)         jsr     write_integer   ; 評価した式を出力
15BD-38             1271 ( 4)         pulx                    ; 実行位置アドレスを復帰
15BE-72 01 8F       1272 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
15C1-BD 14 F0       1273 ( 6)         jsr     skip_space
15C4-C1 3B          1274 ( 2)         cmpb    #';'
15C6-27 07          1275 ( 3)         beq     :nloff
15C8-C1 2C          1276 ( 2)         cmpb    #','
15CA-26 09          1277 ( 3)         bne     :finish
15CC-BD 15 24       1278 ( 6) .tab    jsr     write_tab       ; タブ出力
15CF-7F 00 8F       1279 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
15D2-08             1280 ( 1)         inx                     ; 次の文字へ
15D3-20 C4          1281 ( 3)         bra     :loop
15D5-7D 00 8F       1282 ( 4) .finish tst     <NewLineFlag
15D8-27 03          1283 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
15DA-BD FF B2       1284 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
15DD-7E 11 4B       1285 ( 3) .end    jmp     is_multi
15E0-               1286
15E0-               1287
15E0-               1288      ; -----------------------------------------------------------------------
15E0-               1289      ; input文を実行する
15E0-               1290      ; Execute 'input' statement
15E0-               1291      ; -----------------------------------------------------------------------
15E0-               1292      exe_input:
15E0-BD 14 F0       1293 ( 6)         jsr     skip_space
15E3-27 31          1294 ( 3)         beq     :end            ; 終端文字なら改行して終了
15E5-BD 14 FC       1295 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
15E8-24 0A          1296 ( 3)         bcc     :1
15EA-E6 00          1297 ( 4)         ldab    0,x
15EC-C1 3B          1298 ( 2)         cmpb    #';'
15EE-26 29          1299 ( 3)         bne     :err00
15F0-08             1300 ( 1)         inx
15F1-BD 14 F0       1301 ( 6)         jsr     skip_space
15F4-BD 14 DB       1302 ( 6) .1      jsr     is_variable
15F7-24 20          1303 ( 3)         bcc     :err00
15F9-86 02          1304 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
15FB-58             1305 ( 1)         aslb                    ; B = 変数領域の下位バイト
15FC-DD 8B          1306 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
15FE-               1307            ; // 変数の後に余計な文字がないか確認
15FE-               1308            ; // 例えば "input a+b" など
15FE-DF 8D          1309 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
1600-BD 14 F0       1310 ( 6)         jsr     skip_space
1603-27 06          1311 ( 3)         beq     :read           ; 終端文字なら入力へ
1605-C1 3A          1312 ( 2)         cmpb    #':'            ; ":"なら入力へ
1607-26 10          1313 ( 3)         bne     :err00          ; それ以外の文字ならエラー
1609-DE 8D          1314 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
160B-BD FF A9       1315 ( 6) .read   jsr     read_line
160E-CE 01 40       1316 ( 3)         ldx     #TEXT_BFFR
1611-BD 15 2D       1317 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
1614-DE 8D          1318 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1616-7E 11 4B       1319 ( 3) .end    jmp     is_multi
1619-4F             1320 ( 1) .err00  clra                    ; "Syntax error"
161A-7E 17 DC       1321 ( 3)         jmp     write_err_msg
161D-               1322
161D-               1323
161D-               1324      ; -----------------------------------------------------------------------
161D-               1325      ; if文を実行する
161D-               1326      ; Execute 'if' statement
161D-               1327      ;【引数】X:実行位置アドレス
161D-               1328      ;【使用】B, X
161D-               1329      ;【返値】なし
161D-               1330      ; -----------------------------------------------------------------------
161D-BD 14 F0       1331 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
1620-27 0B          1332 ( 3)         beq     :end            ; 終端文字なら終了
1622-BD 11 A9       1333 ( 6)         jsr     eval_expression ; 式評価
1625-24 09          1334 ( 3)         bcc     :err04
1627-5D             1335 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
1628-27 03          1336 ( 3)         beq     :end
162A-7E 11 6B       1337 ( 3)         jmp     exe_line        ; True
162D-7E 11 5B       1338 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
1630-86 04          1339 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1632-7E 17 DC       1340 ( 3)         jmp     write_err_msg
1635-               1341
1635-               1342
1635-               1343      ; -----------------------------------------------------------------------
1635-               1344      ; gosub文を実行する
1635-               1345      ; Execute 'gosub' statement
1635-               1346      ;【引数】X:実行位置アドレス
1635-               1347      ;【使用】A, B, X
1635-               1348      ;【返値】なし
1635-               1349      ; -----------------------------------------------------------------------
1635-               1350      exe_gosub:
1635-72 01 A0       1351 ( 6)         oim     #1,<ToSubFlag   ; 分岐モードを1 = gosubにする
1638-               1352              ; そのままexe_gotoに続く
1638-               1353
1638-               1354
1638-               1355      ; -----------------------------------------------------------------------
1638-               1356      ; goto文を実行する
1638-               1357      ; Execute 'goto' statement
1638-               1358      ;【引数】X:実行位置アドレス
1638-               1359      ;【使用】A, B, X
1638-               1360      ;【返値】なし
1638-               1361      ; -----------------------------------------------------------------------
1638-               1362      exe_goto:
1638-BD 14 F0       1363 ( 6)         jsr     skip_space      ; 空白を読み飛ばし
163B-27 3F          1364 ( 3)         beq     :err00          ; 終端文字"Syntax error"
163D-BD 11 A9       1365 ( 6)         jsr     eval_expression ; 式評価
1640-24 3E          1366 ( 3)         bcc     :err04          ; "Illegal expression"
1642-2B 41          1367 ( 3)         bmi     :err12          ; "Invalid line number"
1644-DD 96          1368 ( 4)         std     <LineNumber     ; 飛び先になる行番号を一時保存
1646-7D 00 A0       1369 ( 4)         tst     ToSubFlag
1649-27 17          1370 ( 3)         beq     :to             ; 分岐モードが0=gotoなら:toへ
164B-18             1371 ( 2)         xgdx                    ; D = ExePointer
164C-DE A1          1372 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
164E-8C 02 28       1373 ( 3)         cpx     #SSTACK         ; 既にスタック最上位か？
1651-27 3C          1374 ( 3)         beq     :err18          ; Yes. "Subroutine stack overflow"
1653-09             1375 ( 1)         dex
1654-09             1376 ( 1)         dex
1655-ED 00          1377 ( 5)         std     0,x             ; ExePointerをスタックに積む
1657-DC 9D          1378 ( 4)         ldd     <ExeLineAddr
1659-09             1379 ( 1)         dex
165A-09             1380 ( 1)         dex
165B-ED 00          1381 ( 5)         std     0,x             ; ExeLineAddrをスタックに積む
165D-DF A1          1382 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
165F-7F 00 A0       1383 ( 5)         clr     ToSubFlag       ; 分岐モードを0 = gotoに戻す
1662-DE 9D          1384 ( 4) .to     ldx     <ExeLineAddr    ; X <- 実行中の行の先頭アドレス
1664-EC 00          1385 ( 5)         ldd     0,x             ; 今実行している行の行番号を取得
1666-18             1386 ( 2)         xgdx
1667-9C 96          1387 ( 4)         cpx     <LineNumber     ; 現在の行番号と飛び先の行番号を比較
1669-18             1388 ( 2)         xgdx
166A-25 03          1389 ( 3)         bcs     :1              ; 現在の行番号 > 飛び先の行番号 = ここから検索
166C-CE 04 00       1390 ( 3)         ldx     #USER_AREA_TOP  ; 現在の行番号 < 飛び先の行番号 = 先頭から検索
166F-BD 15 41       1391 ( 6) .1      jsr     scan_line_num   ; 同じ行番号を探す
1672-24 16          1392 ( 3)         bcc     :err16          ; "Undefined line number"
1674-DF 9D          1393 ( 4)         stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
1676-08             1394 ( 1)         inx
1677-08             1395 ( 1)         inx
1678-08             1396 ( 1)         inx
1679-7E 11 6B       1397 ( 3)         jmp     exe_line
167C-               1398
167C-4F             1399 ( 1) .err00  clra                    ; "Syntax error"
167D-7E 17 DC       1400 ( 3)         jmp     write_err_msg
1680-86 04          1401 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1682-7E 17 DC       1402 ( 3)         jmp     write_err_msg
1685-86 0C          1403 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1687-7E 17 DC       1404 ( 3)         jmp     write_err_msg
168A-86 10          1405 ( 2) .err16  ldaa    #16             ; "Undefined line number"
168C-7E 17 DC       1406 ( 3)         jmp     write_err_msg
168F-86 12          1407 ( 2) .err18  ldaa    #18             ; "Subroutine stack overflow"
1691-7E 17 DC       1408 ( 3)         jmp     write_err_msg
1694-               1409
1694-               1410
1694-               1411      ; -----------------------------------------------------------------------
1694-               1412      ; return文を実行する
1694-               1413      ; Execute 'return' statement
1694-               1414      ;【引数】X:実行位置アドレス
1694-               1415      ;【使用】A, B, X
1694-               1416      ;【返値】なし
1694-               1417      ; -----------------------------------------------------------------------
1694-               1418      exe_return:
1694-DE A1          1419 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
1696-8C 02 50       1420 ( 3)         cpx     #SSTACK_BTM+1   ; 既にスタックの底か？
1699-27 10          1421 ( 3)         beq     :err20          ; Yes. "Return without gosub"
169B-EC 00          1422 ( 5)         ldd     0,x
169D-DD 9D          1423 ( 4)         std     <ExeLineAddr    ; ExeLineAddrをスタックから復帰
169F-08             1424 ( 1)         inx
16A0-08             1425 ( 1)         inx
16A1-EC 00          1426 ( 5)         ldd     0,x             ; D = ExePointer
16A3-08             1427 ( 1)         inx
16A4-08             1428 ( 1)         inx
16A5-DF A1          1429 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
16A7-18             1430 ( 2)         xgdx                    ; X = ExePointer
16A8-7E 11 4B       1431 ( 3)         jmp     is_multi
16AB-               1432
16AB-86 14          1433 ( 2) .err20  ldaa    #20             ; "Return without gosub"
16AD-7E 17 DC       1434 ( 3)         jmp     write_err_msg
16B0-               1435
16B0-               1436
16B0-               1437      ; -----------------------------------------------------------------------
16B0-               1438      ; trunc文を実行する
16B0-               1439      ; Execute 'trunc' statement
16B0-               1440      ;【引数】X:実行位置アドレス
16B0-               1441      ;【使用】B, X
16B0-               1442      ;【返値】なし
16B0-               1443      ; -----------------------------------------------------------------------
16B0-               1444      exe_trunc:
16B0-7F 00 9F       1445 ( 5)         clr     <ModuloMode     ; tranc = 0 にする
16B3-7E 11 4B       1446 ( 3)         jmp     is_multi
16B6-               1447
16B6-               1448
16B6-               1449      ; -----------------------------------------------------------------------
16B6-               1450      ; floor文を実行する
16B6-               1451      ; Execute 'trunc' statement
16B6-               1452      ;【引数】X:実行位置アドレス
16B6-               1453      ;【使用】B, X
16B6-               1454      ;【返値】なし
16B6-               1455      ; -----------------------------------------------------------------------
16B6-               1456      exe_floor:
16B6-72 01 9F       1457 ( 6)         oim     #1,<ModuloMode  ; floor = 1以上 にする
16B9-7E 11 4B       1458 ( 3)         jmp     is_multi
16BC-               1459
16BC-               1460
16BC-               1461      ; ------------------------------------------------
16BC-               1462      ; ブロック転送
16BC-               1463      ; Move memory
16BC-               1464      ;【引数】Source:転送元アドレス
16BC-               1465      ;        Destination:転送先アドレス
16BC-               1466      ;        Bytes:転送バイト数
16BC-               1467      ;【使用】A, B, X, UR0
16BC-               1468      ;【返値】なし
16BC-               1469      ; ------------------------------------------------
16BC-               1470      mem_move:
16BC-DC 94          1471 ( 4)         ldd     <Bytes
16BE-27 0A          1472 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
16C0-DC 90          1473 ( 4)         ldd     <Source
16C2-93 92          1474 ( 4)         subd    <Destination    ; Source - Destination
16C4-27 04          1475 ( 3)         beq     :end            ; 転送元と転送先が同じなら即終了
16C6-24 03          1476 ( 3)         bcc     LDIR            ; Source > Destination
16C8-20 31          1477 ( 3)         bra     LDDR            ; Source < Destination
16CA-39             1478 ( 5) .end    rts
16CB-               1479
16CB-               1480      ; ------------------------------------------------
16CB-               1481      ; 前方から転送（LDIR）
16CB-               1482      ; Load, Increment and Repeat
16CB-               1483      ;【引数】Source:転送元アドレス
16CB-               1484      ;        Destination:転送先アドレス
16CB-               1485      ;        Bytes:転送バイト数
16CB-               1486      ;【使用】A, B, X, UR0
16CB-               1487      ;【返値】なし
16CB-               1488      ; ------------------------------------------------
16CB-               1489      LDIR:
00A3-               1490      .Offset .eq     UR0
16CB-               1491             ; // オフセットの計算。既にDレジスタに入っている
16CB-DD A3          1492 ( 4)        std     <:Offset        ; Offset = Source - Destination
16CD-               1493            ; // 終了判定用のアドレスを計算
16CD-DC 90          1494 ( 4)         ldd     <Source         ; 転送終了アドレス = Source - Bytes
16CF-D3 94          1495 ( 4)         addd    <Bytes
16D1-DD 92          1496 ( 4)         std     <Destination    ; 転送終了アドレスをDestinationに代入
16D3-               1497            ; // 転送開始
16D3-DE 90          1498 ( 4)         ldx     <Source         ; 転送開始アドレスをXに代入
16D5-               1499            ; // 転送するバイト数が奇数か偶数か判断。
16D5-               1500            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
16D5-DC 94          1501 ( 4)         ldd     <Bytes
16D7-04             1502 ( 1)         lsrd                    ; 転送バイト数 / 2, 奇数ならC=1
16D8-24 0E          1503 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
16DA-               1504            ; // Byte転送
16DA-A6 00          1505 ( 4)         ldaa    0,x             ; A <- [Source]
16DC-18             1506 ( 2)         xgdx                    ; D = address, X = data
16DD-93 A3          1507 ( 4)         subd    <:Offset        ; Source - Offset = Destination
16DF-18             1508 ( 2)         xgdx                    ; D = data, X = address
16E0-A7 00          1509 ( 4)         staa    0,x             ; [Destination] <- A
16E2-18             1510 ( 2)         xgdx                    ; D = address, X = data
16E3-D3 A3          1511 ( 4)         addd    <:Offset        ; Destination + Offset = Source
16E5-18             1512 ( 2)         xgdx                    ; D = data, X = address
16E6-20 0D          1513 ( 3)         bra     :odd            ; 飛び先でinx
16E8-               1514            ; // Word転送
16E8-EC 00          1515 ( 5) .loop   ldd     0,x
16EA-18             1516 ( 2)         xgdx
16EB-93 A3          1517 ( 4)         subd    <:Offset
16ED-18             1518 ( 2)         xgdx
16EE-ED 00          1519 ( 5)         std     0,x
16F0-18             1520 ( 2)         xgdx
16F1-D3 A3          1521 ( 4)         addd    <:Offset
16F3-18             1522 ( 2)         xgdx
16F4-08             1523 ( 1)         inx
16F5-08             1524 ( 1) .odd    inx
16F6-9C 92          1525 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
16F8-26 EE          1526 ( 3)         bne     :loop
16FA-39             1527 ( 5)         rts
16FB-               1528
16FB-               1529      ; ------------------------------------------------
16FB-               1530      ; 後方から転送（LDDR）
16FB-               1531      ; Load, Decrement and Repeat
16FB-               1532      ;【引数】Source:転送元アドレス
16FB-               1533      ;        Destination:転送先アドレス
16FB-               1534      ;        Bytes:転送バイト数
16FB-               1535      ;【使用】A, B, X, UR0
16FB-               1536      ;【返値】なし
16FB-               1537      ; ------------------------------------------------
16FB-               1538      LDDR:
00A3-               1539      .Offset .eq     UR0
16FB-               1540            ; // オフセットの計算
16FB-DC 92          1541 ( 4)         ldd     <Destination
16FD-93 90          1542 ( 4)         subd    <Source
16FF-DD A3          1543 ( 4)         std     <:Offset         ; Offset = Destination - Source
1701-               1544            ; // 転送終了アドレスは既にDestinationに代入済み
1701-               1545            ; // 転送開始アドレスの計算。一番後ろから
1701-DC 90          1546 ( 4)         ldd     <Source         ; 転送開始アドレス = Source + Bytes
1703-D3 94          1547 ( 4)         addd    <Bytes
1705-18             1548 ( 2)         xgdx                    ; X = 転送開始アドレス
1706-               1549            ; // 転送するバイト数が奇数か偶数か判断。
1706-               1550            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
1706-DC 94          1551 ( 4)         ldd     <Bytes
1708-04             1552 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
1709-24 0F          1553 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
170B-               1554            ; // Byte転送
170B-09             1555 ( 1)         dex
170C-A6 00          1556 ( 4)         ldaa    0,x             ; A <- [Source]
170E-18             1557 ( 2)         xgdx                    ; D = address, X = data
170F-D3 A3          1558 ( 4)         addd    <:Offset        ; Source + Offset = Destination
1711-18             1559 ( 2)         xgdx                    ; D = data, X = address
1712-A7 00          1560 ( 4)         staa    0,x             ; [Destination] <- A
1714-18             1561 ( 2)         xgdx                    ; D = address, X = data
1715-93 A3          1562 ( 4)         subd    <:Offset        ; Destination - Offset = Source
1717-18             1563 ( 2)         xgdx                    ; D = data, X = address
1718-20 0E          1564 ( 3)         bra     :odd
171A-               1565            ; // Word転送
171A-09             1566 ( 1) .loop   dex
171B-09             1567 ( 1)         dex
171C-EC 00          1568 ( 5)         ldd     0,x
171E-18             1569 ( 2)         xgdx
171F-D3 A3          1570 ( 4)         addd    <:Offset
1721-18             1571 ( 2)         xgdx
1722-ED 00          1572 ( 5)         std     0,x
1724-18             1573 ( 2)         xgdx
1725-93 A3          1574 ( 4)         subd    <:Offset
1727-18             1575 ( 2)         xgdx
1728-9C 90          1576 ( 4) .odd    cpx     <Source         ; 転送終了アドレスと現在のアドレスを比較
172A-26 EE          1577 ( 3)         bne     :loop
172C-39             1578 ( 5)         rts
172D-               1579
172D-               1580
172D-               1581      ; -----------------------------------------------------------------------
172D-               1582      ; テーブル検索
172D-               1583      ; Search the keyword table
172D-               1584      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
172D-               1585      ;【使用】A, B, X
172D-               1586      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
172D-               1587      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
172D-               1588      ; -----------------------------------------------------------------------
172D-               1589      search_table:
172D-EC 05          1590 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
172F-91 AB          1591 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1731-26 2F          1592 ( 3)         bne     :false
1733-D1 AC          1593 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
1735-26 2B          1594 ( 3)         bne     :false
1737-EC 07          1595 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
1739-4D             1596 ( 1)         tsta                    ; $00（終端記号）か？
173A-27 1B          1597 ( 3)         beq     :true
173C-91 AD          1598 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
173E-26 22          1599 ( 3)         bne     :false
1740-5D             1600 ( 1)         tstb                    ; $00（終端記号）か？
1741-27 14          1601 ( 3)         beq     :true
1743-D1 AE          1602 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
1745-26 1B          1603 ( 3)         bne     :false
1747-EC 09          1604 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
1749-4D             1605 ( 1)         tsta                    ; $00（終端記号）か？
174A-27 0B          1606 ( 3)         beq     :true
174C-91 AF          1607 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
174E-26 12          1608 ( 3)         bne     :false
1750-5D             1609 ( 1)         tstb                    ; $00（終端記号）か？
1751-27 04          1610 ( 3)         beq     :true
1753-D1 B0          1611 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
1755-26 0B          1612 ( 3)         bne     :false
1757-E6 02          1613 ( 4) .true   ldab    2,x             ; B = 語長
1759-EE 03          1614 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
175B-31             1615 ( 1)         ins                     ; 元のリターンアドレスを削除
175C-31             1616 ( 1)         ins
175D-3C             1617 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
175E-DE 8D          1618 ( 4)         ldx     <ExePointer
1760-3A             1619 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1761-39             1620 ( 5)         rts                     ; 命令ルーチンにジャンプ
1762-EE 00          1621 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1764-26 C7          1622 ( 3)         bne     :top
1766-DE 8D          1623 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
1768-0C             1624 ( 1)         clc                     ; false: C=0
1769-39             1625 ( 5)         rts
176A-               1626
176A-               1627
176A-               1628      ; ***********************************************************************
176A-               1629      ;   キーワードテーブル Keyword table
176A-               1630      ; ***********************************************************************
176A-               1631      ; レコードの構造 Record structure
176A-               1632      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
176A-               1633      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
176A-               1634      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
176A-               1635      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
176A-               1636      ; キーワードは2文字以上6文字以下
176A-               1637      CMD_TABLE
176A-17 73          1638      .run            .dw     :new
176C-03             1639                      .db     3
176D-15 56          1640                      .dw     exe_run
176F-72 75 6E 00    1641                      .az     "run"
1773-17 7C          1642      .new            .dw     :list
1775-03             1643                      .db     3
1776-10 03          1644                      .dw     cold_start
1778-6E 65 77 00    1645                      .az     "new"
177C-17 86          1646      .list           .dw     SMT_TABLE:print
177E-04             1647                      .db     4
177F-15 7B          1648                      .dw     exe_list
1781-6C 69 73 74 
     00             1649                      .az     "list"
1786-               1650      SMT_TABLE
1786-17 91          1651      .print          .dw     :input
1788-05             1652                      .db     5
1789-15 96          1653                      .dw     exe_print
178B-70 72 69 6E 
     74 00          1654                      .az     "print"
1791-17 9C          1655      .input          .dw     :if
1793-05             1656                      .db     5
1794-15 E0          1657                      .dw     exe_input
1796-69 6E 70 75 
     74 00          1658                      .az     "input"
179C-17 A4          1659      .if             .dw     :goto
179E-02             1660                      .db     2
179F-16 1D          1661                      .dw     exe_if
17A1-69 66 00       1662                      .az     "if"
17A4-17 AE          1663      .goto           .dw     :gosub
17A6-04             1664                      .db     4
17A7-16 38          1665                      .dw     exe_goto
17A9-67 6F 74 6F 
     00             1666                      .az     "goto"
17AE-17 B9          1667      .gosub          .dw     :return
17B0-05             1668                      .db     5
17B1-16 35          1669                      .dw     exe_gosub
17B3-67 6F 73 75 
     62 00          1670                      .az     "gosub"
17B9-17 C4          1671      .return         .dw     :trunc
17BB-06             1672                      .db     6
17BC-16 94          1673                      .dw     exe_return
17BE-72 65 74 75 
     72 6E          1674                      .as     "return"        ; 6文字なので終端不要。'.as'を使用する
17C4-17 CF          1675      .trunc          .dw     :floor
17C6-05             1676                      .db     5
17C7-16 B0          1677                      .dw     exe_trunc
17C9-74 72 75 6E 
     63 00          1678                      .az     "trunc"
17CF-17 DA          1679      .floor          .dw     :bottom
17D1-05             1680                      .db     5
17D2-16 B6          1681                      .dw     exe_floor
17D4-66 6C 6F 6F 
     72 00          1682                      .az     "floor"
17DA-00 00          1683      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
17DC-               1684
17DC-               1685
17DC-               1686      ; -----------------------------------------------------------------------
17DC-               1687      ; エラーメッセージを表示する
17DC-               1688      ; Write Error Messege
17DC-               1689      ;【引数】A: エラーコード
17DC-               1690      ;【使用】A, B, X
17DC-               1691      ;【返値】なし
17DC-               1692      ; -----------------------------------------------------------------------
17DC-               1693      write_err_msg:
17DC-7D 00 39       1694 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
17DF-27 03          1695 ( 3)         beq     :1
17E1-BD FF B2       1696 ( 6)         jsr     write_crlf
17E4-CE 18 0F       1697 ( 3) .1      ldx     #ERRMSG1
17E7-BD FF AF       1698 ( 6)         jsr     write_line
17EA-16             1699 ( 1)         tab
17EB-CE 18 1B       1700 ( 3)         ldx     #ERRCODE
17EE-3A             1701 ( 1)         abx
17EF-EE 00          1702 ( 5)         ldx     0,x
17F1-BD FF AF       1703 ( 6)         jsr     write_line
17F4-7D 00 9C       1704 ( 4)         tst     ExeStateFlag    ; 実行モードか？
17F7-26 0D          1705 ( 3)         bne     :2              ; No. 行番号を表示せずにスキップ
17F9-CE 18 16       1706 ( 3)         ldx     #ERRMSG2        ; Yes. 行番号を表示する
17FC-BD FF AF       1707 ( 6)         jsr     write_line
17FF-DE 9D          1708 ( 4)         ldx     <ExeLineAddr
1801-EC 00          1709 ( 5)         ldd     0,x
1803-BD 14 92       1710 ( 6)         jsr     write_integer
1806-BD FF B2       1711 ( 6) .2      jsr     write_crlf
1809-DE 80          1712 ( 4)         ldx     <StackPointer
180B-35             1713 ( 1)         txs
180C-7E 10 23       1714 ( 3)         jmp     tb_main
180F-               1715
180F-4F 6F 70 73 
     21 20 00       1716      ERRMSG1 .az     "Oops! "
1816-20 69 6E 20 
     00             1717      ERRMSG2 .az     " in "
181B-18 31          1718      ERRCODE .dw     .err00
181D-18 3E          1719              .dw     .err02
181F-18 51          1720              .dw     .err04
1821-18 64          1721              .dw     .err06
1823-18 7D          1722              .dw     .err08
1825-18 89          1723              .dw     .err10
1827-18 9F          1724              .dw     .err12
1829-18 B3          1725              .dw     .err14
182B-18 C4          1726              .dw     .err16
182D-18 DA          1727              .dw     .err18
182F-18 F4          1728              .dw     .err20
1831-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1729      .err00  .az     "Syntax error"
183E-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1730      .err02  .az     "Out of range value"
1851-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1731      .err04  .az     "Illegal expression"
1864-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1732      .err06  .az     "Calculate stack overflow"
187D-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1733      .err08  .az     "Zero Divide"
1889-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1734      .err10  .az     "Print statement error"
189F-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1735      .err12  .az     "Invalid line number"
18B3-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1736      .err14  .az     "Memory size over"
18C4-55 6E 64 65 
     66 69 6E 65 
     64 20 6C 69 
     6E 65 20 6E 
     75 6D 62 65 
     72 00          1737      .err16  .az     "Undefined line number"
18DA-53 75 62 72 
     6F 75 74 69 
     6E 65 20 73 
     74 61 63 6B 
     20 6F 76 65 
     72 66 6C 6F 
     77 00          1738      .err18  .az     "Subroutine stack overflow"
18F4-52 65 74 75 
     72 6E 20 77 
     69 74 68 6F 
     75 74 20 67 
     6F 73 75 62 
     00             1739      .err20  .az     "Return without gosub"
1909-               1740
1909-               1741
1909-               1742      ; ***********************************************************************
1909-               1743      ;   デバック用ルーチン Debugging routines
1909-               1744      ; ***********************************************************************
1909-               1745      ; -----------------------------------------------------------------------
1909-               1746      ; ユーザーレジスタを表示する
1909-               1747      ; Display user registers
1909-               1748      ; -----------------------------------------------------------------------
1909-36             1749 ( 4) PUTUR:  psha
190A-37             1750 ( 4)         pshb
190B-3C             1751 ( 5)         pshx
190C-CE 19 3F       1752 ( 3)         ldx     #:MSGUR0
190F-BD FF AF       1753 ( 6)         jsr     write_line
1912-DC A3          1754 ( 4)         ldd     <UR0
1914-BD FF BB       1755 ( 6)         jsr     write_word
1917-CE 19 44       1756 ( 3)         ldx     #:MSGUR1
191A-BD FF AF       1757 ( 6)         jsr     write_line
191D-DC A5          1758 ( 4)         ldd     <UR1
191F-BD FF BB       1759 ( 6)         jsr     write_word
1922-CE 19 4A       1760 ( 3)         ldx     #:MSGUR2
1925-BD FF AF       1761 ( 6)         jsr     write_line
1928-DC A7          1762 ( 4)         ldd     <UR2
192A-BD FF BB       1763 ( 6)         jsr     write_word
192D-CE 19 50       1764 ( 3)         ldx     #:MSGUR3
1930-BD FF AF       1765 ( 6)         jsr     write_line
1933-DC A9          1766 ( 4)         ldd     <UR3
1935-BD FF BB       1767 ( 6)         jsr     write_word
1938-BD FF B2       1768 ( 6)         jsr     write_crlf
193B-38             1769 ( 4)         pulx
193C-33             1770 ( 3)         pulb
193D-32             1771 ( 3)         pula
193E-39             1772 ( 5)         rts
193F-55 52 30 3D 
     00             1773      .MSGUR0          .az     "UR0="
1944-20 55 52 31 
     3D 00          1774      .MSGUR1          .az     " UR1="
194A-20 55 52 32 
     3D 00          1775      .MSGUR2          .az     " UR2="
1950-20 55 52 33 
     3D 00          1776      .MSGUR3          .az     " UR3="
