0000-                 14
0000-                 15      ; ***********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ***********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ***********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0011-                 46      XON             .eq     $11     ; DC1
0013-                 47      XOFF            .eq     $13     ; DC3
001B-                 48      ESC             .eq     $1b     ; Escape
0027-                 49      APOSTROPHE      .eq     $27     ; Apostrophe
0000-                 50
0020-                 51      RAM_START       .eq     $0020
1FFF-                 52      RAM_END         .eq     $1fff
E000-                 53      ROM_START       .eq     $e000
FFFF-                 54      ROM_END         .eq     $ffff
1000-                 55      PROGRAM_START   .eq     $1000   ; プログラム開始アドレス
0FFF-                 56      STACK           .eq     $0fff
0000-                 57
0400-                 58      USER_AREA_TOP   .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 59      USER_AREA_BTM   .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 60
0000-                 61      ; ***********************************************************************
0000-                 62      ;   システム変数 System variables
0000-                 63      ; ***********************************************************************
0000-                 64              .sm     RAM
0020-                 65              .or     $20
0020-                 66
0020-                 67      ; Interrupt Vector Hooking
0020-                 68      VEC_TRAP        .bs     3
0023-                 69      VEC_SCI         .bs     3
0026-                 70      VEC_TOF         .bs     3
0029-                 71      VEC_OCF         .bs     3
002C-                 72      VEC_ICF         .bs     3
002F-                 73      VEC_IRQ         .bs     3
0032-                 74      VEC_SWI         .bs     3
0035-                 75      VEC_NMI         .bs     3
0038-                 76      BreakPointFlag  .bs     1
0039-                 77      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 78      RxBffrQty       .bs     1       ; 受信バッファデータ数
003B-                 79      RxBffrReadPtr   .bs     2       ; 受信バッファ読み込みポインタ
003D-                 80      RxBffrWritePtr  .bs     2       ; 受信バッファ書き込みポインタ
003F-                 81      ; General-Purpose Registers
003F-                 82      R0              .bs     2
0041-                 83      R1              .bs     2
0043-                 84
0043-                 85      ; ***********************************************************************
0043-                 86      ;   システムワークエリア System work area
0043-                 87      ; ***********************************************************************
0043-                 88              .sm     RAM
0100-                 89              .or     $0100
0100-                 90      ; 各種バッファ
0100-                 91      Rx_BUFFER       .bs     64      ; 受信バッファ（$0100-$013f）
013F-                 92      Rx_BUFFER_END   .eq     *-1
0040-                 93      Rx_BFFR_SIZE    .eq     Rx_BUFFER_END-Rx_BUFFER+1
0140-                 94      TEXT_BFFR       .bs     73      ; テキストバッファ（$0140-$188: 73byte）
0188-                 95      TEXT_BFFR_END   .eq     *-1
0049-                 96      TEXT_BFFR_SIZE  .eq     TEXT_BFFR_END-TEXT_BFFR+1
0189-                 97
0189-                 98      ; ***********************************************************************
0189-                 99      ;   変数 Variables
0189-                100      ; ***********************************************************************
0189-                101              .sm     RAM
0080-                102              .or     $80
0080-                103
0080-                104      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                105      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                106      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                107      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                108      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                109      Divisor         .bs     2       ; 除数
0089-                110      Remainder       .bs     2       ; 剰余
008B-                111      VariableAddr    .bs     2       ; 変数のアドレス
008D-                112      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                113      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                114      Source          .bs     2       ; 転送元アドレス
0092-                115      Destination     .bs     2       ; 転送先アドレス
0094-                116      Bytes           .bs     2       ; 転送バイト数
0096-                117      LineNumber      .bs     2       ; 行番号
0098-                118      LineLength      .bs     2       ; 行の長さ
009A-                119      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                120      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                121      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                122      ModuloMode      .bs     1       ; 剰余演算フラグ 0 = tranc, 1以上 = floor
00A0-                123      ToSubFlag       .bs     1       ; 分岐モードフラグ 0 = goto, 1 = gosub
00A1-                124      SStackPtr       .bs     2       ; サブルーチンスタック（Subroutine stack）ポインタ
00A3-                125      ArrayAddr       .bs     2       ; 配列変数の先頭アドレス
00A5-                126      MaxSubscript    .bs     2       ; 配列の最大添字数
00A7-                127      RndNumber       .bs     2       ; 乱数値
00A9-                128
00A9-                129      ; General-Purpose Registers
00A9-                130      UR0             *
00A9-                131      UR0H            .bs     1
00AA-                132      UR0L            .bs     1
00AB-                133      UR1             *
00AB-                134      UR1H            .bs     1
00AC-                135      UR1L            .bs     1
00AD-                136      UR2             *
00AD-                137      UR2H            .bs     1
00AE-                138      UR2L            .bs     1
00AF-                139      UR3             *
00AF-                140      UR3H            .bs     1
00B0-                141      UR3L            .bs     1
00B1-                142      ; Work area
00B1-                143      COMPARE         .bs     6       ; 文字列比較用バッファ
00B7-                144
00B7-                145      ; ***********************************************************************
00B7-                146      ;   ワークエリア work area
00B7-                147      ; ***********************************************************************
00B7-                148              .sm     RAM
0200-                149              .or     $0200
0200-                150      CSTACK          .bs     40      ; 計算スタック (Calculate stack)
0227-                151      CSTACK_BTM      .eq     *-1
0028-                152      CSTACK_SIZE     .eq     CSTACK_BTM-CSTACK+1
0228-                153      SSTACK          .bs     40      ; サブルーチンスタック (Subroutine stack)
024F-                154      SSTACK_BTM      .eq     *-1
0028-                155      SSTACK_SIZE     .eq     SSTACK_BTM-SSTACK+1
02C2-                156              .or     $02c2
02C2-                157      VARIABLE        .bs     52      ; 変数26文字 ($02c2-02f5)
02F5-                158      VARIABLE_END    .eq     *-1
0034-                159      VARIABLE_SIZE   .eq     VARIABLE_END-VARIABLE+1
02F6-                160
02F6-                161      ; ***********************************************************************
02F6-                162      ;   Program Start
02F6-                163      ; ***********************************************************************
0000-                164              .sm     CODE
1000-                165              .or     PROGRAM_START
1000-                166
1000-                167      init_tinybasic:
1000-30              168 ( 1)         tsx
1001-DF 80           169 ( 4)         stx     <StackPointer
1003-CE 1A 3F        170 ( 3)         ldx     #ESC_CLEAR
1006-BD FF AF        171 ( 6)         jsr     write_line
1009-CE 1A 4A        172 ( 3)         ldx     #MSG_TBSTART
100C-BD FF AF        173 ( 6)         jsr     write_line
100F-                174
100F-                175
100F-                176      cold_start:
100F-                177            ; // プログラムエリアの初期化
100F-CE 04 00        178 ( 3)         ldx     #USER_AREA_TOP
1012-DF 9A           179 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1014-4F              180 ( 1)         clra
1015-5F              181 ( 1)         clrb
1016-ED 00           182 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
1018-97 98           183 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
101A-                184            ; // 変数領域の初期化
101A-CE 02 C2        185 ( 3)         ldx     #VARIABLE
101D-ED 00           186 ( 5) .loop   std     0,x
101F-08              187 ( 1)         inx
1020-08              188 ( 1)         inx
1021-8C 02 F6        189 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
1024-26 F7           190 ( 3)         bne     :loop
1026-                191            ; // 配列変数の初期化
1026-CC 04 02        192 ( 3)         ldd     #USER_AREA_TOP+2
1029-DD A3           193 ( 4)         std     <ArrayAddr
102B-CC 09 FF        194 ( 3)         ldd     #USER_AREA_BTM+2-USER_AREA_TOP
102E-04              195 ( 1)         lsrd
102F-DD A5           196 ( 4)         std     <MaxSubscript
1031-                197            ; // 乱数のSeed値の設定
1031-DC 09           198 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
1033-27 FC           199 ( 3)         beq     :seed           ; Seedはゼロ以外
1035-DD A7           200 ( 4)         std     <RndNumber
1037-                201
1037-                202      warm_start:
1037-                203            ; // スタックポインタの初期化
1037-CE 02 50        204 ( 3)         ldx     #SSTACK_BTM+1
103A-DF A1           205 ( 4)         stx     <SStackPtr
103C-                206            ; // 各種フラグの初期化
103C-4F              207 ( 1)         clra
103D-97 9F           208 ( 3)         staa    <ModuloMode     ; 剰余演算をtrunc（0への切捨て除算）にする
103F-97 A0           209 ( 3)         staa    <ToSubFlag      ; 分岐モードを0 = gotoにする
1041-                210
1041-                211
1041-                212      tb_main:
1041-CE 1A 5C        213 ( 3)         ldx     #MSG_OK
1044-BD FF AF        214 ( 6)         jsr     write_line
1047-72 01 9C        215 ( 6) prompt: oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
104A-C6 3E           216 ( 2)         ldab    #'>'
104C-BD FF AC        217 ( 6)         jsr     write_char
104F-BD FF A9        218 ( 6)         jsr     read_line
1052-CE 01 40        219 ( 3)         ldx     #TEXT_BFFR      ; 実行位置アドレスをセット
1055-                220            ; // 行番号判定
1055-BD 14 C1        221 ( 6)         jsr     get_int_from_decimal
1058-24 0A           222 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
105A-83 00 00        223 ( 3)         subd    #0
105D-2E 08           224 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
105F-86 0C           225 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1061-7E 18 F6        226 ( 3)         jmp     write_err_msg
1064-                227
1064-                228      ; 実行モード（ダイレクトモード）
1064-                229      execute_mode:
1064-7E 11 9D        230 ( 3)         jmp     exe_line
1067-                231
1067-                232      ; 行編集モード
1067-                233      ; 空行か否か、空行でなければ同じ行番号か否かで処理を振り分ける
1067-                234      edit_mode:
1067-DF 8D           235 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1069-DD 96           236 ( 4)         std     <LineNumber     ; 行番号を保存
106B-                237            ; // 空行チェック
106B-BD 15 8A        238 ( 6)         jsr     skip_space
106E-26 02           239 ( 3)         bne     :1
1070-20 1B           240 ( 3)         bra     delete_line     ; 空行だったら削除ルーチンへ
1072-                241      .1    ; // 入力行の長さチェック（Aレジスタに文字数）
1072-DE 8D           242 ( 4)         ldx     <ExePointer     ; バッファアドレスを復帰
1074-86 04           243 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1076-E6 00           244 ( 4) .loop   ldab    0,x
1078-27 04           245 ( 3)         beq     :2
107A-4C              246 ( 1)         inca                    ; 行の長さを+1
107B-08              247 ( 1)         inx                     ; バッファアドレスを+1
107C-20 F8           248 ( 3)         bra     :loop
107E-97 99           249 ( 3) .2      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
1080-                250            ; // 同じ行があるかどうか確認
1080-CE 04 00        251 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
1083-BD 15 EE        252 ( 6)         jsr     scan_line_num   ; 行番号検索
1086-DF 9D           253 ( 4)         stx     <ExeLineAddr    ; 検索した行アドレスをExeLineAddrに退避しておく
1088-24 29           254 ( 3)         bcc     not_same_line_num
108A-7E 11 13        255 ( 3)         jmp     same_line_num
108D-                256
108D-                257      ; 一行削除
108D-                258      delete_line:
108D-CE 04 00        259 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
1090-BD 15 EE        260 ( 6)         jsr     scan_line_num   ; 行番号検索
1093-24 1B           261 ( 3)         bcc     :end            ; 同じ行がなければ何もしない
1095-                262            ; // 転送先アドレスの設定（既存の行の先頭アドレス）
1095-DF 92           263 ( 4)         stx     <Destination
1097-                264            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1097-E6 02           265 ( 4)         ldab    2,x
1099-D7 99           266 ( 3)         stab    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存しておく
109B-3A              267 ( 1)         abx
109C-DF 90           268 ( 4)         stx     <Source
109E-                269            ; // 転送バイト数の設定（プログラム終端アドレス - 次の行の先頭アドレス + 2）
109E-DC 9A           270 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10A0-93 90           271 ( 4)         subd    <Source         ; - 次の行の先頭アドレス
10A2-C3 00 02        272 ( 3)         addd    #2              ; + 2
10A5-DD 94           273 ( 4)         std     <Bytes
10A7-                274            ; // ブロック転送
10A7-BD 17 C1        275 ( 6)         jsr     mem_move
10AA-                276            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス - 行の長さ）
10AA-DC 9A           277 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10AC-93 98           278 ( 4)         subd    <LineLength     ; - 行の長さ
10AE-DD 9A           279 ( 4)         std     <PrgmEndAddr
10B0-7E 11 6B        280 ( 3) .end    jmp     array_index
10B3-                281
10B3-                282      ; 同じ行番号がなかった場合の処理
10B3-                283      not_same_line_num:
10B3-                284            ; // D:次に大きな行番号 X:次に大きな行の先頭アドレス
10B3-83 00 00        285 ( 3)         subd    #0              ; tstd
10B6-27 22           286 ( 3)         beq     :add            ; 最終行より後ろ（D=$0000）だったら入力行挿入
10B8-                287            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10B8-DC 9A           288 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10BA-D3 98           289 ( 4)         addd    <LineLength     ; + 行の長さ
10BC-8D 48           290 ( 5)         bsr     check_pgrm_end
10BE-DD 9A           291 ( 4)         std     <PrgmEndAddr
10C0-                292            ; // 転送元アドレスの設定（次に大きな行の先頭アドレス）
10C0-DF 90           293 ( 4)         stx     <Source
10C2-                294            ; // 転送先アドレスの設定（次に大きな行の先頭アドレス + 行の長さ）
10C2-D6 99           295 ( 3)         ldab    <LineLength+1   ; 行の長さ
10C4-3A              296 ( 1)         abx                     ; + 次に大きな行の先頭アドレス
10C5-DF 92           297 ( 4)         stx     <Destination
10C7-                298            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
10C7-DC 9A           299 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10C9-93 90           300 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
10CB-C3 00 02        301 ( 3)         addd    #2              ; + 2
10CE-DD 94           302 ( 4)         std     <Bytes
10D0-                303            ; // ブロック転送
10D0-BD 17 C1        304 ( 6)         jsr     mem_move
10D3-                305            ; // 入力行の挿入
10D3-DE 9D           306 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
10D5-8D 16           307 ( 5)         bsr     insert_new_line
10D7-7E 11 6B        308 ( 3)         jmp     array_index
10DA-                309      .add
10DA-                310            ; // D:$0000 X:プログラム終端アドレス
10DA-                311            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10DA-DC 9A           312 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10DC-D3 98           313 ( 4)         addd    <LineLength     ; + 行の長さ
10DE-8D 26           314 ( 5)         bsr     check_pgrm_end
10E0-DD 9A           315 ( 4)         std     <PrgmEndAddr
10E2-                316            ; // 入力行の挿入
10E2-8D 09           317 ( 5)         bsr     insert_new_line
10E4-                318            ; // 終端行の挿入
10E4-DE 9A           319 ( 4)         ldx     <PrgmEndAddr
10E6-4F              320 ( 1)         clra
10E7-5F              321 ( 1)         clrb
10E8-ED 00           322 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
10EA-7E 11 6B        323 ( 3)         jmp     array_index
10ED-                324
10ED-                325      ; 入力行の転送
10ED-                326      insert_new_line:
10ED-DC 96           327 ( 4)         ldd     <LineNumber     ; 行番号を転送
10EF-ED 00           328 ( 5)         std     0,x
10F1-08              329 ( 1)         inx
10F2-08              330 ( 1)         inx
10F3-D6 99           331 ( 3)         ldab    <LineLength+1   ; 行の長さを転送
10F5-E7 00           332 ( 4)         stab    0,x
10F7-08              333 ( 1)         inx
10F8-                334            ; // 転送先アドレスの設定（現在の位置）
10F8-DF 92           335 ( 4)         stx     <Destination
10FA-                336            ; // 転送バイト数の設定（行の長さ - 3（行番号 - 長さ））
10FA-4F              337 ( 1)         clra                    ; 行の長さ（A=0,B=下位8bit）
10FB-C0 03           338 ( 2)         subb    #3              ; - 3
10FD-DD 94           339 ( 4)         std     <Bytes
10FF-                340            ; // 転送元アドレスの設定（入力された行）
10FF-DC 8D           341 ( 4)         ldd     <ExePointer     ; バッファアドレスを復帰（行番号の直後を指している）
1101-DD 90           342 ( 4)         std     <Source
1103-                343            ; // ブロック転送
1103-7E 17 C1        344 ( 3)         jmp     mem_move        ; 飛び先でrts
1106-                345
1106-                346      ; プログラムエリアを超えていないか確認
1106-                347      check_pgrm_end:
1106-18              348 ( 2)         xgdx
1107-8C 0D FD        349 ( 3)         cpx     #USER_AREA_BTM
110A-18              350 ( 2)         xgdx
110B-24 01           351 ( 3)         bcc     :err14
110D-39              352 ( 5)         rts
110E-86 0E           353 ( 2) .err14  ldaa    #14              ; "Memory size over"
1110-7E 18 F6        354 ( 3)         jmp     write_err_msg
1113-                355
1113-                356      ; 同じ行番号があった場合、既存の行との長さの差で処理を振り分ける
1113-                357      same_line_num:
1113-                358            ; // D:行番号 X:既存の行の開始アドレス
1113-96 99           359 ( 3)         ldaa    <LineLength+1   ; 入力行の長さを取得
1115-A0 02           360 ( 4)         suba    2,x             ; **Aレジスタ** = 入力行の長さ - 既存行の長さ
1117-2B 2D           361 ( 3)         bmi     short_length    ; 入力行の長さ < 既存行の長さ
1119-27 26           362 ( 3)         beq     same_length     ; 入力行の長さ = 既存行の長さ
111B-                363
111B-                364      ; 入力行が既存の行より長い場合
111B-                365      long_length:                    ; 入力行の長さ > 既存行の長さ
111B-                366            ; // 転送元アドレスの設定（次の行の先頭アドレス）
111B-E6 02           367 ( 4)         ldab    2,x
111D-3A              368 ( 1)         abx
111E-DF 90           369 ( 4)         stx     <Source
1120-                370            ; // 転送先アドレスの設定（次の行の先頭アドレス + 入力行の長さ - 既存行の長さ）
1120-16              371 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
1121-4F              372 ( 1)         clra
1122-DD AB           373 ( 4)         std     <UR1            ; 入力行の長さ - 既存行の長さを後で使うためにUR1に保存
1124-3A              374 ( 1)         abx                     ; 次の行の先頭アドレス + （入力行の長さ - 既存行の長さ）
1125-DF 92           375 ( 4)         stx     <Destination
1127-                376            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1127-DC 9A           377 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1129-93 90           378 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
112B-C3 00 02        379 ( 3)         addd    #2              ; + 2
112E-DD 94           380 ( 4)         std     <Bytes
1130-                381            ; // 新しいプログラム終端アドレスの設定
1130-                382            ; // （プログラム終端アドレス + 入力行の長さ - 既存行の長さ）
1130-DC 9A           383 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1132-D3 AB           384 ( 4)         addd    <UR1            ; + 入力行の長さ - 既存行の長さ
1134-8D D0           385 ( 5)         bsr     check_pgrm_end
1136-DD 9A           386 ( 4)         std     <PrgmEndAddr
1138-                387            ; // ブロック転送
1138-BD 17 C1        388 ( 6)         jsr     mem_move
113B-                389            ; // 入力行の挿入
113B-DE 9D           390 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
113D-8D AE           391 ( 5)         bsr     insert_new_line
113F-20 2A           392 ( 3)         bra     array_index
1141-                393
1141-                394      ; 入力行と既存の行が同じ長さの場合
1141-                395      same_length:
1141-8D AA           396 ( 5)         bsr     insert_new_line
1143-7E 10 47        397 ( 3)         jmp     prompt
1146-                398
1146-                399      ; 入力行が既存の行より短い場合
1146-                400      short_Length:
1146-                401            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1146-E6 02           402 ( 4)         ldab    2,x
1148-3A              403 ( 1)         abx
1149-DF 90           404 ( 4)         stx     <Source
114B-                405            ; // 転送先アドレスの設定（次の行の先頭アドレス - 既存行の長さ + 入力行の長さ）
114B-16              406 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
114C-50              407 ( 1)         negb                    ; 絶対値にする
114D-4F              408 ( 1)         clra
114E-DD AB           409 ( 4)         std     <UR1            ; 既存行の長さ - 入力行の長さ
1150-18              410 ( 2)         xgdx
1151-93 AB           411 ( 4)         subd    <UR1            ; 次の行の先頭アドレス - （既存行の長さ - 入力行の長さ）
1153-DD 92           412 ( 4)         std     <Destination
1155-                413            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1155-DC 9A           414 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1157-93 90           415 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1159-C3 00 02        416 ( 3)         addd    #2              ; + 2
115C-DD 94           417 ( 4)         std     <Bytes
115E-                418            ; // ブロック転送
115E-BD 17 C1        419 ( 6)         jsr     mem_move
1161-                420            ; // 新しいプログラム終端アドレスの設定
1161-                421            ; // （プログラム終端アドレス - 既存行の長さ + 入力行の長さ）
1161-DC 9A           422 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1163-93 AB           423 ( 4)         subd    <UR1            ; - （既存行の長さ - 入力行の長さ）
1165-DD 9A           424 ( 4)         std     <PrgmEndAddr
1167-                425            ; // 入力行の挿入
1167-DE 9D           426 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1169-8D 82           427 ( 5)         bsr     insert_new_line
116B-                428
116B-                429      array_index:
116B-DC 9A           430 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
116D-C3 00 02        431 ( 3)         addd    #2              ; + 2
1170-DD A3           432 ( 4)         std     <ArrayAddr      ; 配列変数の先頭アドレス
1172-CC 0D FF        433 ( 3)         ldd     #USER_AREA_BTM+2
1175-93 A3           434 ( 4)         subd    <ArrayAddr
1177-04              435 ( 1)         lsrd
1178-DD A5           436 ( 4)         std     <MaxSubscript
117A-7E 10 47        437 ( 3)         jmp     prompt
117D-                438
117D-                439
117D-                440      ; -----------------------------------------------------------------------
117D-                441      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
117D-                442      ; Is a multi statement mark?
117D-                443      ;【引数】X:実行位置アドレス
117D-                444      ;【使用】B, X
117D-                445      ;【返値】なし
117D-                446      ; -----------------------------------------------------------------------
117D-                447      is_multi:
117D-BD 15 8A        448 ( 6)         jsr     skip_space
1180-27 0B           449 ( 3)         beq     eol_process
1182-C1 3A           450 ( 2)         cmpb    #':'
1184-26 03           451 ( 3)         bne     :err00
1186-08              452 ( 1)         inx
1187-20 14           453 ( 3)         bra     exe_line
1189-4F              454 ( 1) .err00  clra                    ; "Syntax error"
118A-7E 18 F6        455 ( 3)         jmp     write_err_msg
118D-                456
118D-                457
118D-                458      ; -----------------------------------------------------------------------
118D-                459      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
118D-                460      ;  - directモードであればそのまま終了
118D-                461      ;  - runモードであれば次の行のポインタを設定してrts
118D-                462      ; End-of-line processing
118D-                463      ;  - If in direct mode, terminate execution
118D-                464      ;  - If run mode, set the pointer to the next line and rts
118D-                465      ;【引数】なし
118D-                466      ;【使用】A, B, X
118D-                467      ;【返値】なし
118D-                468      ; -----------------------------------------------------------------------
118D-                469      eol_process:
118D-                470            ; // runモードであれば次の行のポインタを設定してrts
118D-7D 00 9C        471 ( 4)         tst     <ExeStateFlag
1190-26 08           472 ( 3)         bne     :end
1192-DE 9D           473 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
1194-E6 02           474 ( 4)         ldab    2,x             ; 行の長さを取得
1196-3A              475 ( 1)         abx                     ; 次の行の先頭アドレスを取得
1197-DF 9D           476 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
1199-39              477 ( 5)         rts
119A-7E 10 37        478 ( 3) .end    jmp     warm_start      ; directモードであればそのまま終了
119D-                479
119D-                480
119D-                481      ; -----------------------------------------------------------------------
119D-                482      ; 一行実行
119D-                483      ; Execute one line
119D-                484      ;【引数】X:実行位置アドレス
119D-                485      ;【使用】A, B, X
119D-                486      ;【返値】なし
119D-                487      ; -----------------------------------------------------------------------
119D-                488      exe_line:
119D-BD 15 8A        489 ( 6)         jsr     skip_space
11A0-27 EB           490 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
11A2-C1 27           491 ( 2)         cmpb    #APOSTROPHE     ; "'"であれば行末まで読み飛ばす
11A4-27 E7           492 ( 3)         beq     eol_process
11A6-                493            ; // 配列変数のチェック
11A6-C1 40           494 ( 2)         cmpb    #'@'
11A8-26 1B           495 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
11AA-E6 01           496 ( 4)         ldab    1,x
11AC-C1 28           497 ( 2)         cmpb    #'('            ; 直後の文字は'('？
11AE-26 4A           498 ( 3)         bne     :err00          ; No. "Syntax error"
11B0-08              499 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
11B1-08              500 ( 1)         inx
11B2-BD 12 03        501 ( 6)         jsr     eval_expression ; 添字を取得する
11B5-24 47           502 ( 3)         bcc     :err04
11B7-                503            ; // ')'の確認
11B7-37              504 ( 4)         pshb                    ; 添字の下位8bitを退避
11B8-E6 00           505 ( 4)         ldab    0,x
11BA-C1 29           506 ( 2)         cmpb    #')'
11BC-26 3C           507 ( 3)         bne     :err00
11BE-33              508 ( 3)         pulb                    ; 添字の下位8bitを復帰
11BF-08              509 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
11C0-BD 15 C7        510 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
11C3-20 08           511 ( 3)         bra     :let
11C5-BD 15 75        512 ( 6) .var    jsr     is_variable     ; 変数か？
11C8-24 12           513 ( 3)         bcc     :cmd            ; No. テーブル検索へ
11CA-86 02           514 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
11CC-58              515 ( 1)         aslb                    ; B = 変数領域の下位バイト
11CD-DD 8B           516 ( 4) .let    std     <VariableAddr   ; 変数アドレスを保存
11CF-                517            ; // 代入文のチェック
11CF-BD 15 8A        518 ( 6)         jsr     skip_space      ; Yes. 代入文か？
11D2-C1 3D           519 ( 2)         cmpb    #'='
11D4-26 24           520 ( 3)         bne     :err00          ; No. エラー処理へ
11D6-08              521 ( 1)         inx                     ; Yes. 代入実行
11D7-BD 15 DA        522 ( 6)         jsr     assign_to_var
11DA-20 A1           523 ( 3)         bra     is_multi
11DC-                524            ; // コマンド・ステートメントのチェック
11DC-EC 00           525 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
11DE-DD B1           526 ( 4)         std     <COMPARE
11E0-EC 02           527 ( 5)         ldd     2,x
11E2-DD B3           528 ( 4)         std     <COMPARE+2
11E4-EC 04           529 ( 5)         ldd     4,x
11E6-DD B5           530 ( 4)         std     <COMPARE+4
11E8-DF 8D           531 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
11EA-7D 00 9C        532 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
11ED-27 05           533 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
11EF-CE 18 6F        534 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
11F2-20 03           535 ( 3)         bra     :2
11F4-CE 18 8B        536 ( 3) .1      ldx     #SMT_TABLE
11F7-BD 18 32        537 ( 6) .2      jsr     search_table    ; テーブル検索実行
11FA-4F              538 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
11FB-7E 18 F6        539 ( 3)         jmp     write_err_msg
11FE-86 04           540 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1200-7E 18 F6        541 ( 3)         jmp     write_err_msg
1203-                542
1203-                543
1203-                544      ; -----------------------------------------------------------------------
1203-                545      ; 式を評価する
1203-                546      ; Evaluate the expression
1203-                547      ;【引数】B:アスキーコード X:実行位置アドレス
1203-                548      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
1203-                549      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
1203-                550      ;        偽(C=0) / X:現在の実行位置アドレス
1203-                551      ; -----------------------------------------------------------------------
1203-                552      eval_expression:
00AD-                553      .SP     .eq     UR2
00AF-                554      .X      .eq     UR3
1203-                555            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
1203-DF AF           556 ( 4)         stx     <:X
1205-30              557 ( 1)         tsx
1206-DF AD           558 ( 4)         stx     <:SP
1208-DE AF           559 ( 4)         ldx     <:X
120A-                560            ; // 計算スタックの初期化
120A-CC 02 28        561 ( 3)         ldd     #CSTACK_BTM+1
120D-DD 82           562 ( 4)         std     <CStackPtr
120F-                563            ; // 式評価開始
120F-8D 08           564 ( 5)         bsr     expr_4th
1211-                565            ; // 計算結果をスタックトップから取り出す
1211-3C              566 ( 5)         pshx
1212-DE 82           567 ( 4)         ldx     <CStackPtr
1214-EC 00           568 ( 5)         ldd     0,x
1216-38              569 ( 4)         pulx
1217-0D              570 ( 1)         sec                     ; true:C=1
1218-39              571 ( 5)         rts
1219-                572
1219-                573      expr_4th:
1219-8D 50           574 ( 5)         bsr     expr_3rd
121B-BD 15 8A        575 ( 6) .loop   jsr     skip_space
121E-C1 3D           576 ( 2)         cmpb    #'='            ; '='?
1220-26 08           577 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
1222-08              578 ( 1)         inx
1223-8D 46           579 ( 5)         bsr     expr_3rd
1225-BD 14 74        580 ( 6)         jsr     CS_eq           ; EQual to
1228-20 F1           581 ( 3)         bra     :loop
122A-C1 3C           582 ( 2) .ltsign cmpb    #'<'            ; '<'?
122C-26 22           583 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
122E-08              584 ( 1)         inx
122F-E6 00           585 ( 4)         ldab    0,x
1231-C1 3E           586 ( 2)         cmpb    #'>'            ; '<>'?
1233-26 08           587 ( 3)         bne     :lte
1235-08              588 ( 1)         inx
1236-8D 33           589 ( 5)         bsr     expr_3rd
1238-BD 14 95        590 ( 6)         jsr     CS_ne           ; Not Equal to
123B-20 DE           591 ( 3)         bra     :loop
123D-C1 3D           592 ( 2) .lte    cmpb    #'='            ; '<='?
123F-26 08           593 ( 3)         bne     :lt
1241-08              594 ( 1)         inx
1242-8D 27           595 ( 5)         bsr     expr_3rd
1244-BD 14 8A        596 ( 6)         jsr     CS_lte          ; Less Than or Equal to
1247-20 D2           597 ( 3)         bra     :loop
1249-8D 20           598 ( 5) .lt     bsr     expr_3rd
124B-BD 14 7F        599 ( 6)         jsr     CS_lt           ; Less Than
124E-20 CB           600 ( 3)         bra     :loop
1250-C1 3E           601 ( 2) .gtsign cmpb    #'>'            ; '>'?
1252-26 16           602 ( 3)         bne     :end
1254-08              603 ( 1)         inx
1255-E6 00           604 ( 4)         ldab    0,x
1257-C1 3D           605 ( 2)         cmpb    #'='            ; '>='?
1259-26 08           606 ( 3)         bne     :gt
125B-08              607 ( 1)         inx
125C-8D 0D           608 ( 5)         bsr     expr_3rd
125E-BD 14 AB        609 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
1261-20 B8           610 ( 3)         bra     :loop
1263-8D 06           611 ( 5) .gt     bsr     expr_3rd
1265-BD 14 A0        612 ( 6)         jsr     CS_gt           ; Greater Than
1268-20 B1           613 ( 3)         bra     :loop
126A-39              614 ( 5) .end    rts
126B-                615
126B-                616      expr_3rd:
126B-8D 1C           617 ( 5)         bsr     expr_2nd
126D-BD 15 8A        618 ( 6) .loop   jsr     skip_space
1270-C1 2B           619 ( 2)         cmpb    #'+'
1272-26 08           620 ( 3)         bne     :minus
1274-08              621 ( 1)         inx
1275-8D 12           622 ( 5)         bsr     expr_2nd
1277-BD 13 3E        623 ( 6)         jsr     CS_add
127A-20 F1           624 ( 3)         bra     :loop
127C-C1 2D           625 ( 2) .minus  cmpb    #'-'
127E-26 08           626 ( 3)         bne     :end
1280-08              627 ( 1)         inx
1281-8D 06           628 ( 5)         bsr     expr_2nd
1283-BD 13 47        629 ( 6)         jsr     CS_sub
1286-20 E5           630 ( 3)         bra     :loop
1288-39              631 ( 5) .end    rts
1289-                632
1289-                633      expr_2nd:
1289-8D 28           634 ( 5)         bsr     expr_1st
128B-BD 15 8A        635 ( 6) .loop   jsr     skip_space
128E-C1 2A           636 ( 2)         cmpb    #'*'
1290-26 08           637 ( 3)         bne     :div
1292-08              638 ( 1)         inx
1293-8D 1E           639 ( 5)         bsr     expr_1st
1295-BD 13 50        640 ( 6)         jsr     CS_mul
1298-20 F1           641 ( 3)         bra     :loop
129A-C1 2F           642 ( 2) .div    cmpb    #'/'
129C-26 08           643 ( 3)         bne     :mod
129E-08              644 ( 1)         inx
129F-8D 12           645 ( 5)         bsr     expr_1st
12A1-BD 13 6D        646 ( 6)         jsr     CS_div
12A4-20 E5           647 ( 3)         bra     :loop
12A6-C1 25           648 ( 2) .mod    cmpb    #'%'
12A8-26 08           649 ( 3)         bne     :end
12AA-08              650 ( 1)         inx
12AB-8D 06           651 ( 5)         bsr     expr_1st
12AD-BD 13 86        652 ( 6)         jsr     CS_mod
12B0-20 D9           653 ( 3)         bra     :loop
12B2-39              654 ( 5) .end    rts
12B3-                655
12B3-                656      expr_1st:
00AD-                657      .SP     .eq     UR2
00AF-                658      .X      .eq     UR3
12B3-BD 15 8A        659 ( 6)         jsr     skip_space
12B6-BD 14 C1        660 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
12B9-24 02           661 ( 3)         bcc     :array          ; 数字でなければ配列変数のチェックへ
12BB-20 59           662 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
12BD-C1 40           663 ( 2) .array  cmpb    #'@'
12BF-26 22           664 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
12C1-E6 01           665 ( 4)         ldab    1,x
12C3-C1 28           666 ( 2)         cmpb    #'('            ; 直後の文字は'('？
12C5-26 66           667 ( 3)         bne     :err00          ; No. "Syntax error"
12C7-08              668 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
12C8-08              669 ( 1)         inx
12C9-BD 12 19        670 ( 6)         jsr     expr_4th        ; 添字を取得する
12CC-                671            ; // ')'の確認
12CC-C1 29           672 ( 2)         cmpb    #')'
12CE-26 5D           673 ( 3)         bne     :err00
12D0-3C              674 ( 5)         pshx                    ; 実行位置アドレスを退避
12D1-DE 82           675 ( 4)         ldx     <CStackPtr
12D3-EC 00           676 ( 5)         ldd     0,x             ; 添字の取得
12D5-08              677 ( 1)         inx
12D6-08              678 ( 1)         inx
12D7-DF 82           679 ( 4)         stx     <CStackPtr
12D9-BD 15 C7        680 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
12DC-18              681 ( 2)         xgdx                    ; X = 配列変数のアドレス
12DD-EC 00           682 ( 5)         ldd     0,x             ; 配列変数値を取得
12DF-38              683 ( 4)         pulx                    ; 実行位置アドレスを復帰
12E0-08              684 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
12E1-20 33           685 ( 3)         bra     :push
12E3-BD 15 75        686 ( 6) .var    jsr     is_variable     ; 変数か？
12E6-24 0A           687 ( 3)         bcc     :func           ; 変数でなければカッコのチェックへ
12E8-                688            ; // 変数値の取得
12E8-3C              689 ( 5)         pshx                    ; 実行位置アドレスを退避
12E9-86 02           690 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
12EB-58              691 ( 1)         aslb                    ; B = 変数領域の下位バイト
12EC-18              692 ( 2)         xgdx                    ; X = 変数のアドレス
12ED-EC 00           693 ( 5)         ldd     0,x             ; D <- 変数の値
12EF-38              694 ( 4)         pulx                    ; 実行位置アドレスを復帰
12F0-20 24           695 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
12F2-EC 00           696 ( 5) .func   ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
12F4-DD B1           697 ( 4)         std     <COMPARE
12F6-EC 02           698 ( 5)         ldd     2,x
12F8-DD B3           699 ( 4)         std     <COMPARE+2
12FA-EC 04           700 ( 5)         ldd     4,x
12FC-DD B5           701 ( 4)         std     <COMPARE+4
12FE-DF 8D           702 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
1300-CE 18 EA        703 ( 3)         ldx     #FUNC_TABLE
1303-BD 18 32        704 ( 6)         jsr     search_table    ; テーブル検索実行。飛び先でrts
1306-E6 00           705 ( 4)         ldab    0,x             ; 該当関数がなかった場合はもう一度文字を読み込む
1308-C1 28           706 ( 2) .paren  cmpb    #'('
130A-26 1A           707 ( 3)         bne     :err
130C-08              708 ( 1)         inx
130D-BD 12 19        709 ( 6)         jsr     expr_4th
1310-C1 29           710 ( 2)         cmpb    #')'
1312-26 12           711 ( 3)         bne     :err
1314-08              712 ( 1)         inx
1315-39              713 ( 5)         rts
1316-3C              714 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1317-DE 82           715 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1319-09              716 ( 1)         dex
131A-09              717 ( 1)         dex
131B-8C 01 FE        718 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
131E-25 11           719 ( 3)         bcs     :err06
1320-ED 00           720 ( 5)         std     0,x
1322-DF 82           721 ( 4)         stx     <CStackPtr
1324-38              722 ( 4)         pulx                    ; 実行位置アドレスを復帰
1325-39              723 ( 5)         rts
1326-                724            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
1326-DE AD           725 ( 4) .err    ldx     <:SP
1328-35              726 ( 1)         txs
1329-DE AF           727 ( 4)         ldx     <:X
132B-0C              728 ( 1)         clc                     ; false:C=0
132C-39              729 ( 5)         rts
132D-4F              730 ( 1) .err00  clra                    ; "Syntax error"
132E-7E 18 F6        731 ( 3)         jmp     write_err_msg
1331-86 06           732 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
1333-7E 18 F6        733 ( 3)         jmp     write_err_msg
1336-                734
1336-                735      ;
1336-                736      ; Arithmetic operator
1336-                737      ;
1336-                738      CS_store:
1336-08              739 ( 1)         inx
1337-08              740 ( 1)         inx
1338-ED 00           741 ( 5)         std     0,x
133A-DF 82           742 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
133C-38              743 ( 4)         pulx                    ; 実行位置アドレスを復帰
133D-39              744 ( 5)         rts
133E-                745
133E-3C              746 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
133F-DE 82           747 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1341-EC 02           748 ( 5)         ldd     2,x
1343-E3 00           749 ( 5)         addd    0,x
1345-20 EF           750 ( 3)         bra     CS_store
1347-                751
1347-3C              752 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
1348-DE 82           753 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
134A-EC 02           754 ( 5)         ldd     2,x
134C-A3 00           755 ( 5)         subd    0,x
134E-20 E6           756 ( 3)         bra     CS_store
1350-                757
1350-                758      CS_mul:
00A9-                759      .Result         .eq     UR0
1350-3C              760 ( 5)         pshx                    ; 実行位置アドレスを退避
1351-DE 82           761 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1353-                762              ; B * D
1353-A6 03           763 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
1355-E6 01           764 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
1357-3D              765 ( 7)         mul                     ; B * D
1358-DD A9           766 ( 4)         std     <:Result        ;「B*D」を保存
135A-                767              ; A * D
135A-EC 01           768 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
135C-3D              769 ( 7)         mul                     ; A * D
135D-DB A9           770 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
135F-D7 A9           771 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
1361-                772              ; C * B
1361-A6 00           773 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
1363-E6 03           774 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
1365-3D              775 ( 7)         mul                     ; C * B
1366-DB A9           776 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1368-17              777 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1369-D6 AA           778 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
136B-20 C9           779 ( 3)         bra     CS_store
136D-                780
136D-                781      ;
136D-                782      ; trunc : 符号付き割り算の考え方
136D-                783      ; ・剰余は被除数の符号と同一
136D-                784      ;   ・ 7 / 3  = 商  2、剰余  1
136D-                785      ;   ・-7 / 3  = 商 -2、剰余 -1
136D-                786      ;   ・ 7 / -3 = 商 -2、剰余  1
136D-                787      ;   ・-7 / -3 = 商  2、剰余 -1
136D-                788      ;
136D-7D 00 9F        789 ( 4) CS_div: tst     <ModuloMode
1370-26 7A           790 ( 3)         bne     CS_div2
1372-3C              791 ( 5)         pshx                    ; 実行位置アドレスを退避
1373-DE 82           792 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1375-8D 2B           793 ( 5)         bsr     div_uint        ; 除算実行
1377-18              794 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1378-7D 00 85        795 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
137B-27 05           796 ( 3)         beq     :end            ; '+'なら終了
137D-43              797 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
137E-53              798 ( 1)         comb
137F-C3 00 01        799 ( 3)         addd    #1
1382-DE 82           800 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1384-20 B0           801 ( 3)         bra     CS_store
1386-                802
1386-7D 00 9F        803 ( 4) CS_mod: tst     <ModuloMode
1389-26 7E           804 ( 3)         bne     CS_mod2
138B-3C              805 ( 5)         pshx                    ; 実行位置アドレスを退避
138C-DE 82           806 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
138E-8D 12           807 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1390-DD 89           808 ( 4)         std     <Remainder      ; 剰余はゼロか？
1392-27 0A           809 ( 3)         beq     :end            ; ゼロであれば終了
1394-7D 00 86        810 ( 4)         tst     <RemSignFlag    ; 剰余の符号チェック
1397-27 05           811 ( 3)         beq     :end            ; '+'なら終了
1399-43              812 ( 1) .sign   coma                    ; '-'なら2の補数にする
139A-53              813 ( 1)         comb
139B-C3 00 01        814 ( 3)         addd    #1
139E-DE 82           815 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
13A0-20 94           816 ( 3)         bra     CS_store
13A2-                817
13A2-                818      div_uint:
00A9-                819      .Counter        .eq     UR0H
13A2-EC 00           820 ( 5)         ldd     0,x             ; ゼロ除算チェック
13A4-27 41           821 ( 3)         beq     :err08          ; 除数がゼロならエラー
13A6-5F              822 ( 1)         clrb
13A7-D7 85           823 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
13A9-D7 86           824 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
13AB-C6 10           825 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
13AD-D7 A9           826 ( 3)         stab    <:Counter
13AF-                827              ; // 剰余の符号フラグの設定
13AF-EC 02           828 ( 5)         ldd     2,x             ; Dレジスタに被除数を代入
13B1-2A 03           829 ( 3)         bpl     :1              ; 被除数が正であれば剰余の符号は正（0）
13B3-7C 00 86        830 ( 6)         inc     <RemSignFlag    ; 被除数が負であれば剰余の符号は負（1）
13B6-                831              ; // 商の符号フラグの設定
13B6-A8 00           832 ( 4) .1      eora    0,x             ; 被除数の符号と除数の符号のXORを取る
13B8-2A 03           833 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
13BA-7C 00 85        834 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
13BD-                835              ; // 除数を絶対値にする
13BD-EC 00           836 ( 5) .2      ldd     0,x             ; D <- 除数
13BF-2A 05           837 ( 3)         bpl     :3
13C1-43              838 ( 1)         coma                    ; 除数が負なら絶対値にする
13C2-53              839 ( 1)         comb
13C3-C3 00 01        840 ( 3)         addd    #1
13C6-DD 87           841 ( 4) .3      std     <Divisor        ; 除数を保存
13C8-                842              ; // 被除数を絶対値にする
13C8-EC 02           843 ( 5)         ldd     2,x             ; D <- 被除数
13CA-2A 05           844 ( 3)         bpl     :4
13CC-43              845 ( 1)         coma                    ; 被除数が負なら絶対値にする
13CD-53              846 ( 1)         comb
13CE-C3 00 01        847 ( 3)         addd    #1
13D1-                848              ; // 除算実行
13D1-18              849 ( 2) .4      xgdx                    ; X <- 被除数
13D2-4F              850 ( 1)         clra                    ; D（WORK）をクリア
13D3-5F              851 ( 1)         clrb
13D4-18              852 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
13D5-05              853 ( 1)         asld
13D6-18              854 ( 2)         xgdx
13D7-59              855 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
13D8-49              856 ( 1)         rola
13D9-93 87           857 ( 4)         subd    <Divisor        ; WORK - 除数
13DB-08              858 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
13DC-24 03           859 ( 3)         bcc     :5              ; WORKから除数を引けた？
13DE-D3 87           860 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
13E0-09              861 ( 1)         dex                     ; XレジスタのLSBを0に戻す
13E1-7A 00 A9        862 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
13E4-26 EE           863 ( 3)         bne     :loop
13E6-39              864 ( 5)         rts
13E7-86 08           865 ( 2) .err08  ldaa    #8              ; "Zero Divide"
13E9-7E 18 F6        866 ( 3)         jmp     write_err_msg
13EC-                867
13EC-                868      ;
13EC-                869      ; floor : 符号付き割り算の考え方
13EC-                870      ; ・剰余は除数の符号と同一
13EC-                871      ;   ・ 7 / 3  = 商  2、剰余  1
13EC-                872      ;   ・-7 / 3  = 商 -3、剰余  2
13EC-                873      ;   ・ 7 / -3 = 商 -3、剰余 -2
13EC-                874      ;   ・-7 / -3 = 商  2、剰余 -1
13EC-                875      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
13EC-                876      ;       2.ただし、除数がゼロの場合は1は足さない
13EC-                877      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
13EC-                878      ;         除数の絶対値から剰余の絶対値を引く
13EC-                879      ;       2.その結果を除数と同じ符号にする
13EC-                880      ;       3.ただし、除数がゼロの場合は剰余もゼロ
13EC-                881      ;
13EC-                882      CS_div2:
13EC-3C              883 ( 5)         pshx                    ; 実行位置アドレスを退避
13ED-DE 82           884 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13EF-8D 39           885 ( 5)         bsr     div_uint2       ; 除算実行
13F1-18              886 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
13F2-7D 00 85        887 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
13F5-27 0D           888 ( 3)         beq     :end            ; '+'なら終了
13F7-8C 00 00        889 ( 3)         cpx     #0              ; 剰余はゼロか？
13FA-27 03           890 ( 3)         beq     :sign
13FC-C3 00 01        891 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
13FF-43              892 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1400-53              893 ( 1)         comb
1401-C3 00 01        894 ( 3)         addd    #1
1404-DE 82           895 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1406-7E 13 36        896 ( 3)         jmp     CS_store
1409-                897
1409-                898      CS_mod2:
1409-3C              899 ( 5)         pshx                    ; 実行位置アドレスを退避
140A-DE 82           900 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
140C-8D 1C           901 ( 5)         bsr     div_uint2        ; 除算実行。D = 剰余
140E-DD 89           902 ( 4)         std     <Remainder      ; 剰余はゼロか？
1410-27 13           903 ( 3)         beq     :end            ; ゼロであれば終了
1412-7D 00 85        904 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
1415-27 04           905 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
1417-DC 87           906 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1419-93 89           907 ( 4)         subd    <Remainder
141B-7D 00 86        908 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
141E-27 05           909 ( 3)         beq     :end            ; '+'なら終了
1420-43              910 ( 1)         coma                    ; '-'なら2の補数にする
1421-53              911 ( 1)         comb
1422-C3 00 01        912 ( 3)         addd    #1
1425-DE 82           913 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1427-7E 13 36        914 ( 3)         jmp     CS_store
142A-                915
142A-                916      div_uint2:
00A9-                917      .Counter        .eq     UR0H
142A-EC 00           918 ( 5)         ldd     0,x             ; ゼロ除算チェック
142C-27 41           919 ( 3)         beq     :err08          ; 除数がゼロならエラー
142E-5F              920 ( 1)         clrb
142F-D7 85           921 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1431-D7 86           922 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1433-C6 10           923 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1435-D7 A9           924 ( 3)         stab    <:Counter
1437-                925              ; // 剰余の符号フラグの設定
1437-EC 00           926 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1439-2A 03           927 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
143B-7C 00 86        928 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
143E-                929              ; // 商の符号フラグの設定
143E-A8 02           930 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
1440-2A 03           931 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
1442-7C 00 85        932 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
1445-                933              ; // 除数を絶対値にする
1445-EC 00           934 ( 5) .2      ldd     0,x             ; D <- 除数
1447-2A 05           935 ( 3)         bpl     :3
1449-43              936 ( 1)         coma                    ; 除数が負なら絶対値にする
144A-53              937 ( 1)         comb
144B-C3 00 01        938 ( 3)         addd    #1
144E-DD 87           939 ( 4) .3      std     <Divisor        ; 除数を保存
1450-                940              ; // 被除数を絶対値にする
1450-EC 02           941 ( 5)         ldd     2,x             ; D <- 被除数
1452-2A 05           942 ( 3)         bpl     :4
1454-43              943 ( 1)         coma                    ; 被除数が負なら絶対値にする
1455-53              944 ( 1)         comb
1456-C3 00 01        945 ( 3)         addd    #1
1459-                946              ; // 除算実行
1459-18              947 ( 2) .4      xgdx                    ; X <- 被除数
145A-4F              948 ( 1)         clra                    ; D（WORK）をクリア
145B-5F              949 ( 1)         clrb
145C-18              950 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
145D-05              951 ( 1)         asld
145E-18              952 ( 2)         xgdx
145F-59              953 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
1460-49              954 ( 1)         rola
1461-93 87           955 ( 4)         subd    <Divisor        ; WORK - 除数
1463-08              956 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
1464-24 03           957 ( 3)         bcc     :5              ; WORKから除数を引けた？
1466-D3 87           958 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1468-09              959 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1469-7A 00 A9        960 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
146C-26 EE           961 ( 3)         bne     :loop
146E-39              962 ( 5)         rts
146F-86 08           963 ( 2) .err08  ldaa    #8              ; "Zero Divide"
1471-7E 18 F6        964 ( 3)         jmp     write_err_msg
1474-                965
1474-3C              966 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
1475-DE 82           967 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1477-EC 02           968 ( 5)         ldd     2,x
1479-A3 00           969 ( 5)         subd    0,x
147B-27 39           970 ( 3)         beq     CS_true
147D-20 3D           971 ( 3)         bra     CS_false
147F-                972
147F-3C              973 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1480-DE 82           974 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1482-EC 02           975 ( 5)         ldd     2,x
1484-A3 00           976 ( 5)         subd    0,x
1486-2D 2E           977 ( 3)         blt     CS_true
1488-20 32           978 ( 3)         bra     CS_false
148A-                979
148A-3C              980 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
148B-DE 82           981 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
148D-EC 02           982 ( 5)         ldd     2,x
148F-A3 00           983 ( 5)         subd    0,x
1491-2F 23           984 ( 3)         ble     CS_true
1493-20 27           985 ( 3)         bra     CS_false
1495-                986
1495-3C              987 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
1496-DE 82           988 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1498-EC 02           989 ( 5)         ldd     2,x
149A-A3 00           990 ( 5)         subd    0,x
149C-26 18           991 ( 3)         bne     CS_true
149E-20 1C           992 ( 3)         bra     CS_false
14A0-                993
14A0-3C              994 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
14A1-DE 82           995 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
14A3-EC 02           996 ( 5)         ldd     2,x
14A5-A3 00           997 ( 5)         subd    0,x
14A7-2E 0D           998 ( 3)         bgt     CS_true
14A9-20 11           999 ( 3)         bra     CS_false
14AB-               1000
14AB-3C             1001 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
14AC-DE 82          1002 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
14AE-EC 02          1003 ( 5)         ldd     2,x
14B0-A3 00          1004 ( 5)         subd    0,x
14B2-2C 02          1005 ( 3)         bge     CS_true
14B4-20 06          1006 ( 3)         bra     CS_false
14B6-               1007
14B6-               1008      CS_true:
14B6-CC 00 01       1009 ( 3)         ldd     #1
14B9-7E 13 36       1010 ( 3)         jmp     CS_store
14BC-               1011
14BC-               1012      CS_false:
14BC-4F             1013 ( 1)         clra
14BD-5F             1014 ( 1)         clrb
14BE-7E 13 36       1015 ( 3)         jmp     CS_store
14C1-               1016
14C1-               1017      ; -----------------------------------------------------------------------
14C1-               1018      ; テキストバッファの10進文字列から数値を取得する
14C1-               1019      ; Get a integer from a decimal string in a text buffer
14C1-               1020      ;【引数】X:バッファアドレス
14C1-               1021      ;【使用】A, B, X, UR0, UR1
14C1-               1022      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
14C1-               1023      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
14C1-               1024      ; -----------------------------------------------------------------------
14C1-               1025      get_int_from_decimal:
00A9-               1026      .RetValue       .eq     UR0     ; Return Value
00AB-               1027      .TempValue      .eq     UR1     ; Temporary Value
14C1-4F             1028 ( 1)         clra
14C2-5F             1029 ( 1)         clrb
14C3-DD A9          1030 ( 4)         std     <:RetValue
14C5-97 AB          1031 ( 3)         staa    <:TempValue
14C7-97 84          1032 ( 3)         staa    <SignFlag
14C9-E6 00          1033 ( 4)         ldab    0,x             ; 1文字取得
14CB-C1 2D          1034 ( 2)         cmpb    #'-'            ; マイナス記号か？
14CD-26 05          1035 ( 3)         bne     :1
14CF-7C 00 84       1036 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
14D2-20 0B          1037 ( 3)         bra     :next
14D4-C1 2B          1038 ( 2) .1      cmpb    #'+'            ; プラス記号か？
14D6-27 07          1039 ( 3)         beq     :next
14D8-BD FF C1       1040 ( 6)         jsr     is_decimal_char ; 数字か？
14DB-24 36          1041 ( 3)         bcc     :false          ; No. C=1で終了
14DD-20 13          1042 ( 3)         bra     :first
14DF-08             1043 ( 1) .next   inx                     ; 符号の次の1文字を取得
14E0-E6 00          1044 ( 4)         ldab    0,x
14E2-BD FF C1       1045 ( 6)         jsr     is_decimal_char ; 数字か？
14E5-24 40          1046 ( 3)         bcc     :err04          ; No. エラー処理へ
14E7-20 09          1047 ( 3)         bra     :first          ; Yes. これが最初の数字
14E9-DD A9          1048 ( 4) .loop   std     <:RetValue      ; 結果を退避
14EB-E6 00          1049 ( 4)         ldab    0,x             ; 1文字取得
14ED-BD FF C1       1050 ( 6)         jsr     is_decimal_char ; 数字か？
14F0-24 14          1051 ( 3)         bcc     :end
14F2-C0 30          1052 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
14F4-D7 AC          1053 ( 3)         stab    <:TempValue+1
14F6-               1054            ; // RetValue * 10 + TempValue
14F6-DC A9          1055 ( 4)         ldd     <:RetValue
14F8-05             1056 ( 1)         asld                    ; * 2
14F9-05             1057 ( 1)         asld                    ; * 4
14FA-D3 A9          1058 ( 4)         addd    <:RetValue      ; * 5
14FC-05             1059 ( 1)         asld                    ; * 10
14FD-D3 AB          1060 ( 4)         addd    <:TempValue     ; += TempValue
14FF-08             1061 ( 1)         inx                     ; ポインタを進める
1500-25 20          1062 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
1502-2B 10          1063 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
1504-20 E3          1064 ( 3)         bra     :loop
1506-DC A9          1065 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
1508-7D 00 84       1066 ( 4)         tst     <SignFlag       ; 符号チェック
150B-27 05          1067 ( 3)         beq     :true
150D-43             1068 ( 1)         coma                    ; 負なら2の補数に
150E-53             1069 ( 1)         comb
150F-C3 00 01       1070 ( 3)         addd    #1
1512-0D             1071 ( 1) .true   sec
1513-39             1072 ( 5) .false  rts
1514-               1073
1514-               1074      .overflow
1514-               1075            ; // -32,768かどうかの判定
1514-18             1076 ( 2)         xgdx
1515-8C 80 00       1077 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
1518-18             1078 ( 2)         xgdx
1519-26 07          1079 ( 3)         bne     :err02          ; No. 範囲外
151B-7D 00 84       1080 ( 4)         tst     <SignFlag       ; 符号チェック
151E-27 02          1081 ( 3)         beq     :err02          ; 正ならば範囲外
1520-20 C7          1082 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
1522-               1083
1522-86 02          1084 ( 2) .err02  ldaa    #2              ; "Out of range"
1524-7E 18 F6       1085 ( 3)         jmp     write_err_msg
1527-86 04          1086 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1529-7E 18 F6       1087 ( 3)         jmp     write_err_msg
152C-               1088
152C-               1089
152C-               1090      ; -----------------------------------------------------------------------
152C-               1091      ; Dレジスタの数値をコンソールに出力する
152C-               1092      ; Write Decimal Character converted from Integer
152C-               1093      ;【引数】D:Integer
152C-               1094      ;【使用】A, B, X
152C-               1095      ;【返値】なし
152C-               1096      ; -----------------------------------------------------------------------
152C-               1097      write_integer:
00A9-               1098      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00AA-               1099      .Counter        .eq     UR0L    ; 桁カウンター
152C-2A 0C          1100 ( 3)         bpl     :plus           ; 符号判定
152E-37             1101 ( 4)         pshb                    ; 負数なら'-'を出力する
152F-C6 2D          1102 ( 2)         ldab    #'-'
1531-BD FF AC       1103 ( 6)         jsr     write_char
1534-33             1104 ( 3)         pulb
1535-43             1105 ( 1)         coma                    ; 絶対値にする（2の補数にする）
1536-53             1106 ( 1)         comb
1537-C3 00 01       1107 ( 3)         addd    #1
153A-7F 00 A9       1108 ( 5) .plus   clr     <:ZeroSuppress
153D-CE 15 6D       1109 ( 3)         ldx     #:CONST
1540-7F 00 AA       1110 ( 5) .loop   clr     <:Counter
1543-A3 00          1111 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
1545-25 05          1112 ( 3)         bcs     :write
1547-7C 00 AA       1113 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
154A-20 F7          1114 ( 3)         bra     :digit
154C-               1115
154C-E3 00          1116 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
154E-37             1117 ( 4)         pshb
154F-D6 AA          1118 ( 3)         ldab    <:Counter
1551-27 03          1119 ( 3)         beq     :1              ; この桁はゼロか？
1553-7C 00 A9       1120 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
1556-7D 00 A9       1121 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1559-27 05          1122 ( 3)         beq     :2              ; No. この桁は表示しない
155B-CB 30          1123 ( 2)         addb    #$30            ; Yes. この桁を表示する
155D-BD FF AC       1124 ( 6)         jsr     write_char
1560-33             1125 ( 3) .2      pulb
1561-08             1126 ( 1)         inx                     ; 次の引く数へ
1562-08             1127 ( 1)         inx
1563-8C 15 75       1128 ( 3)         cpx     #:CONST+8
1566-26 D8          1129 ( 3)         bne     :loop
1568-CB 30          1130 ( 2)         addb    #$30            ; 一の桁の数値を表示
156A-7E FF AC       1131 ( 3)         jmp     write_char
156D-               1132      ; Dから引いていく数
156D-27 10          1133      .CONST  .dw     $2710           ; 10,000
156F-03 E8          1134              .dw     $03e8           ; 1,000
1571-00 64          1135              .dw     $0064           ; 100
1573-00 0A          1136              .dw     $000a           ; 10
1575-               1137
1575-               1138
1575-               1139      ; -----------------------------------------------------------------------
1575-               1140      ; テキストバッファの英文字が変数か判定する
1575-               1141      ; Is a character retrieved from a text buffer a variable?
1575-               1142      ;【引数】X:バッファアドレス
1575-               1143      ;【使用】A, B, X
1575-               1144      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
1575-               1145      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
1575-               1146      ; -----------------------------------------------------------------------
1575-               1147      is_variable:
1575-E6 00          1148 ( 4)         ldab    0,x
1577-BD FF BE       1149 ( 6)         jsr     is_alphabetic_char
157A-24 0D          1150 ( 3)         bcc     :end
157C-17             1151 ( 1)         tba                             ; 1文字目のアスキーコードを退避
157D-E6 01          1152 ( 4)         ldab    1,x                     ; 2文字目を取得
157F-BD FF BE       1153 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
1582-16             1154 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
1583-24 02          1155 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
1585-0C             1156 ( 1)         clc                             ; Yes. 変数ではない。C=0
1586-39             1157 ( 5)         rts
1587-08             1158 ( 1) .var    inx                             ; ポインタを進める
1588-0D             1159 ( 1)         sec                             ; C=1
1589-39             1160 ( 5) .end    rts
158A-               1161
158A-               1162
158A-               1163      ; -----------------------------------------------------------------------
158A-               1164      ; 空白を読み飛ばす
158A-               1165      ; Skip Space
158A-               1166      ;【引数】X:実行位置アドレス
158A-               1167      ;【使用】B, X
158A-               1168      ;【返値】B:アスキーコード（$00の時Z=1）
158A-               1169      ;        X:実行位置アドレス
158A-               1170      ; -----------------------------------------------------------------------
158A-               1171      skip_space:
158A-E6 00          1172 ( 4)         ldab    0,x
158C-27 07          1173 ( 3)         beq     :end
158E-C1 20          1174 ( 2)         cmpb    #SPACE
1590-22 03          1175 ( 3)         bhi     :end
1592-08             1176 ( 1)         inx
1593-20 F5          1177 ( 3)         bra     skip_space
1595-39             1178 ( 5) .end    rts
1596-               1179
1596-               1180
1596-               1181      ; -----------------------------------------------------------------------
1596-               1182      ; 引用符付きの文字列を出力する
1596-               1183      ; Write Quoted Stirng
1596-               1184      ;【引数】B:アスキーコード X:実行位置アドレス
1596-               1185      ;【使用】A, B, X
1596-               1186      ;【返値】真(C=1) / X:次の実行位置アドレス
1596-               1187      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
1596-               1188      ; -----------------------------------------------------------------------
1596-               1189      write_quoted_str:
1596-C1 22          1190 ( 2)         cmpb    #$22            ; 一重引用符か？
1598-27 04          1191 ( 3)         beq     :1
159A-C1 27          1192 ( 2)         cmpb    #$27            ; 二重引用符か？
159C-26 19          1193 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
159E-17             1194 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
159F-               1195            ; // 終端の引用符をチェック
159F-3C             1196 ( 5)         pshx
15A0-08             1197 ( 1) .check  inx
15A1-E6 00          1198 ( 4)         ldab    0,x
15A3-27 14          1199 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
15A5-11             1200 ( 1)         cba
15A6-26 F8          1201 ( 3)         bne     :check
15A8-38             1202 ( 4)         pulx
15A9-               1203            ; // 文字列の出力
15A9-08             1204 ( 1) .loop   inx
15AA-E6 00          1205 ( 4)         ldab    0,x
15AC-11             1206 ( 1)         cba                     ; 保存した引用符との比較
15AD-27 05          1207 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
15AF-BD FF AC       1208 ( 6)         jsr     write_char
15B2-20 F5          1209 ( 3)         bra     :loop
15B4-08             1210 ( 1) .true   inx
15B5-0D             1211 ( 1)         sec
15B6-39             1212 ( 5)         rts
15B7-0C             1213 ( 1) .false  clc
15B8-39             1214 ( 5)         rts
15B9-86 0A          1215 ( 2) .err10  ldaa    #10             ; "Print statement error"
15BB-7E 18 F6       1216 ( 3)         jmp     write_err_msg
15BE-               1217
15BE-               1218
15BE-               1219      ; -----------------------------------------------------------------------
15BE-               1220      ; タブを出力する
15BE-               1221      ; Write tabs
15BE-               1222      ;【引数】なし
15BE-               1223      ;【使用】B
15BE-               1224      ;【返値】なし
15BE-               1225      ; -----------------------------------------------------------------------
15BE-               1226      write_tab:
15BE-BD FF B5       1227 ( 6) .top    jsr     write_space
15C1-7B 07 39       1228 ( 4)         tim     #7,<TabCount
15C4-26 F8          1229 ( 3)         bne     :top
15C6-39             1230 ( 5)         rts
15C7-               1231
15C7-               1232
15C7-               1233      ; -----------------------------------------------------------------------
15C7-               1234      ; 配列変数のアドレスを取得する
15C7-               1235      ; Set the address of the array variable
15C7-               1236      ;【引数】D:添字
15C7-               1237      ;【使用】A, B
15C7-               1238      ;【返値】D:配列変数のアドレス
15C7-               1239      ; -----------------------------------------------------------------------
15C7-               1240      set_array_addr:
15C7-18             1241 ( 2)         xgdx
15C8-9C A5          1242 ( 4)         cpx     <MaxSubscript   ; 取得した添字 > 添字の最大値？
15CA-22 09          1243 ( 3)         bhi     :err22          ; Yes. エラー処理
15CC-18             1244 ( 2)         xgdx
15CD-05             1245 ( 1)         asld                    ; 添字を2倍にする
15CE-D3 A3          1246 ( 4)         addd    <ArrayAddr
15D0-39             1247 ( 5)         rts
15D1-4F             1248 ( 1) .err00  clra                    ; "Syntax error"
15D2-7E 18 F6       1249 ( 3)         jmp     write_err_msg
15D5-86 16          1250 ( 2) .err22  ldaa    #22             ; "Subscript is out of range"
15D7-7E 18 F6       1251 ( 3)         jmp     write_err_msg
15DA-               1252
15DA-               1253
15DA-               1254      ; -----------------------------------------------------------------------
15DA-               1255      ; 式を評価して変数に値を代入する
15DA-               1256      ; Evaluate an expression and assign a value to a variable
15DA-               1257      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
15DA-               1258      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
15DA-               1259      ;【返値】D:Integer X:次の実行位置アドレス
15DA-               1260      ; -----------------------------------------------------------------------
15DA-               1261      assign_to_var:
15DA-BD 15 8A       1262 ( 6)         jsr     skip_space
15DD-BD 12 03       1263 ( 6)         jsr     eval_expression
15E0-24 07          1264 ( 3)         bcc     :err04
15E2-3C             1265 ( 5)         pshx                    ; 実行位置アドレスを退避
15E3-DE 8B          1266 ( 4)         ldx     <VariableAddr
15E5-ED 00          1267 ( 5)         std     0,x             ; 変数に結果を保存
15E7-38             1268 ( 4)         pulx                    ; 実行位置アドレスを復帰
15E8-39             1269 ( 5)         rts
15E9-86 04          1270 ( 2) .err04  ldaa    #4              ; "Illegal expression"
15EB-7E 18 F6       1271 ( 3)         jmp     write_err_msg
15EE-               1272
15EE-               1273
15EE-               1274      ; -----------------------------------------------------------------------
15EE-               1275      ; 同じ行番号を検索する
15EE-               1276      ; Scan equal line number
15EE-               1277      ;【引数】LineNumber:検索対象の行番号 X:検索を開始する行頭アドレス
15EE-               1278      ;【使用】A, B, X
15EE-               1279      ;【返値】真(C=1) / D:行番号 X:その行の開始アドレス
15EE-               1280      ;        偽(C=0) / D:次に大きな行番号 X:次に大きな行の開始アドレス
15EE-               1281      ;                  またはD:$0000 X:プログラム終了アドレス
15EE-               1282      ; -----------------------------------------------------------------------
15EE-               1283      scan_line_num:
15EE-EC 00          1284 ( 5) .loop   ldd     0,x             ; D:行番号
15F0-27 0F          1285 ( 3)         beq     :false          ; プログラム終端まで来たので偽
15F2-18             1286 ( 2)         xgdx
15F3-9C 96          1287 ( 4)         cpx     <LineNumber
15F5-18             1288 ( 2)         xgdx
15F6-27 07          1289 ( 3)         beq     :true           ; 同一の行番号が見つかったので真
15F8-2E 07          1290 ( 3)         bgt     :false          ; 対象の行番号より大きくなったので偽
15FA-E6 02          1291 ( 4)         ldab    2,x
15FC-3A             1292 ( 1)         abx
15FD-20 EF          1293 ( 3)         bra     :loop
15FF-0D             1294 ( 1) .true   sec
1600-39             1295 ( 5)         rts
1601-0C             1296 ( 1) .false  clc
1602-39             1297 ( 5)         rts
1603-               1298
1603-               1299
1603-               1300      ; -----------------------------------------------------------------------
1603-               1301      ; runコマンドを実行する
1603-               1302      ; Execute 'run' command
1603-               1303      ;【引数】なし
1603-               1304      ;【使用】A, B, X
1603-               1305      ;【返値】なし
1603-               1306      ; -----------------------------------------------------------------------
1603-               1307      exe_run:
1603-               1308            ; // 乱数のSeed値の設定
1603-DC 09          1309 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
1605-27 FC          1310 ( 3)         beq     :seed           ; Seedはゼロ以外
1607-DD A7          1311 ( 4)         std     <RndNumber
1609-               1312            ; // 変数領域の初期化
1609-CE 02 C2       1313 ( 3)         ldx     #VARIABLE
160C-4F             1314 ( 1)         clra
160D-5F             1315 ( 1)         clrb
160E-ED 00          1316 ( 5) .1      std     0,x
1610-08             1317 ( 1)         inx
1611-08             1318 ( 1)         inx
1612-8C 02 F6       1319 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
1615-26 F7          1320 ( 3)         bne     :1
1617-7F 00 9C       1321 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
161A-CE 04 00       1322 ( 3)         ldx     #USER_AREA_TOP
161D-DF 9D          1323 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
161F-EC 00          1324 ( 5)         ldd     0,x
1621-27 08          1325 ( 3)         beq     :end            ; 行番号が$0000なら終了
1623-08             1326 ( 1)         inx
1624-08             1327 ( 1)         inx
1625-08             1328 ( 1)         inx
1626-BD 11 9D       1329 ( 6)         jsr     exe_line        ; 一行実行
1629-20 F2          1330 ( 3)         bra     :loop
162B-7E 10 37       1331 ( 3) .end    jmp     warm_start
162E-               1332
162E-               1333
162E-               1334      ; -----------------------------------------------------------------------
162E-               1335      ; listコマンドを実行する
162E-               1336      ; Execute 'list' command
162E-               1337      ;【引数】なし
162E-               1338      ;【使用】A, B, X
162E-               1339      ;【返値】なし
162E-               1340      ; -----------------------------------------------------------------------
162E-               1341      exe_list:
162E-CE 04 00       1342 ( 3)         ldx     #USER_AREA_TOP
1631-               1343            ; // 行番号出力
1631-EC 00          1344 ( 5) .loop   ldd     0,x
1633-27 11          1345 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
1635-3C             1346 ( 5)         pshx
1636-BD 15 2C       1347 ( 6)         jsr     write_integer
1639-38             1348 ( 4)         pulx
163A-               1349            ; // 本文出力
163A-08             1350 ( 1)         inx                     ; 本文までスキップ
163B-08             1351 ( 1)         inx
163C-08             1352 ( 1)         inx
163D-BD FF AF       1353 ( 6)         jsr     write_line
1640-BD FF B2       1354 ( 6)         jsr     write_crlf
1643-08             1355 ( 1)         inx                     ; 次の行番号へ
1644-20 EB          1356 ( 3)         bra     :loop
1646-7E 10 41       1357 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1649-               1358
1649-               1359
1649-               1360      ; -----------------------------------------------------------------------
1649-               1361      ; Print文を実行する
1649-               1362      ; Execute 'print' statement
1649-               1363      ;【引数】X:実行位置アドレス
1649-               1364      ;【使用】B, X（下位ルーチンでA）
1649-               1365      ;【返値】なし
1649-               1366      ; -----------------------------------------------------------------------
1649-               1367      exe_print:
1649-72 01 8F       1368 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
164C-BD 15 8A       1369 ( 6) .loop   jsr     skip_space
164F-27 37          1370 ( 3)         beq     :finish         ; 終端文字なら改行して終了
1651-BD 15 96       1371 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1654-25 1B          1372 ( 3)         bcs     :nlon
1656-BD 12 03       1373 ( 6)         jsr     eval_expression
1659-25 11          1374 ( 3)         bcs     :int
165B-               1375            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
165B-               1376            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
165B-C1 3B          1377 ( 2) .check  cmpb    #';'
165D-27 23          1378 ( 3)         beq     :nloff
165F-C1 2C          1379 ( 2)         cmpb    #','
1661-27 1C          1380 ( 3)         beq     :tab
1663-C1 3A          1381 ( 2)         cmpb    #':'
1665-27 21          1382 ( 3)         beq     :finish
1667-86 04          1383 ( 2)         ldaa    #4              ; "Illegal expression"
1669-7E 18 F6       1384 ( 3)         jmp     write_err_msg
166C-3C             1385 ( 5) .int    pshx                    ; 実行位置アドレスを退避
166D-BD 15 2C       1386 ( 6)         jsr     write_integer   ; 評価した式を出力
1670-38             1387 ( 4)         pulx                    ; 実行位置アドレスを復帰
1671-72 01 8F       1388 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1674-BD 15 8A       1389 ( 6)         jsr     skip_space
1677-C1 3B          1390 ( 2)         cmpb    #';'
1679-27 07          1391 ( 3)         beq     :nloff
167B-C1 2C          1392 ( 2)         cmpb    #','
167D-26 09          1393 ( 3)         bne     :finish
167F-BD 15 BE       1394 ( 6) .tab    jsr     write_tab       ; タブ出力
1682-7F 00 8F       1395 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
1685-08             1396 ( 1)         inx                     ; 次の文字へ
1686-20 C4          1397 ( 3)         bra     :loop
1688-7D 00 8F       1398 ( 4) .finish tst     <NewLineFlag
168B-27 03          1399 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
168D-BD FF B2       1400 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
1690-7E 11 7D       1401 ( 3) .end    jmp     is_multi
1693-               1402
1693-               1403
1693-               1404      ; -----------------------------------------------------------------------
1693-               1405      ; input文を実行する
1693-               1406      ; Execute 'input' statement
1693-               1407      ;【引数】X:実行位置アドレス
1693-               1408      ;【使用】B, X（下位ルーチンでA）
1693-               1409      ;【返値】なし
1693-               1410      ; -----------------------------------------------------------------------
1693-               1411      exe_input:
1693-BD 15 8A       1412 ( 6)         jsr     skip_space
1696-27 38          1413 ( 3)         beq     :err00          ; 終端文字ならエラー
1698-C1 3A          1414 ( 2)         cmpb    #':'            ; ":"ならエラー
169A-27 34          1415 ( 3)         beq     :err00
169C-BD 15 96       1416 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
169F-24 0A          1417 ( 3)         bcc     :1
16A1-E6 00          1418 ( 4)         ldab    0,x
16A3-C1 3B          1419 ( 2)         cmpb    #';'
16A5-26 29          1420 ( 3)         bne     :err00
16A7-08             1421 ( 1)         inx
16A8-BD 15 8A       1422 ( 6)         jsr     skip_space
16AB-BD 15 75       1423 ( 6) .1      jsr     is_variable
16AE-24 20          1424 ( 3)         bcc     :err00
16B0-86 02          1425 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
16B2-58             1426 ( 1)         aslb                    ; B = 変数領域の下位バイト
16B3-DD 8B          1427 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
16B5-               1428            ; // 変数の後に余計な文字がないか確認
16B5-               1429            ; // 例えば "input a+b" など
16B5-DF 8D          1430 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
16B7-BD 15 8A       1431 ( 6)         jsr     skip_space
16BA-27 06          1432 ( 3)         beq     :read           ; 終端文字なら入力へ
16BC-C1 3A          1433 ( 2)         cmpb    #':'            ; ":"なら入力へ
16BE-26 10          1434 ( 3)         bne     :err00          ; それ以外の文字ならエラー
16C0-DE 8D          1435 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16C2-BD FF A9       1436 ( 6) .read   jsr     read_line
16C5-CE 01 40       1437 ( 3)         ldx     #TEXT_BFFR
16C8-BD 15 DA       1438 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
16CB-DE 8D          1439 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16CD-7E 11 7D       1440 ( 3)         jmp     is_multi
16D0-4F             1441 ( 1) .err00  clra                    ; "Syntax error"
16D1-7E 18 F6       1442 ( 3)         jmp     write_err_msg
16D4-               1443
16D4-               1444
16D4-               1445      ; -----------------------------------------------------------------------
16D4-               1446      ; if文を実行する
16D4-               1447      ; Execute 'if' statement
16D4-               1448      ;【引数】X:実行位置アドレス
16D4-               1449      ;【使用】B, X
16D4-               1450      ;【返値】なし
16D4-               1451      ; -----------------------------------------------------------------------
16D4-BD 15 8A       1452 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
16D7-27 12          1453 ( 3)         beq     :err00          ; 終端文字ならエラー
16D9-C1 3A          1454 ( 2)         cmpb    #':'            ; ":"ならエラー
16DB-27 0E          1455 ( 3)         beq     :err00
16DD-BD 12 03       1456 ( 6)         jsr     eval_expression ; 式評価
16E0-24 0D          1457 ( 3)         bcc     :err04
16E2-5D             1458 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
16E3-27 03          1459 ( 3)         beq     :end
16E5-7E 11 9D       1460 ( 3)         jmp     exe_line        ; True
16E8-7E 11 8D       1461 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
16EB-4F             1462 ( 1) .err00  clra                    ; "Syntax error"
16EC-7E 18 F6       1463 ( 3)         jmp     write_err_msg
16EF-86 04          1464 ( 2) .err04  ldaa    #4              ; "Illegal expression"
16F1-7E 18 F6       1465 ( 3)         jmp     write_err_msg
16F4-               1466
16F4-               1467
16F4-               1468      ; -----------------------------------------------------------------------
16F4-               1469      ; gosub文を実行する
16F4-               1470      ; Execute 'gosub' statement
16F4-               1471      ;【引数】X:実行位置アドレス
16F4-               1472      ;【使用】A, B, X
16F4-               1473      ;【返値】なし
16F4-               1474      ; -----------------------------------------------------------------------
16F4-               1475      exe_gosub:
16F4-72 01 A0       1476 ( 6)         oim     #1,<ToSubFlag   ; 分岐モードを1 = gosubにする
16F7-               1477              ; そのままexe_gotoに続く
16F7-               1478
16F7-               1479
16F7-               1480      ; -----------------------------------------------------------------------
16F7-               1481      ; goto文を実行する
16F7-               1482      ; Execute 'goto' statement
16F7-               1483      ;【引数】X:実行位置アドレス
16F7-               1484      ;【使用】A, B, X
16F7-               1485      ;【返値】なし
16F7-               1486      ; -----------------------------------------------------------------------
16F7-               1487      exe_goto:
16F7-BD 15 8A       1488 ( 6)         jsr     skip_space      ; 空白を読み飛ばし
16FA-27 3F          1489 ( 3)         beq     :err00          ; 終端文字"Syntax error"
16FC-BD 12 03       1490 ( 6)         jsr     eval_expression ; 式評価
16FF-24 3E          1491 ( 3)         bcc     :err04          ; "Illegal expression"
1701-2B 41          1492 ( 3)         bmi     :err12          ; "Invalid line number"
1703-DD 96          1493 ( 4)         std     <LineNumber     ; 飛び先になる行番号を一時保存
1705-7D 00 A0       1494 ( 4)         tst     ToSubFlag
1708-27 17          1495 ( 3)         beq     :to             ; 分岐モードが0=gotoなら:toへ
170A-18             1496 ( 2)         xgdx                    ; D = ExePointer
170B-DE A1          1497 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
170D-8C 02 28       1498 ( 3)         cpx     #SSTACK         ; 既にスタック最上位か？
1710-27 3C          1499 ( 3)         beq     :err18          ; Yes. "Subroutine stack overflow"
1712-09             1500 ( 1)         dex
1713-09             1501 ( 1)         dex
1714-ED 00          1502 ( 5)         std     0,x             ; ExePointerをスタックに積む
1716-DC 9D          1503 ( 4)         ldd     <ExeLineAddr
1718-09             1504 ( 1)         dex
1719-09             1505 ( 1)         dex
171A-ED 00          1506 ( 5)         std     0,x             ; ExeLineAddrをスタックに積む
171C-DF A1          1507 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
171E-7F 00 A0       1508 ( 5)         clr     ToSubFlag       ; 分岐モードを0 = gotoに戻す
1721-DE 9D          1509 ( 4) .to     ldx     <ExeLineAddr    ; X <- 実行中の行の先頭アドレス
1723-EC 00          1510 ( 5)         ldd     0,x             ; 今実行している行の行番号を取得
1725-18             1511 ( 2)         xgdx
1726-9C 96          1512 ( 4)         cpx     <LineNumber     ; 現在の行番号と飛び先の行番号を比較
1728-18             1513 ( 2)         xgdx
1729-25 03          1514 ( 3)         bcs     :1              ; 現在の行番号 > 飛び先の行番号 = ここから検索
172B-CE 04 00       1515 ( 3)         ldx     #USER_AREA_TOP  ; 現在の行番号 < 飛び先の行番号 = 先頭から検索
172E-BD 15 EE       1516 ( 6) .1      jsr     scan_line_num   ; 同じ行番号を探す
1731-24 16          1517 ( 3)         bcc     :err16          ; "Undefined line number"
1733-DF 9D          1518 ( 4)         stx     <ExeLineAddr    ; 飛び先の先頭アドレスを保存
1735-08             1519 ( 1)         inx
1736-08             1520 ( 1)         inx
1737-08             1521 ( 1)         inx
1738-7E 11 9D       1522 ( 3)         jmp     exe_line
173B-               1523
173B-4F             1524 ( 1) .err00  clra                    ; "Syntax error"
173C-7E 18 F6       1525 ( 3)         jmp     write_err_msg
173F-86 04          1526 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1741-7E 18 F6       1527 ( 3)         jmp     write_err_msg
1744-86 0C          1528 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1746-7E 18 F6       1529 ( 3)         jmp     write_err_msg
1749-86 10          1530 ( 2) .err16  ldaa    #16             ; "Undefined line number"
174B-7E 18 F6       1531 ( 3)         jmp     write_err_msg
174E-86 12          1532 ( 2) .err18  ldaa    #18             ; "Subroutine stack overflow"
1750-7E 18 F6       1533 ( 3)         jmp     write_err_msg
1753-               1534
1753-               1535
1753-               1536      ; -----------------------------------------------------------------------
1753-               1537      ; return文を実行する
1753-               1538      ; Execute 'return' statement
1753-               1539      ;【引数】X:実行位置アドレス
1753-               1540      ;【使用】A, B, X
1753-               1541      ;【返値】なし
1753-               1542      ; -----------------------------------------------------------------------
1753-               1543      exe_return:
1753-DE A1          1544 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
1755-8C 02 50       1545 ( 3)         cpx     #SSTACK_BTM+1   ; 既にスタックの底か？
1758-27 10          1546 ( 3)         beq     :err20          ; Yes. "Return without gosub"
175A-EC 00          1547 ( 5)         ldd     0,x
175C-DD 9D          1548 ( 4)         std     <ExeLineAddr    ; ExeLineAddrをスタックから復帰
175E-08             1549 ( 1)         inx
175F-08             1550 ( 1)         inx
1760-EC 00          1551 ( 5)         ldd     0,x             ; D = ExePointer
1762-08             1552 ( 1)         inx
1763-08             1553 ( 1)         inx
1764-DF A1          1554 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
1766-18             1555 ( 2)         xgdx                    ; X = ExePointer
1767-7E 11 7D       1556 ( 3)         jmp     is_multi
176A-               1557
176A-86 14          1558 ( 2) .err20  ldaa    #20             ; "Return without gosub"
176C-7E 18 F6       1559 ( 3)         jmp     write_err_msg
176F-               1560
176F-               1561
176F-               1562      ; -----------------------------------------------------------------------
176F-               1563      ; trunc文を実行する
176F-               1564      ; Execute 'trunc' statement
176F-               1565      ;【引数】X:実行位置アドレス
176F-               1566      ;【使用】B, X
176F-               1567      ;【返値】なし
176F-               1568      ; -----------------------------------------------------------------------
176F-               1569      exe_trunc:
176F-7F 00 9F       1570 ( 5)         clr     <ModuloMode     ; tranc = 0 にする
1772-7E 11 7D       1571 ( 3)         jmp     is_multi
1775-               1572
1775-               1573
1775-               1574      ; -----------------------------------------------------------------------
1775-               1575      ; floor文を実行する
1775-               1576      ; Execute 'trunc' statement
1775-               1577      ;【引数】X:実行位置アドレス
1775-               1578      ;【使用】B, X
1775-               1579      ;【返値】なし
1775-               1580      ; -----------------------------------------------------------------------
1775-               1581      exe_floor:
1775-72 01 9F       1582 ( 6)         oim     #1,<ModuloMode  ; floor = 1以上 にする
1778-7E 11 7D       1583 ( 3)         jmp     is_multi
177B-               1584
177B-               1585
177B-               1586      ; -----------------------------------------------------------------------
177B-               1587      ; rnd関数を実行する
177B-               1588      ; Execute 'rnd' function
177B-               1589      ;【引数】X:実行位置アドレス
177B-               1590      ;【使用】A, B, X
177B-               1591      ;【返値】D:乱数値 X:次の実行位置アドレス
177B-               1592      ; -----------------------------------------------------------------------
177B-               1593      exe_rnd:
177B-               1594            ; // xorshiftで乱数生成
177B-D6 A7          1595 ( 3)         ldab    <RndNumber
177D-54             1596 ( 1)         lsrb
177E-D6 A8          1597 ( 3)         ldab    <RndNumber+1
1780-56             1598 ( 1)         rorb
1781-D8 A7          1599 ( 3)         eorb    <RndNumber
1783-D7 A7          1600 ( 3)         stab    <RndNumber
1785-56             1601 ( 1)         rorb
1786-D8 A8          1602 ( 3)         eorb    <RndNumber+1
1788-D7 A8          1603 ( 3)         stab    <RndNumber+1
178A-17             1604 ( 1)         tba
178B-98 A7          1605 ( 3)         eora    <RndNumber
178D-97 A7          1606 ( 3)         staa    <RndNumber
178F-84 7F          1607 ( 2)         anda    #$7f            ; 生成される乱数は0〜32,767となる
1791-BD 13 16       1608 ( 6)         jsr     expr_1st:push   ; 乱数を計算スタックにプッシュ
1794-BD 12 19       1609 ( 6)         jsr     expr_4th        ; 引数を取得する
1797-               1610            ; // ')'の確認
1797-C1 29          1611 ( 2)         cmpb    #')'
1799-26 1D          1612 ( 3)         bne     :err00
179B-3C             1613 ( 5)         pshx                    ; 実行位置アドレスを退避
179C-               1614            ; // 計算スタックの引数を+1する
179C-DE 82          1615 ( 4)         ldx     <CStackPtr
179E-EC 00          1616 ( 5)         ldd     0,x
17A0-2F 1A          1617 ( 3)         ble     :err02          ; 引数が正の実数でなければ"Out of range"
17A2-C3 00 01       1618 ( 3)         addd    #1
17A5-ED 00          1619 ( 5)         std     0,x
17A7-DF 82          1620 ( 4)         stx     <CStackPtr
17A9-               1621            ; // rnd(32768)の場合、生成された乱数を32768+1つまり-32768で割らないといけない
17A9-               1622            ; // 結果を正の数とするために一時的にtruncモードにする
17A9-D6 9F          1623 ( 3)         ldab    <ModuloMode     ; 剰余演算フラグを保存
17AB-37             1624 ( 4)         pshb
17AC-7F 00 9F       1625 ( 5)         clr     ModuloMode      ; 剰余演算フラグをtrancにする
17AF-BD 13 86       1626 ( 6)         jsr     CS_mod          ; 乱数 / (引数 + 1)
17B2-33             1627 ( 3)         pulb                    ; 剰余演算フラグを復帰
17B3-D7 9F          1628 ( 3)         stab    <ModuloMode
17B5-38             1629 ( 4)         pulx                    ; 実行位置アドレスを復帰
17B6-08             1630 ( 1)         inx                     ; 次の実行位置アドレスに
17B7-39             1631 ( 5)         rts                     ; expr_2ndの2行目に戻る
17B8-4F             1632 ( 1) .err00  clra                    ; "Syntax error"
17B9-7E 18 F6       1633 ( 3)         jmp     write_err_msg
17BC-86 02          1634 ( 2) .err02  ldaa    #2              ; "Out of range"
17BE-7E 18 F6       1635 ( 3)         jmp     write_err_msg
17C1-               1636
17C1-               1637
17C1-               1638      ; -----------------------------------------------------------------------
17C1-               1639      ; ブロック転送
17C1-               1640      ; Move memory
17C1-               1641      ;【引数】Source:転送元アドレス
17C1-               1642      ;        Destination:転送先アドレス
17C1-               1643      ;        Bytes:転送バイト数
17C1-               1644      ;【使用】A, B, X, UR0
17C1-               1645      ;【返値】なし
17C1-               1646      ; -----------------------------------------------------------------------
17C1-               1647      mem_move:
17C1-DC 94          1648 ( 4)         ldd     <Bytes
17C3-27 0A          1649 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
17C5-DC 90          1650 ( 4)         ldd     <Source
17C7-93 92          1651 ( 4)         subd    <Destination    ; Source - Destination
17C9-27 04          1652 ( 3)         beq     :end            ; 転送元と転送先が同じなら即終了
17CB-24 03          1653 ( 3)         bcc     LDIR            ; Source > Destination
17CD-20 31          1654 ( 3)         bra     LDDR            ; Source < Destination
17CF-39             1655 ( 5) .end    rts
17D0-               1656
17D0-               1657      ; -----------------------------------------------------------------------
17D0-               1658      ; 前方から転送（LDIR）
17D0-               1659      ; Load, Increment and Repeat
17D0-               1660      ;【引数】Source:転送元アドレス
17D0-               1661      ;        Destination:転送先アドレス
17D0-               1662      ;        Bytes:転送バイト数
17D0-               1663      ;【使用】A, B, X, UR0
17D0-               1664      ;【返値】なし
17D0-               1665      ; -----------------------------------------------------------------------
17D0-               1666      LDIR:
00A9-               1667      .Offset .eq     UR0
17D0-               1668             ; // オフセットの計算。既にDレジスタに入っている
17D0-DD A9          1669 ( 4)        std     <:Offset        ; Offset = Source - Destination
17D2-               1670            ; // 終了判定用のアドレスを計算
17D2-DC 90          1671 ( 4)         ldd     <Source         ; 転送終了アドレス = Source - Bytes
17D4-D3 94          1672 ( 4)         addd    <Bytes
17D6-DD 92          1673 ( 4)         std     <Destination    ; 転送終了アドレスをDestinationに代入
17D8-               1674            ; // 転送開始
17D8-DE 90          1675 ( 4)         ldx     <Source         ; 転送開始アドレスをXに代入
17DA-               1676            ; // 転送するバイト数が奇数か偶数か判断。
17DA-               1677            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
17DA-DC 94          1678 ( 4)         ldd     <Bytes
17DC-04             1679 ( 1)         lsrd                    ; 転送バイト数 / 2, 奇数ならC=1
17DD-24 0E          1680 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
17DF-               1681            ; // Byte転送
17DF-A6 00          1682 ( 4)         ldaa    0,x             ; A <- [Source]
17E1-18             1683 ( 2)         xgdx                    ; D = address, X = data
17E2-93 A9          1684 ( 4)         subd    <:Offset        ; Source - Offset = Destination
17E4-18             1685 ( 2)         xgdx                    ; D = data, X = address
17E5-A7 00          1686 ( 4)         staa    0,x             ; [Destination] <- A
17E7-18             1687 ( 2)         xgdx                    ; D = address, X = data
17E8-D3 A9          1688 ( 4)         addd    <:Offset        ; Destination + Offset = Source
17EA-18             1689 ( 2)         xgdx                    ; D = data, X = address
17EB-20 0D          1690 ( 3)         bra     :odd            ; 飛び先でinx
17ED-               1691            ; // Word転送
17ED-EC 00          1692 ( 5) .loop   ldd     0,x
17EF-18             1693 ( 2)         xgdx
17F0-93 A9          1694 ( 4)         subd    <:Offset
17F2-18             1695 ( 2)         xgdx
17F3-ED 00          1696 ( 5)         std     0,x
17F5-18             1697 ( 2)         xgdx
17F6-D3 A9          1698 ( 4)         addd    <:Offset
17F8-18             1699 ( 2)         xgdx
17F9-08             1700 ( 1)         inx
17FA-08             1701 ( 1) .odd    inx
17FB-9C 92          1702 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
17FD-26 EE          1703 ( 3)         bne     :loop
17FF-39             1704 ( 5)         rts
1800-               1705
1800-               1706      ; -----------------------------------------------------------------------
1800-               1707      ; 後方から転送（LDDR）
1800-               1708      ; Load, Decrement and Repeat
1800-               1709      ;【引数】Source:転送元アドレス
1800-               1710      ;        Destination:転送先アドレス
1800-               1711      ;        Bytes:転送バイト数
1800-               1712      ;【使用】A, B, X, UR0
1800-               1713      ;【返値】なし
1800-               1714      ; -----------------------------------------------------------------------
1800-               1715      LDDR:
00A9-               1716      .Offset .eq     UR0
1800-               1717            ; // オフセットの計算
1800-DC 92          1718 ( 4)         ldd     <Destination
1802-93 90          1719 ( 4)         subd    <Source
1804-DD A9          1720 ( 4)         std     <:Offset         ; Offset = Destination - Source
1806-               1721            ; // 転送終了アドレスは既にDestinationに代入済み
1806-               1722            ; // 転送開始アドレスの計算。一番後ろから
1806-DC 90          1723 ( 4)         ldd     <Source         ; 転送開始アドレス = Source + Bytes
1808-D3 94          1724 ( 4)         addd    <Bytes
180A-18             1725 ( 2)         xgdx                    ; X = 転送開始アドレス
180B-               1726            ; // 転送するバイト数が奇数か偶数か判断。
180B-               1727            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
180B-DC 94          1728 ( 4)         ldd     <Bytes
180D-04             1729 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
180E-24 0F          1730 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
1810-               1731            ; // Byte転送
1810-09             1732 ( 1)         dex
1811-A6 00          1733 ( 4)         ldaa    0,x             ; A <- [Source]
1813-18             1734 ( 2)         xgdx                    ; D = address, X = data
1814-D3 A9          1735 ( 4)         addd    <:Offset        ; Source + Offset = Destination
1816-18             1736 ( 2)         xgdx                    ; D = data, X = address
1817-A7 00          1737 ( 4)         staa    0,x             ; [Destination] <- A
1819-18             1738 ( 2)         xgdx                    ; D = address, X = data
181A-93 A9          1739 ( 4)         subd    <:Offset        ; Destination - Offset = Source
181C-18             1740 ( 2)         xgdx                    ; D = data, X = address
181D-20 0E          1741 ( 3)         bra     :odd
181F-               1742            ; // Word転送
181F-09             1743 ( 1) .loop   dex
1820-09             1744 ( 1)         dex
1821-EC 00          1745 ( 5)         ldd     0,x
1823-18             1746 ( 2)         xgdx
1824-D3 A9          1747 ( 4)         addd    <:Offset
1826-18             1748 ( 2)         xgdx
1827-ED 00          1749 ( 5)         std     0,x
1829-18             1750 ( 2)         xgdx
182A-93 A9          1751 ( 4)         subd    <:Offset
182C-18             1752 ( 2)         xgdx
182D-9C 90          1753 ( 4) .odd    cpx     <Source         ; 転送終了アドレスと現在のアドレスを比較
182F-26 EE          1754 ( 3)         bne     :loop
1831-39             1755 ( 5)         rts
1832-               1756
1832-               1757
1832-               1758      ; -----------------------------------------------------------------------
1832-               1759      ; テーブル検索
1832-               1760      ; Search the keyword table
1832-               1761      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
1832-               1762      ;【使用】A, B, X
1832-               1763      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
1832-               1764      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
1832-               1765      ; -----------------------------------------------------------------------
1832-               1766      search_table:
1832-EC 05          1767 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
1834-91 B1          1768 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1836-26 2F          1769 ( 3)         bne     :false
1838-D1 B2          1770 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
183A-26 2B          1771 ( 3)         bne     :false
183C-EC 07          1772 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
183E-4D             1773 ( 1)         tsta                    ; $00（終端記号）か？
183F-27 1B          1774 ( 3)         beq     :true
1841-91 B3          1775 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
1843-26 22          1776 ( 3)         bne     :false
1845-5D             1777 ( 1)         tstb                    ; $00（終端記号）か？
1846-27 14          1778 ( 3)         beq     :true
1848-D1 B4          1779 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
184A-26 1B          1780 ( 3)         bne     :false
184C-EC 09          1781 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
184E-4D             1782 ( 1)         tsta                    ; $00（終端記号）か？
184F-27 0B          1783 ( 3)         beq     :true
1851-91 B5          1784 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
1853-26 12          1785 ( 3)         bne     :false
1855-5D             1786 ( 1)         tstb                    ; $00（終端記号）か？
1856-27 04          1787 ( 3)         beq     :true
1858-D1 B6          1788 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
185A-26 0B          1789 ( 3)         bne     :false
185C-E6 02          1790 ( 4) .true   ldab    2,x             ; B = 語長
185E-EE 03          1791 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
1860-31             1792 ( 1)         ins                     ; 元のリターンアドレスを削除
1861-31             1793 ( 1)         ins
1862-3C             1794 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1863-DE 8D          1795 ( 4)         ldx     <ExePointer
1865-3A             1796 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1866-39             1797 ( 5)         rts                     ; 命令ルーチンにジャンプ
1867-EE 00          1798 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1869-26 C7          1799 ( 3)         bne     :top
186B-DE 8D          1800 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
186D-0C             1801 ( 1)         clc                     ; false: C=0
186E-39             1802 ( 5)         rts
186F-               1803
186F-               1804
186F-               1805      ; ***********************************************************************
186F-               1806      ;   キーワードテーブル Keyword table
186F-               1807      ; ***********************************************************************
186F-               1808      ; レコードの構造 Record structure
186F-               1809      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
186F-               1810      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
186F-               1811      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
186F-               1812      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
186F-               1813      ; キーワードは2文字以上6文字以下
186F-               1814      CMD_TABLE
186F-18 78          1815      .run            .dw     :new
1871-03             1816                      .db     3
1872-16 03          1817                      .dw     exe_run
1874-72 75 6E 00    1818                      .az     "run"
1878-18 81          1819      .new            .dw     :list
187A-03             1820                      .db     3
187B-10 0F          1821                      .dw     cold_start
187D-6E 65 77 00    1822                      .az     "new"
1881-18 8B          1823      .list           .dw     SMT_TABLE:print
1883-04             1824                      .db     4
1884-16 2E          1825                      .dw     exe_list
1886-6C 69 73 74 
     00             1826                      .az     "list"
188B-               1827      SMT_TABLE
188B-18 96          1828      .print          .dw     :input
188D-05             1829                      .db     5
188E-16 49          1830                      .dw     exe_print
1890-70 72 69 6E 
     74 00          1831                      .az     "print"
1896-18 A1          1832      .input          .dw     :if
1898-05             1833                      .db     5
1899-16 93          1834                      .dw     exe_input
189B-69 6E 70 75 
     74 00          1835                      .az     "input"
18A1-18 A9          1836      .if             .dw     :goto
18A3-02             1837                      .db     2
18A4-16 D4          1838                      .dw     exe_if
18A6-69 66 00       1839                      .az     "if"
18A9-18 B3          1840      .goto           .dw     :gosub
18AB-04             1841                      .db     4
18AC-16 F7          1842                      .dw     exe_goto
18AE-67 6F 74 6F 
     00             1843                      .az     "goto"
18B3-18 BE          1844      .gosub          .dw     :return
18B5-05             1845                      .db     5
18B6-16 F4          1846                      .dw     exe_gosub
18B8-67 6F 73 75 
     62 00          1847                      .az     "gosub"
18BE-18 C9          1848      .return         .dw     :end
18C0-06             1849                      .db     6
18C1-17 53          1850                      .dw     exe_return
18C3-72 65 74 75 
     72 6E          1851                      .as     "return"        ; 6文字なので終端不要。'.as'を使用する
18C9-18 D2          1852      .end            .dw     :trunc
18CB-03             1853                      .db     3
18CC-10 37          1854                      .dw     warm_start
18CE-65 6E 64 00    1855                      .az     "end"
18D2-18 DD          1856      .trunc          .dw     :floor
18D4-05             1857                      .db     5
18D5-17 6F          1858                      .dw     exe_trunc
18D7-74 72 75 6E 
     63 00          1859                      .az     "trunc"
18DD-18 E8          1860      .floor          .dw     :bottom
18DF-05             1861                      .db     5
18E0-17 75          1862                      .dw     exe_floor
18E2-66 6C 6F 6F 
     72 00          1863                      .az     "floor"
18E8-00 00          1864      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18EA-               1865
18EA-               1866      FUNC_TABLE
18EA-18 F4          1867      .rnd            .dw     :bottom
18EC-04             1868                      .db     4
18ED-17 7B          1869                      .dw     exe_rnd
18EF-72 6E 64 28 
     00             1870                      .az     "rnd("
18F4-00 00          1871      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18F6-               1872
18F6-               1873
18F6-               1874      ; -----------------------------------------------------------------------
18F6-               1875      ; エラーメッセージを表示する
18F6-               1876      ; Write Error Messege
18F6-               1877      ;【引数】A: エラーコード
18F6-               1878      ;【使用】A, B, X
18F6-               1879      ;【返値】なし
18F6-               1880      ; -----------------------------------------------------------------------
18F6-               1881      write_err_msg:
18F6-7D 00 39       1882 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
18F9-27 03          1883 ( 3)         beq     :1
18FB-BD FF B2       1884 ( 6)         jsr     write_crlf
18FE-CE 19 29       1885 ( 3) .1      ldx     #ERRMSG1
1901-BD FF AF       1886 ( 6)         jsr     write_line
1904-16             1887 ( 1)         tab
1905-CE 19 35       1888 ( 3)         ldx     #ERRCODE
1908-3A             1889 ( 1)         abx
1909-EE 00          1890 ( 5)         ldx     0,x
190B-BD FF AF       1891 ( 6)         jsr     write_line
190E-7D 00 9C       1892 ( 4)         tst     ExeStateFlag    ; 実行モードか？
1911-26 0D          1893 ( 3)         bne     :2              ; No. 行番号を表示せずにスキップ
1913-CE 19 30       1894 ( 3)         ldx     #ERRMSG2        ; Yes. 行番号を表示する
1916-BD FF AF       1895 ( 6)         jsr     write_line
1919-DE 9D          1896 ( 4)         ldx     <ExeLineAddr
191B-EC 00          1897 ( 5)         ldd     0,x
191D-BD 15 2C       1898 ( 6)         jsr     write_integer
1920-BD FF B2       1899 ( 6) .2      jsr     write_crlf
1923-DE 80          1900 ( 4)         ldx     <StackPointer
1925-35             1901 ( 1)         txs
1926-7E 10 37       1902 ( 3)         jmp     warm_start
1929-               1903
1929-4F 6F 70 73 
     21 20 00       1904      ERRMSG1 .az     "Oops! "
1930-20 69 6E 20 
     00             1905      ERRMSG2 .az     " in "
1935-19 4D          1906      ERRCODE .dw     .err00
1937-19 5A          1907              .dw     .err02
1939-19 6D          1908              .dw     .err04
193B-19 80          1909              .dw     .err06
193D-19 99          1910              .dw     .err08
193F-19 A5          1911              .dw     .err10
1941-19 BB          1912              .dw     .err12
1943-19 CF          1913              .dw     .err14
1945-19 E0          1914              .dw     .err16
1947-19 F6          1915              .dw     .err18
1949-1A 10          1916              .dw     .err20
194B-1A 25          1917              .dw     .err22
194D-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1918      .err00  .az     "Syntax error"
195A-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1919      .err02  .az     "Out of range value"
196D-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1920      .err04  .az     "Illegal expression"
1980-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1921      .err06  .az     "Calculate stack overflow"
1999-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1922      .err08  .az     "Zero Divide"
19A5-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1923      .err10  .az     "Print statement error"
19BB-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1924      .err12  .az     "Invalid line number"
19CF-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1925      .err14  .az     "Memory size over"
19E0-55 6E 64 65 
     66 69 6E 65 
     64 20 6C 69 
     6E 65 20 6E 
     75 6D 62 65 
     72 00          1926      .err16  .az     "Undefined line number"
19F6-53 75 62 72 
     6F 75 74 69 
     6E 65 20 73 
     74 61 63 6B 
     20 6F 76 65 
     72 66 6C 6F 
     77 00          1927      .err18  .az     "Subroutine stack overflow"
1A10-52 65 74 75 
     72 6E 20 77 
     69 74 68 6F 
     75 74 20 67 
     6F 73 75 62 
     00             1928      .err20  .az     "Return without gosub"
1A25-53 75 62 73 
     63 72 69 70 
     74 20 69 73 
     20 6F 75 74 
     20 6F 66 20 
     72 61 6E 67 
     65 00          1929      .err22  .az     "Subscript is out of range"
1A3F-               1930
1A3F-               1931
1A3F-               1932      ; ***********************************************************************
1A3F-               1933      ;   文字列 Strings
1A3F-               1934      ; ***********************************************************************
1A3F-1B 5B 32 4A 
     1B 5B 31 3B 
     31 48 00       1935      ESC_CLEAR       .az     #ESC,"[2J",#ESC,"[1;1H"
1A4A-36 33 30 33 
     20 54 69 6E 
     79 20 42 41 
     53 49 43 0D 
     0A 00          1936      MSG_TBSTART     .az     "6303 Tiny BASIC",#CR,#LF
1A5C-4F 4B 0D 0A 
     00             1937      MSG_OK          .az     "OK",#CR,#LF
1A61-               1938
1A61-               1939
1A61-               1940      ; ***********************************************************************
1A61-               1941      ;   デバック用ルーチン Debugging routines
1A61-               1942      ; ***********************************************************************
1A61-               1943      ; -----------------------------------------------------------------------
1A61-               1944      ; ユーザーレジスタを表示する
1A61-               1945      ; Display user registers
1A61-               1946      ; -----------------------------------------------------------------------
1A61-36             1947 ( 4) PUTUR:  psha
1A62-37             1948 ( 4)         pshb
1A63-3C             1949 ( 5)         pshx
1A64-CE 1A 97       1950 ( 3)         ldx     #:MSGUR0
1A67-BD FF AF       1951 ( 6)         jsr     write_line
1A6A-DC A9          1952 ( 4)         ldd     <UR0
1A6C-BD FF BB       1953 ( 6)         jsr     write_word
1A6F-CE 1A 9C       1954 ( 3)         ldx     #:MSGUR1
1A72-BD FF AF       1955 ( 6)         jsr     write_line
1A75-DC AB          1956 ( 4)         ldd     <UR1
1A77-BD FF BB       1957 ( 6)         jsr     write_word
1A7A-CE 1A A2       1958 ( 3)         ldx     #:MSGUR2
1A7D-BD FF AF       1959 ( 6)         jsr     write_line
1A80-DC AD          1960 ( 4)         ldd     <UR2
1A82-BD FF BB       1961 ( 6)         jsr     write_word
1A85-CE 1A A8       1962 ( 3)         ldx     #:MSGUR3
1A88-BD FF AF       1963 ( 6)         jsr     write_line
1A8B-DC AF          1964 ( 4)         ldd     <UR3
1A8D-BD FF BB       1965 ( 6)         jsr     write_word
1A90-BD FF B2       1966 ( 6)         jsr     write_crlf
1A93-38             1967 ( 4)         pulx
1A94-33             1968 ( 3)         pulb
1A95-32             1969 ( 3)         pula
1A96-39             1970 ( 5)         rts
1A97-55 52 30 3D 
     00             1971      .MSGUR0          .az     "UR0="
1A9C-20 55 52 31 
     3D 00          1972      .MSGUR1          .az     " UR1="
1AA2-20 55 52 32 
     3D 00          1973      .MSGUR2          .az     " UR2="
1AA8-20 55 52 33 
     3D 00          1974      .MSGUR3          .az     " UR3="
