0000-                 14
0000-                 15      ; ********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0000-                 46
0020-                 47      RAM_START       .eq     $0020
1FFF-                 48      RAM_END         .eq     $1fff
E000-                 49      ROM_START       .eq     $e000
FFFF-                 50      ROM_END         .eq     $ffff
0FFF-                 51      STACK           .eq     $0fff
0000-                 52
1000-                 53      PROGRAM_START   .eq     $1000
0100-                 54      Rx_BUFFER       .eq     $0100   ; SCI Rx Buffer ($0100-0148,73byte)
0148-                 55      Rx_BUFFER_END   .eq     $0148   ; 73byte（72character）
0149-                 56      CSTACK          .eq     $0149   ; 計算スタック (Calculate stack, 40byte)
01C2-                 57      VARIABLE        .eq     $01c2   ; 変数26文字 ($01c2-01f5, 52byte)
0400-                 58      USERAREATOP     .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 59      USERAREABTM     .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 60
0000-                 61      ; ***********************************************************************
0000-                 62      ;   システム変数 System variables
0000-                 63      ; ***********************************************************************
0000-                 64              .sm     RAM
0020-                 65              .or     $20
0020-                 66
0020-                 67      ; Interrupt Vector Hooking
0020-                 68      VEC_TRAP        .bs     3
0023-                 69      VEC_SCI         .bs     3
0026-                 70      VEC_TOF         .bs     3
0029-                 71      VEC_OCF         .bs     3
002C-                 72      VEC_ICF         .bs     3
002F-                 73      VEC_IRQ         .bs     3
0032-                 74      VEC_SWI         .bs     3
0035-                 75      VEC_NMI         .bs     3
0038-                 76      BreakPointFlag  .bs     1
0039-                 77      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 78      ; General-Purpose Registers
003A-                 79      R0              .bs     2
003C-                 80      R1              .bs     2
003E-                 81
003E-                 82      ; ***********************************************************************
003E-                 83      ;   変数 Variables
003E-                 84      ; ***********************************************************************
003E-                 85              .sm     RAM
0080-                 86              .or     $80
0080-                 87
0080-                 88      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                 89      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                 90      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                 91      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                 92      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                 93      Divisor         .bs     2       ; 除数
0089-                 94      Remainder       .bs     2       ; 剰余
008B-                 95      VariableAddr    .bs     2       ; 変数のアドレス
008D-                 96      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                 97      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                 98      Source          .bs     2       ; 転送元アドレス
0092-                 99      Destination     .bs     2       ; 転送先アドレス
0094-                100      Bytes           .bs     2       ; 転送バイト数
0096-                101      LineNumber      .bs     2       ; 行番号
0098-                102      LineLength      .bs     2       ; 行の長さ
009A-                103      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                104      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                105
009D-                106      ; General-Purpose Registers
009D-                107      UR0             *
009D-                108      UR0H            .bs     1
009E-                109      UR0L            .bs     1
009F-                110      UR1             *
009F-                111      UR1H            .bs     1
00A0-                112      UR1L            .bs     1
00A1-                113      UR2             *
00A1-                114      UR2H            .bs     1
00A2-                115      UR2L            .bs     1
00A3-                116      UR3             *
00A3-                117      UR3H            .bs     1
00A4-                118      UR3L            .bs     1
00A5-                119      ; Work area
00A5-                120      COMPARE         .bs     6       ; 文字列比較用バッファ
00AB-                121
00AB-                122      ; ***********************************************************************
00AB-                123      ;   Program Start
00AB-                124      ; ***********************************************************************
0000-                125              .sm     CODE
1000-                126              .or     PROGRAM_START
1000-                127
1000-                128      init_tinybasic:
1000-30              129 ( 1)         tsx
1001-DF 80           130 ( 4)         stx     <StackPointer
1003-                131
1003-                132
1003-                133      cold_start:
1003-                134            ; // プログラムエリアの初期化
1003-CE 04 00        135 ( 3)         ldx     #USERAREATOP
1006-DF 9A           136 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              137 ( 1)         clra
1009-5F              138 ( 1)         clrb
100A-ED 00           139 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           140 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                141            ; // 変数領域の初期化
100E-CE 01 C2        142 ( 3)         ldx     #VARIABLE
1011-ED 00           143 ( 5) .loop   std     0,x
1013-08              144 ( 1)         inx
1014-08              145 ( 1)         inx
1015-8C 01 F6        146 ( 3)         cpx     #VARIABLE+52
1018-26 F7           147 ( 3)         bne     :loop
101A-                148
101A-                149
101A-                150      tb_main:
101A-72 01 9C        151 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
101D-C6 3E           152 ( 2)         ldab    #'>'
101F-BD FF AC        153 ( 6)         jsr     write_char
1022-BD FF A9        154 ( 6)         jsr     read_line
1025-CE 01 00        155 ( 3)         ldx     #Rx_BUFFER      ; 実行位置アドレスをセット
1028-                156            ; // 行番号判定
1028-BD 12 D3        157 ( 6)         jsr     get_int_from_decimal
102B-24 0A           158 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
102D-83 00 00        159 ( 3)         subd    #0
1030-2E 08           160 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
1032-86 0C           161 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1034-7E 15 4F        162 ( 3)         jmp     write_err_msg
1037-                163
1037-                164      execute_mode:
1037-7E 10 93        165 ( 3)         jmp     exe_line
103A-                166
103A-                167      edit_mode:
103A-DF 8D           168 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
103C-DD 96           169 ( 4)         std     <LineNumber     ; 行番号を保存
103E-                170            ; // 行の長さを取得
103E-86 04           171 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1040-E6 00           172 ( 4) .loop   ldab    0,x
1042-27 04           173 ( 3)         beq     :1
1044-4C              174 ( 1)         inca                    ; 行の長さを+1
1045-08              175 ( 1)         inx                     ; バッファアドレスを+1
1046-20 F8           176 ( 3)         bra     :loop
1048-97 99           177 ( 3) .1      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
104A-                178            ; // 転送の準備
104A-DE 9A           179 ( 4)         ldx     <PrgmEndAddr    ; X <- プログラムの最終アドレス
104C-DC 9A           180 ( 4)         ldd     <PrgmEndAddr
104E-D3 98           181 ( 4)         addd    <LineLength     ; D <- 行の長さを足した最終アドレス
1050-18              182 ( 2)         xgdx
1051-8C 0D FD        183 ( 3)         cpx     #USERAREABTM    ; ユーザーエリアを超えていないかチェック
1054-18              184 ( 2)         xgdx
1055-24 24           185 ( 3)         bcc     :err14          ; "Memory size over"
1057-DD 9A           186 ( 4)         std     <PrgmEndAddr    ; 新しい最終アドレスを設定
1059-                187            ; // 行番号と行の長さを転送
1059-DC 96           188 ( 4)         ldd     <LineNumber     ; 行番号を取得
105B-ED 00           189 ( 5)         std     0,x
105D-08              190 ( 1)         inx
105E-08              191 ( 1)         inx
105F-D6 99           192 ( 3)         ldab    <LineLength+1   ; 行の長さを取得
1061-E7 00           193 ( 4)         stab    0,x
1063-                194            ; // mem_copyの引数を設定
1063-08              195 ( 1)         inx
1064-DF 92           196 ( 4)         stx     <Destination    ; 転送先アドレス（行の長さの直後）を設定
1066-4F              197 ( 1)         clra                    ; LineLengthの上位バイトをゼロにする
1067-C0 03           198 ( 2)         subb    #3              ; LineLengthから行番号・行の長さの3バイト分を引く
1069-DD 94           199 ( 4)         std     <Bytes          ; 転送バイト数を設定
106B-DC 8D           200 ( 4)         ldd     <ExePointer     ; 行番号の直後を指しているバッファアドレスを復帰
106D-DD 90           201 ( 4)         std     <Source         ; 転送元アドレスを設定
106F-BD 14 A7        202 ( 6)         jsr     mem_copy
1072-                203            ; // 終端行の挿入
1072-DE 9A           204 ( 4)         ldx     <PrgmEndAddr
1074-4F              205 ( 1)         clra
1075-5F              206 ( 1)         clrb
1076-ED 00           207 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
1078-7E 10 1A        208 ( 3)         jmp     tb_main
107B-86 0E           209 ( 2) .err14  ldaa    #14              ; "Memory size over"
107D-7E 15 4F        210 ( 3)         jmp     write_err_msg
1080-                211
1080-                212
1080-                213      ; -----------------------------------------------------------------------
1080-                214      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1080-                215      ; Is a multi statement mark?
1080-                216      ;【引数】X:実行位置アドレス
1080-                217      ;【使用】B, X
1080-                218      ;【返値】なし
1080-                219      ; -----------------------------------------------------------------------
1080-                220      is_multi:
1080-BD 13 9C        221 ( 6)         jsr     skip_space
1083-27 07           222 ( 3)         beq     :end
1085-C1 3A           223 ( 2)         cmpb    #':'
1087-26 06           224 ( 3)         bne     :err00
1089-08              225 ( 1)         inx
108A-20 07           226 ( 3)         bra     exe_line
108C-7E 10 1A        227 ( 3) .end    jmp     tb_main
108F-4F              228 ( 1) .err00  clra                    ; "Syntax error"
1090-7E 15 4F        229 ( 3)         jmp     write_err_msg
1093-                230
1093-                231
1093-                232      ; -----------------------------------------------------------------------
1093-                233      ; 一行実行
1093-                234      ; Execute one line
1093-                235      ;【引数】X:実行位置アドレス
1093-                236      ;【使用】A, B, X
1093-                237      ;【返値】なし
1093-                238      ; -----------------------------------------------------------------------
1093-                239      exe_line:
1093-BD 13 9C        240 ( 6)         jsr     skip_space
1096-27 37           241 ( 3)         beq     :end            ; 終端文字（$00）ならば終了
1098-                242            ; // 代入文のチェック
1098-BD 13 87        243 ( 6)         jsr     is_variable     ; 変数か？
109B-24 12           244 ( 3)         bcc     :cmd            ; No. テーブル検索へ
109D-86 01           245 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
109F-58              246 ( 1)         aslb                    ; B = 変数領域の下位バイト
10A0-DD 8B           247 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
10A2-BD 13 9C        248 ( 6)         jsr     skip_space      ; Yes. 代入文か？
10A5-C1 3D           249 ( 2)         cmpb    #'='
10A7-26 29           250 ( 3)         bne     :err00          ; No. エラー処理へ
10A9-08              251 ( 1)         inx                     ; Yes. 代入実行
10AA-BD 13 D9        252 ( 6)         jsr     assign_to_var
10AD-20 D1           253 ( 3)         bra     is_multi
10AF-EC 00           254 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
10B1-DD A5           255 ( 4)         std     <COMPARE
10B3-EC 02           256 ( 5)         ldd     2,x
10B5-DD A7           257 ( 4)         std     <COMPARE+2
10B7-EC 04           258 ( 5)         ldd     4,x
10B9-DD A9           259 ( 4)         std     <COMPARE+4
10BB-DF 8D           260 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
10BD-7D 00 9C        261 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
10C0-27 05           262 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
10C2-CE 15 1C        263 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
10C5-20 03           264 ( 3)         bra     :2
10C7-CE 15 2F        265 ( 3) .1      ldx     #SMT_TABLE
10CA-BD 14 DF        266 ( 6) .2      jsr     search_table    ; テーブル検索実行
10CD-24 03           267 ( 3)         bcc     :err00
10CF-7E 10 1A        268 ( 3) .end    jmp     tb_main
10D2-                269
10D2-4F              270 ( 1) .err00  clra                    ; Syntax error.
10D3-7E 15 4F        271 ( 3)         jmp     write_err_msg
10D6-                272
10D6-                273
10D6-                274      ; -----------------------------------------------------------------------
10D6-                275      ; 式を評価する
10D6-                276      ; Evaluate the expression
10D6-                277      ;【引数】B:アスキーコード X:実行位置アドレス
10D6-                278      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
10D6-                279      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
10D6-                280      ;        偽(C=0) / X:現在の実行位置アドレス
10D6-                281      ; -----------------------------------------------------------------------
10D6-                282      eval_expression:
00A1-                283      .SP     .eq     UR2
00A3-                284      .X      .eq     UR3
10D6-                285            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
10D6-DF A3           286 ( 4)         stx     <:X
10D8-30              287 ( 1)         tsx
10D9-DF A1           288 ( 4)         stx     <:SP
10DB-DE A3           289 ( 4)         ldx     <:X
10DD-                290            ; // 計算スタックの初期化
10DD-CC 01 72        291 ( 3)         ldd     #CSTACK+40+1    ; 40byte分
10E0-DD 82           292 ( 4)         std     <CStackPtr
10E2-                293            ; // 式評価開始
10E2-8D 08           294 ( 5)         bsr     expr_4th
10E4-                295            ; // 計算結果をスタックトップから取り出す
10E4-3C              296 ( 5)         pshx
10E5-DE 82           297 ( 4)         ldx     <CStackPtr
10E7-EC 00           298 ( 5)         ldd     0,x
10E9-38              299 ( 4)         pulx
10EA-0D              300 ( 1)         sec                     ; true:C=1
10EB-39              301 ( 5)         rts
10EC-                302
10EC-                303      expr_4th:
10EC-8D 50           304 ( 5)         bsr     expr_3rd
10EE-BD 13 9C        305 ( 6) .loop   jsr     skip_space
10F1-C1 3D           306 ( 2)         cmpb    #'='            ; '='?
10F3-26 08           307 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
10F5-08              308 ( 1)         inx
10F6-8D 46           309 ( 5)         bsr     expr_3rd
10F8-BD 12 86        310 ( 6)         jsr     CS_eq           ; EQual to
10FB-20 F1           311 ( 3)         bra     :loop
10FD-C1 3C           312 ( 2) .ltsign cmpb    #'<'            ; '<'?
10FF-26 22           313 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1101-08              314 ( 1)         inx
1102-E6 00           315 ( 4)         ldab    0,x
1104-C1 3E           316 ( 2)         cmpb    #'>'            ; '<>'?
1106-26 08           317 ( 3)         bne     :lte
1108-08              318 ( 1)         inx
1109-8D 33           319 ( 5)         bsr     expr_3rd
110B-BD 12 A7        320 ( 6)         jsr     CS_ne           ; Not Equal to
110E-20 DE           321 ( 3)         bra     :loop
1110-C1 3D           322 ( 2) .lte    cmpb    #'='            ; '<='?
1112-26 08           323 ( 3)         bne     :lt
1114-08              324 ( 1)         inx
1115-8D 27           325 ( 5)         bsr     expr_3rd
1117-BD 12 9C        326 ( 6)         jsr     CS_lte          ; Less Than or Equal to
111A-20 D2           327 ( 3)         bra     :loop
111C-8D 20           328 ( 5) .lt     bsr     expr_3rd
111E-BD 12 91        329 ( 6)         jsr     CS_lt           ; Less Than
1121-20 CB           330 ( 3)         bra     :loop
1123-C1 3E           331 ( 2) .gtsign cmpb    #'>'            ; '>'?
1125-26 16           332 ( 3)         bne     :end
1127-08              333 ( 1)         inx
1128-E6 00           334 ( 4)         ldab    0,x
112A-C1 3D           335 ( 2)         cmpb    #'='            ; '>='?
112C-26 08           336 ( 3)         bne     :gt
112E-08              337 ( 1)         inx
112F-8D 0D           338 ( 5)         bsr     expr_3rd
1131-BD 12 BD        339 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
1134-20 B8           340 ( 3)         bra     :loop
1136-8D 06           341 ( 5) .gt     bsr     expr_3rd
1138-BD 12 B2        342 ( 6)         jsr     CS_gt           ; Greater Than
113B-20 B1           343 ( 3)         bra     :loop
113D-39              344 ( 5) .end    rts
113E-                345
113E-                346      expr_3rd:
113E-8D 1C           347 ( 5)         bsr     expr_2nd
1140-BD 13 9C        348 ( 6) .loop   jsr     skip_space
1143-C1 2B           349 ( 2)         cmpb    #'+'
1145-26 08           350 ( 3)         bne     :minus
1147-08              351 ( 1)         inx
1148-8D 12           352 ( 5)         bsr     expr_2nd
114A-BD 11 D1        353 ( 6)         jsr     CS_add
114D-20 F1           354 ( 3)         bra     :loop
114F-C1 2D           355 ( 2) .minus  cmpb    #'-'
1151-26 08           356 ( 3)         bne     :end
1153-08              357 ( 1)         inx
1154-8D 06           358 ( 5)         bsr     expr_2nd
1156-BD 11 DA        359 ( 6)         jsr     CS_sub
1159-20 E5           360 ( 3)         bra     :loop
115B-39              361 ( 5) .end    rts
115C-                362
115C-                363      expr_2nd:
115C-8D 28           364 ( 5)         bsr     expr_1st
115E-BD 13 9C        365 ( 6) .loop   jsr     skip_space
1161-C1 2A           366 ( 2)         cmpb    #'*'
1163-26 08           367 ( 3)         bne     :div
1165-08              368 ( 1)         inx
1166-8D 1E           369 ( 5)         bsr     expr_1st
1168-BD 11 E3        370 ( 6)         jsr     CS_mul
116B-20 F1           371 ( 3)         bra     :loop
116D-C1 2F           372 ( 2) .div    cmpb    #'/'
116F-26 08           373 ( 3)         bne     :mod
1171-08              374 ( 1)         inx
1172-8D 12           375 ( 5)         bsr     expr_1st
1174-BD 12 00        376 ( 6)         jsr     CS_div
1177-20 E5           377 ( 3)         bra     :loop
1179-C1 25           378 ( 2) .mod    cmpb    #'%'
117B-26 08           379 ( 3)         bne     :end
117D-08              380 ( 1)         inx
117E-8D 06           381 ( 5)         bsr     expr_1st
1180-BD 12 1C        382 ( 6)         jsr     CS_mod
1183-20 D9           383 ( 3)         bra     :loop
1185-39              384 ( 5) .end    rts
1186-                385
1186-                386      expr_1st:
00A1-                387      .SP     .eq     UR2
00A3-                388      .X      .eq     UR3
1186-BD 13 9C        389 ( 6)         jsr     skip_space
1189-BD 12 D3        390 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
118C-24 02           391 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
118E-20 1D           392 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1190-BD 13 87        393 ( 6) .var    jsr     is_variable     ; 変数か？
1193-24 0A           394 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
1195-                395            ; // 変数値の取得
1195-3C              396 ( 5)         pshx                    ; 実行位置アドレスを退避
1196-86 01           397 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
1198-58              398 ( 1)         aslb                    ; B = 変数領域の下位バイト
1199-18              399 ( 2)         xgdx                    ; X = 変数のアドレス
119A-EC 00           400 ( 5)         ldd     0,x             ; D <- 変数の値
119C-38              401 ( 4)         pulx                    ; 実行位置アドレスを復帰
119D-20 0E           402 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
119F-C1 28           403 ( 2) .paren  cmpb    #'('
11A1-26 1A           404 ( 3)         bne     :err
11A3-08              405 ( 1)         inx
11A4-BD 10 EC        406 ( 6)         jsr     expr_4th
11A7-C1 29           407 ( 2)         cmpb    #')'
11A9-26 12           408 ( 3)         bne     :err
11AB-08              409 ( 1)         inx
11AC-39              410 ( 5)         rts
11AD-3C              411 ( 5) .push   pshx                    ; 実行位置アドレスを退避
11AE-DE 82           412 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11B0-09              413 ( 1)         dex
11B1-09              414 ( 1)         dex
11B2-8C 01 47        415 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
11B5-25 0D           416 ( 3)         bcs     :err06
11B7-ED 00           417 ( 5)         std     0,x
11B9-DF 82           418 ( 4)         stx     <CStackPtr
11BB-38              419 ( 4)         pulx                    ; 実行位置アドレスを復帰
11BC-39              420 ( 5)         rts
11BD-                421            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
11BD-DE A1           422 ( 4) .err    ldx     <:SP
11BF-35              423 ( 1)         txs
11C0-DE A3           424 ( 4)         ldx     <:X
11C2-0C              425 ( 1)         clc                     ; false:C=0
11C3-39              426 ( 5)         rts
11C4-86 06           427 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
11C6-7E 15 4F        428 ( 3)         jmp     write_err_msg
11C9-                429
11C9-                430      ;
11C9-                431      ; Arithmetic operator
11C9-                432      ;
11C9-                433      CS_store:
11C9-08              434 ( 1)         inx
11CA-08              435 ( 1)         inx
11CB-ED 00           436 ( 5)         std     0,x
11CD-DF 82           437 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
11CF-38              438 ( 4)         pulx                    ; 実行位置アドレスを復帰
11D0-39              439 ( 5)         rts
11D1-                440
11D1-3C              441 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
11D2-DE 82           442 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11D4-EC 02           443 ( 5)         ldd     2,x
11D6-E3 00           444 ( 5)         addd    0,x
11D8-20 EF           445 ( 3)         bra     CS_store
11DA-                446
11DA-3C              447 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
11DB-DE 82           448 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11DD-EC 02           449 ( 5)         ldd     2,x
11DF-A3 00           450 ( 5)         subd    0,x
11E1-20 E6           451 ( 3)         bra     CS_store
11E3-                452
11E3-                453      CS_mul:
009D-                454      .Result         .eq     UR0
11E3-3C              455 ( 5)         pshx                    ; 実行位置アドレスを退避
11E4-DE 82           456 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11E6-                457              ; B * D
11E6-A6 03           458 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
11E8-E6 01           459 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
11EA-3D              460 ( 7)         mul                     ; B * D
11EB-DD 9D           461 ( 4)         std     <:Result        ;「B*D」を保存
11ED-                462              ; A * D
11ED-EC 01           463 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
11EF-3D              464 ( 7)         mul                     ; A * D
11F0-DB 9D           465 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
11F2-D7 9D           466 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
11F4-                467              ; C * B
11F4-A6 00           468 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
11F6-E6 03           469 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
11F8-3D              470 ( 7)         mul                     ; C * B
11F9-DB 9D           471 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
11FB-17              472 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
11FC-D6 9E           473 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
11FE-20 C9           474 ( 3)         bra     CS_store
1200-                475
1200-                476      ;
1200-                477      ; 符号付き割り算の考え方
1200-                478      ; ・剰余は除数の符号と同一
1200-                479      ;   ・ 7 / 3  = 商  2、剰余  1
1200-                480      ;   ・-7 / 3  = 商 -3、剰余  2
1200-                481      ;   ・ 7 / -3 = 商 -3、剰余 -2
1200-                482      ;   ・-7 / -3 = 商  2、剰余 -1
1200-                483      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
1200-                484      ;       2.ただし、除数がゼロの場合は1は足さない
1200-                485      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
1200-                486      ;         除数の絶対値から剰余の絶対値を引く
1200-                487      ;       2.その結果を除数と同じ符号にする
1200-                488      ;       3.ただし、除数がゼロの場合は剰余もゼロ
1200-                489      ;
1200-3C              490 ( 5) CS_div: pshx                    ; 実行位置アドレスを退避
1201-DE 82           491 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1203-8D 37           492 ( 5)         bsr     div_uint        ; 除算実行
1205-18              493 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1206-7D 00 85        494 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1209-27 0D           495 ( 3)         beq     :end            ; '+'なら終了
120B-8C 00 00        496 ( 3)         cpx     #0              ; 剰余はゼロか？
120E-27 03           497 ( 3)         beq     :sign
1210-C3 00 01        498 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
1213-43              499 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1214-53              500 ( 1)         comb
1215-C3 00 01        501 ( 3)         addd    #1
1218-DE 82           502 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
121A-20 AD           503 ( 3)         bra     CS_store
121C-                504
121C-3C              505 ( 5) CS_mod: pshx                    ; 実行位置アドレスを退避
121D-DE 82           506 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
121F-8D 1B           507 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1221-DD 89           508 ( 4)         std     <Remainder      ; 剰余はゼロか？
1223-27 13           509 ( 3)         beq     :end            ; ゼロであれば終了
1225-7D 00 85        510 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
1228-27 04           511 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
122A-DC 87           512 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
122C-93 89           513 ( 4)         subd    <Remainder
122E-7D 00 86        514 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1231-27 05           515 ( 3)         beq     :end            ; '+'なら終了
1233-43              516 ( 1)         coma                    ; '-'なら2の補数にする
1234-53              517 ( 1)         comb
1235-C3 00 01        518 ( 3)         addd    #1
1238-DE 82           519 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
123A-20 8D           520 ( 3)         bra     CS_store
123C-                521
123C-                522      div_uint:
009D-                523      .Counter        .eq     UR0H
123C-EC 00           524 ( 5)         ldd     0,x             ; ゼロ除算チェック
123E-27 41           525 ( 3)         beq     :err08          ; 除数がゼロならエラー
1240-5F              526 ( 1)         clrb
1241-D7 85           527 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1243-D7 86           528 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1245-C6 10           529 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1247-D7 9D           530 ( 3)         stab    <:Counter
1249-                531              ; // 剰余の符号フラグの設定
1249-EC 00           532 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
124B-2A 03           533 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
124D-7C 00 86        534 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1250-                535              ; // 商の符号フラグの設定
1250-A8 02           536 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
1252-2A 03           537 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
1254-7C 00 85        538 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
1257-                539              ; // 除数を絶対値にする
1257-EC 00           540 ( 5) .2      ldd     0,x             ; D <- 除数
1259-2A 05           541 ( 3)         bpl     :3
125B-43              542 ( 1)         coma                    ; 除数が負なら絶対値にする
125C-53              543 ( 1)         comb
125D-C3 00 01        544 ( 3)         addd    #1
1260-DD 87           545 ( 4) .3      std     <Divisor        ; 除数を保存
1262-                546              ; // 非除数を絶対値にする
1262-EC 02           547 ( 5)         ldd     2,x             ; D <- 被除数
1264-2A 05           548 ( 3)         bpl     :4
1266-43              549 ( 1)         coma                    ; 被除数が負なら絶対値にする
1267-53              550 ( 1)         comb
1268-C3 00 01        551 ( 3)         addd    #1
126B-                552              ; // 除算実行
126B-18              553 ( 2) .4      xgdx                    ; X <- 被除数
126C-4F              554 ( 1)         clra                    ; D（WORK）をクリア
126D-5F              555 ( 1)         clrb
126E-18              556 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
126F-05              557 ( 1)         asld
1270-18              558 ( 2)         xgdx
1271-59              559 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
1272-49              560 ( 1)         rola
1273-93 87           561 ( 4)         subd    <Divisor        ; WORK - 除数
1275-08              562 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
1276-24 03           563 ( 3)         bcc     :5              ; WORKから除数を引けた？
1278-D3 87           564 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
127A-09              565 ( 1)         dex                     ; XレジスタのLSBを0に戻す
127B-7A 00 9D        566 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
127E-26 EE           567 ( 3)         bne     :loop
1280-39              568 ( 5)         rts
1281-86 08           569 ( 2) .err08  ldaa    #8              ; "Zero Divide"
1283-7E 15 4F        570 ( 3)         jmp     write_err_msg
1286-                571
1286-3C              572 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
1287-DE 82           573 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1289-EC 02           574 ( 5)         ldd     2,x
128B-A3 00           575 ( 5)         subd    0,x
128D-27 39           576 ( 3)         beq     CS_true
128F-20 3D           577 ( 3)         bra     CS_false
1291-                578
1291-3C              579 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1292-DE 82           580 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1294-EC 02           581 ( 5)         ldd     2,x
1296-A3 00           582 ( 5)         subd    0,x
1298-2D 2E           583 ( 3)         blt     CS_true
129A-20 32           584 ( 3)         bra     CS_false
129C-                585
129C-3C              586 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
129D-DE 82           587 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
129F-EC 02           588 ( 5)         ldd     2,x
12A1-A3 00           589 ( 5)         subd    0,x
12A3-2F 23           590 ( 3)         ble     CS_true
12A5-20 27           591 ( 3)         bra     CS_false
12A7-                592
12A7-3C              593 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
12A8-DE 82           594 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12AA-EC 02           595 ( 5)         ldd     2,x
12AC-A3 00           596 ( 5)         subd    0,x
12AE-26 18           597 ( 3)         bne     CS_true
12B0-20 1C           598 ( 3)         bra     CS_false
12B2-                599
12B2-3C              600 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
12B3-DE 82           601 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12B5-EC 02           602 ( 5)         ldd     2,x
12B7-A3 00           603 ( 5)         subd    0,x
12B9-2E 0D           604 ( 3)         bgt     CS_true
12BB-20 11           605 ( 3)         bra     CS_false
12BD-                606
12BD-3C              607 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
12BE-DE 82           608 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12C0-EC 02           609 ( 5)         ldd     2,x
12C2-A3 00           610 ( 5)         subd    0,x
12C4-2C 02           611 ( 3)         bge     CS_true
12C6-20 06           612 ( 3)         bra     CS_false
12C8-                613
12C8-                614      CS_true:
12C8-CC 00 01        615 ( 3)         ldd     #1
12CB-7E 11 C9        616 ( 3)         jmp     CS_store
12CE-                617
12CE-                618      CS_false:
12CE-4F              619 ( 1)         clra
12CF-5F              620 ( 1)         clrb
12D0-7E 11 C9        621 ( 3)         jmp     CS_store
12D3-                622
12D3-                623      ; -----------------------------------------------------------------------
12D3-                624      ; テキストバッファの10進文字列から数値を取得する
12D3-                625      ; Get a integer from a decimal string in a text buffer
12D3-                626      ;【引数】X:バッファアドレス
12D3-                627      ;【使用】A, B, X, UR0, UR1
12D3-                628      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
12D3-                629      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
12D3-                630      ; -----------------------------------------------------------------------
12D3-                631      get_int_from_decimal:
009D-                632      .RetValue       .eq     UR0     ; Return Value
009F-                633      .TempValue      .eq     UR1     ; Temporary Value
12D3-4F              634 ( 1)         clra
12D4-5F              635 ( 1)         clrb
12D5-DD 9D           636 ( 4)         std     <:RetValue
12D7-97 9F           637 ( 3)         staa    <:TempValue
12D9-97 84           638 ( 3)         staa    <SignFlag
12DB-E6 00           639 ( 4)         ldab    0,x             ; 1文字取得
12DD-C1 2D           640 ( 2)         cmpb    #'-'            ; マイナス記号か？
12DF-26 05           641 ( 3)         bne     :1
12E1-7C 00 84        642 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
12E4-20 0B           643 ( 3)         bra     :next
12E6-C1 2B           644 ( 2) .1      cmpb    #'+'            ; プラス記号か？
12E8-27 07           645 ( 3)         beq     :next
12EA-BD FF C1        646 ( 6)         jsr     is_decimal_char ; 数字か？
12ED-24 36           647 ( 3)         bcc     :false          ; No. C=1で終了
12EF-20 13           648 ( 3)         bra     :first
12F1-08              649 ( 1) .next   inx                     ; 符号の次の1文字を取得
12F2-E6 00           650 ( 4)         ldab    0,x
12F4-BD FF C1        651 ( 6)         jsr     is_decimal_char ; 数字か？
12F7-24 40           652 ( 3)         bcc     :err04          ; No. エラー処理へ
12F9-20 09           653 ( 3)         bra     :first          ; Yes. これが最初の数字
12FB-DD 9D           654 ( 4) .loop   std     <:RetValue      ; 結果を退避
12FD-E6 00           655 ( 4)         ldab    0,x             ; 1文字取得
12FF-BD FF C1        656 ( 6)         jsr     is_decimal_char ; 数字か？
1302-24 14           657 ( 3)         bcc     :end
1304-C0 30           658 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
1306-D7 A0           659 ( 3)         stab    <:TempValue+1
1308-                660            ; // RetValue * 10 + TempValue
1308-DC 9D           661 ( 4)         ldd     <:RetValue
130A-05              662 ( 1)         asld                    ; * 2
130B-05              663 ( 1)         asld                    ; * 4
130C-D3 9D           664 ( 4)         addd    <:RetValue      ; * 5
130E-05              665 ( 1)         asld                    ; * 10
130F-D3 9F           666 ( 4)         addd    <:TempValue     ; += TempValue
1311-08              667 ( 1)         inx                     ; ポインタを進める
1312-25 20           668 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
1314-2B 10           669 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
1316-20 E3           670 ( 3)         bra     :loop
1318-DC 9D           671 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
131A-7D 00 84        672 ( 4)         tst     <SignFlag       ; 符号チェック
131D-27 05           673 ( 3)         beq     :true
131F-43              674 ( 1)         coma                    ; 負なら2の補数に
1320-53              675 ( 1)         comb
1321-C3 00 01        676 ( 3)         addd    #1
1324-0D              677 ( 1) .true   sec
1325-39              678 ( 5) .false  rts
1326-                679
1326-                680      .overflow
1326-                681            ; // -32,768かどうかの判定
1326-18              682 ( 2)         xgdx
1327-8C 80 00        683 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
132A-18              684 ( 2)         xgdx
132B-26 07           685 ( 3)         bne     :err02          ; No. 範囲外
132D-7D 00 84        686 ( 4)         tst     <SignFlag       ; 符号チェック
1330-27 02           687 ( 3)         beq     :err02          ; 正ならば範囲外
1332-20 C7           688 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
1334-                689
1334-86 02           690 ( 2) .err02  ldaa    #2              ; "Out of range"
1336-7E 15 4F        691 ( 3)         jmp     write_err_msg
1339-86 04           692 ( 2) .err04  ldaa    #4              ; "Illegal expression"
133B-7E 15 4F        693 ( 3)         jmp     write_err_msg
133E-                694
133E-                695
133E-                696      ; -----------------------------------------------------------------------
133E-                697      ; Dレジスタの数値をコンソールに出力する
133E-                698      ; Write Decimal Character converted from Integer
133E-                699      ;【引数】D:Integer
133E-                700      ;【使用】A, B, X
133E-                701      ;【返値】なし
133E-                702      ; -----------------------------------------------------------------------
133E-                703      write_integer:
009D-                704      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
009E-                705      .Counter        .eq     UR0L    ; 桁カウンター
133E-2A 0C           706 ( 3)         bpl     :plus           ; 符号判定
1340-37              707 ( 4)         pshb                    ; 負数なら'-'を出力する
1341-C6 2D           708 ( 2)         ldab    #'-'
1343-BD FF AC        709 ( 6)         jsr     write_char
1346-33              710 ( 3)         pulb
1347-43              711 ( 1)         coma                    ; 絶対値にする（2の補数にする）
1348-53              712 ( 1)         comb
1349-C3 00 01        713 ( 3)         addd    #1
134C-7F 00 9D        714 ( 5) .plus   clr     <:ZeroSuppress
134F-CE 13 7F        715 ( 3)         ldx     #:CONST
1352-7F 00 9E        716 ( 5) .loop   clr     <:Counter
1355-A3 00           717 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
1357-25 05           718 ( 3)         bcs     :write
1359-7C 00 9E        719 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
135C-20 F7           720 ( 3)         bra     :digit
135E-                721
135E-E3 00           722 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1360-37              723 ( 4)         pshb
1361-D6 9E           724 ( 3)         ldab    <:Counter
1363-27 03           725 ( 3)         beq     :1              ; この桁はゼロか？
1365-7C 00 9D        726 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
1368-7D 00 9D        727 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
136B-27 05           728 ( 3)         beq     :2              ; No. この桁は表示しない
136D-CB 30           729 ( 2)         addb    #$30            ; Yes. この桁を表示する
136F-BD FF AC        730 ( 6)         jsr     write_char
1372-33              731 ( 3) .2      pulb
1373-08              732 ( 1)         inx                     ; 次の引く数へ
1374-08              733 ( 1)         inx
1375-8C 13 87        734 ( 3)         cpx     #:CONST+8
1378-26 D8           735 ( 3)         bne     :loop
137A-CB 30           736 ( 2)         addb    #$30            ; 一の桁の数値を表示
137C-7E FF AC        737 ( 3)         jmp     write_char
137F-                738      ; Dから引いていく数
137F-27 10           739      .CONST  .dw     $2710           ; 10,000
1381-03 E8           740              .dw     $03e8           ; 1,000
1383-00 64           741              .dw     $0064           ; 100
1385-00 0A           742              .dw     $000a           ; 10
1387-                743
1387-                744
1387-                745      ; -----------------------------------------------------------------------
1387-                746      ; テキストバッファの英文字が変数か判定する
1387-                747      ; Is a character retrieved from a text buffer a variable?
1387-                748      ;【引数】X:バッファアドレス
1387-                749      ;【使用】A, B, X
1387-                750      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
1387-                751      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
1387-                752      ; -----------------------------------------------------------------------
1387-                753      is_variable:
1387-E6 00           754 ( 4)         ldab    0,x
1389-BD FF BE        755 ( 6)         jsr     is_alphabetic_char
138C-24 0D           756 ( 3)         bcc     :end
138E-17              757 ( 1)         tba                             ; 1文字目のアスキーコードを退避
138F-E6 01           758 ( 4)         ldab    1,x                     ; 2文字目を取得
1391-BD FF BE        759 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
1394-16              760 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
1395-24 02           761 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
1397-0C              762 ( 1)         clc                             ; Yes. 変数ではない。C=0
1398-39              763 ( 5)         rts
1399-08              764 ( 1) .var    inx                             ; ポインタを進める
139A-0D              765 ( 1)         sec                             ; C=1
139B-39              766 ( 5) .end    rts
139C-                767
139C-                768
139C-                769      ; -----------------------------------------------------------------------
139C-                770      ; 空白を読み飛ばす
139C-                771      ; Skip Space
139C-                772      ;【引数】X:実行位置アドレス
139C-                773      ;【使用】B, X
139C-                774      ;【返値】B:アスキーコード（$00の時Z=1）
139C-                775      ;        X:実行位置アドレス
139C-                776      ; -----------------------------------------------------------------------
139C-                777      skip_space:
139C-E6 00           778 ( 4)         ldab    0,x
139E-27 07           779 ( 3)         beq     :end
13A0-C1 20           780 ( 2)         cmpb    #SPACE
13A2-22 03           781 ( 3)         bhi     :end
13A4-08              782 ( 1)         inx
13A5-20 F5           783 ( 3)         bra     skip_space
13A7-39              784 ( 5) .end    rts
13A8-                785
13A8-                786
13A8-                787      ; -----------------------------------------------------------------------
13A8-                788      ; 引用符付きの文字列を出力する
13A8-                789      ; Write Quoted Stirng
13A8-                790      ;【引数】B:アスキーコード X:実行位置アドレス
13A8-                791      ;【使用】A, B, X
13A8-                792      ;【返値】真(C=1) / X:次の実行位置アドレス
13A8-                793      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
13A8-                794      ; -----------------------------------------------------------------------
13A8-                795      write_quoted_str:
13A8-C1 22           796 ( 2)         cmpb    #$22            ; 一重引用符か？
13AA-27 04           797 ( 3)         beq     :1
13AC-C1 27           798 ( 2)         cmpb    #$27            ; 二重引用符か？
13AE-26 19           799 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
13B0-17              800 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
13B1-                801            ; // 終端の引用符をチェック
13B1-3C              802 ( 5)         pshx
13B2-08              803 ( 1) .check  inx
13B3-E6 00           804 ( 4)         ldab    0,x
13B5-27 14           805 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
13B7-11              806 ( 1)         cba
13B8-26 F8           807 ( 3)         bne     :check
13BA-38              808 ( 4)         pulx
13BB-                809            ; // 文字列の出力
13BB-08              810 ( 1) .loop   inx
13BC-E6 00           811 ( 4)         ldab    0,x
13BE-11              812 ( 1)         cba                     ; 保存した引用符との比較
13BF-27 05           813 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
13C1-BD FF AC        814 ( 6)         jsr     write_char
13C4-20 F5           815 ( 3)         bra     :loop
13C6-08              816 ( 1) .true   inx
13C7-0D              817 ( 1)         sec
13C8-39              818 ( 5)         rts
13C9-0C              819 ( 1) .false  clc
13CA-39              820 ( 5)         rts
13CB-86 0A           821 ( 2) .err10  ldaa    #10             ; "Print statement error"
13CD-7E 15 4F        822 ( 3)         jmp     write_err_msg
13D0-                823
13D0-                824
13D0-                825      ; -----------------------------------------------------------------------
13D0-                826      ; タブを出力する
13D0-                827      ; Write tabs
13D0-                828      ;【引数】なし
13D0-                829      ;【使用】B
13D0-                830      ;【返値】なし
13D0-                831      ; -----------------------------------------------------------------------
13D0-                832      write_tab:
13D0-BD FF B5        833 ( 6) .top    jsr     write_space
13D3-7B 07 39        834 ( 4)         tim     #7,<TabCount
13D6-26 F8           835 ( 3)         bne     :top
13D8-39              836 ( 5)         rts
13D9-                837
13D9-                838
13D9-                839      ; -----------------------------------------------------------------------
13D9-                840      ; 式を評価して変数に値を代入する
13D9-                841      ; Evaluate an expression and assign a value to a variable
13D9-                842      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
13D9-                843      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
13D9-                844      ;【返値】D:Integer X:次の実行位置アドレス
13D9-                845      ; -----------------------------------------------------------------------
13D9-                846      assign_to_var:
13D9-BD 13 9C        847 ( 6)         jsr     skip_space
13DC-BD 10 D6        848 ( 6)         jsr     eval_expression
13DF-24 07           849 ( 3)         bcc     :err04
13E1-3C              850 ( 5)         pshx                    ; 実行位置アドレスを退避
13E2-DE 8B           851 ( 4)         ldx     <VariableAddr
13E4-ED 00           852 ( 5)         std     0,x             ; 変数に結果を保存
13E6-38              853 ( 4)         pulx                    ; 実行位置アドレスを復帰
13E7-39              854 ( 5)         rts
13E8-86 04           855 ( 2) .err04  ldaa    #4              ; "Illegal expression"
13EA-7E 15 4F        856 ( 3)         jmp     write_err_msg
13ED-                857
13ED-                858
13ED-                859      ; -----------------------------------------------------------------------
13ED-                860      ; listコマンドを実行する
13ED-                861      ; Execute 'list' command
13ED-                862      ;【引数】なし
13ED-                863      ;【使用】A, B, X
13ED-                864      ;【返値】なし
13ED-                865      ; -----------------------------------------------------------------------
13ED-                866      exe_list:
13ED-CE 04 00        867 ( 3)         ldx     #USERAREATOP
13F0-                868            ; // 行番号出力
13F0-EC 00           869 ( 5) .loop   ldd     0,x
13F2-27 11           870 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
13F4-3C              871 ( 5)         pshx
13F5-BD 13 3E        872 ( 6)         jsr     write_integer
13F8-38              873 ( 4)         pulx
13F9-                874            ; // 本文出力
13F9-08              875 ( 1)         inx                     ; 本文までスキップ
13FA-08              876 ( 1)         inx
13FB-08              877 ( 1)         inx
13FC-BD FF AF        878 ( 6)         jsr     write_line
13FF-BD FF B2        879 ( 6)         jsr     write_crlf
1402-08              880 ( 1)         inx                     ; 次の行番号へ
1403-20 EB           881 ( 3)         bra     :loop
1405-7E 10 1A        882 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1408-                883
1408-                884
1408-                885      ; -----------------------------------------------------------------------
1408-                886      ; Print文を実行する
1408-                887      ; Execute 'print' statement
1408-                888      ;【引数】X:実行位置アドレス
1408-                889      ;【使用】B, X（下位ルーチンでA）
1408-                890      ;【返値】なし
1408-                891      ; -----------------------------------------------------------------------
1408-                892      exe_print:
1408-72 01 8F        893 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
140B-BD 13 9C        894 ( 6) .loop   jsr     skip_space
140E-27 37           895 ( 3)         beq     :finish         ; 終端文字なら改行して終了
1410-BD 13 A8        896 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1413-25 1B           897 ( 3)         bcs     :nlon
1415-BD 10 D6        898 ( 6)         jsr     eval_expression
1418-25 11           899 ( 3)         bcs     :int
141A-                900            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
141A-                901            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
141A-C1 3B           902 ( 2) .check  cmpb    #';'
141C-27 23           903 ( 3)         beq     :nloff
141E-C1 2C           904 ( 2)         cmpb    #','
1420-27 1C           905 ( 3)         beq     :tab
1422-C1 3A           906 ( 2)         cmpb    #':'
1424-27 21           907 ( 3)         beq     :finish
1426-86 04           908 ( 2)         ldaa    #4              ; "Illegal expression"
1428-7E 15 4F        909 ( 3)         jmp     write_err_msg
142B-3C              910 ( 5) .int    pshx                    ; 実行位置アドレスを退避
142C-BD 13 3E        911 ( 6)         jsr     write_integer   ; 評価した式を出力
142F-38              912 ( 4)         pulx                    ; 実行位置アドレスを復帰
1430-72 01 8F        913 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1433-BD 13 9C        914 ( 6)         jsr     skip_space
1436-C1 3B           915 ( 2)         cmpb    #';'
1438-27 07           916 ( 3)         beq     :nloff
143A-C1 2C           917 ( 2)         cmpb    #','
143C-26 09           918 ( 3)         bne     :finish
143E-BD 13 D0        919 ( 6) .tab    jsr     write_tab       ; タブ出力
1441-7F 00 8F        920 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
1444-08              921 ( 1)         inx                     ; 次の文字へ
1445-20 C4           922 ( 3)         bra     :loop
1447-7D 00 8F        923 ( 4) .finish tst     <NewLineFlag
144A-27 03           924 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
144C-BD FF B2        925 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
144F-7E 10 80        926 ( 3) .end    jmp     is_multi
1452-                927
1452-                928
1452-                929      ; -----------------------------------------------------------------------
1452-                930      ; input文を実行する
1452-                931      ; Execute 'input' statement
1452-                932      ; -----------------------------------------------------------------------
1452-                933      exe_input:
1452-BD 13 9C        934 ( 6)         jsr     skip_space
1455-27 31           935 ( 3)         beq     :end            ; 終端文字なら改行して終了
1457-BD 13 A8        936 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
145A-24 0A           937 ( 3)         bcc     :1
145C-E6 00           938 ( 4)         ldab    0,x
145E-C1 3B           939 ( 2)         cmpb    #';'
1460-26 29           940 ( 3)         bne     :err00
1462-08              941 ( 1)         inx
1463-BD 13 9C        942 ( 6)         jsr     skip_space
1466-BD 13 87        943 ( 6) .1      jsr     is_variable
1469-24 20           944 ( 3)         bcc     :err00
146B-86 01           945 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
146D-58              946 ( 1)         aslb                    ; B = 変数領域の下位バイト
146E-DD 8B           947 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1470-                948            ; // 変数の後に余計な文字がないか確認
1470-                949            ; // 例えば "input a+b" など
1470-DF 8D           950 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
1472-BD 13 9C        951 ( 6)         jsr     skip_space
1475-27 06           952 ( 3)         beq     :read           ; 終端文字なら入力へ
1477-C1 3A           953 ( 2)         cmpb    #':'            ; ":"なら入力へ
1479-26 10           954 ( 3)         bne     :err00          ; それ以外の文字ならエラー
147B-DE 8D           955 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
147D-BD FF A9        956 ( 6) .read   jsr     read_line
1480-CE 01 00        957 ( 3)         ldx     #Rx_BUFFER
1483-BD 13 D9        958 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
1486-DE 8D           959 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1488-7E 10 80        960 ( 3) .end    jmp     is_multi
148B-4F              961 ( 1) .err00  clra                    ; "Syntax error"
148C-7E 15 4F        962 ( 3)         jmp     write_err_msg
148F-                963
148F-                964
148F-                965      ; -----------------------------------------------------------------------
148F-                966      ; if文を実行する
148F-                967      ; Execute 'if' statement
148F-                968      ;【引数】X:実行位置アドレス
148F-                969      ;【使用】B, X
148F-                970      ;【返値】なし
148F-                971      ; -----------------------------------------------------------------------
148F-BD 13 9C        972 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
1492-27 0B           973 ( 3)         beq     :end            ; 終端文字なら終了
1494-BD 10 D6        974 ( 6)         jsr     eval_expression ; 式評価
1497-24 09           975 ( 3)         bcc     :err04
1499-5D              976 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
149A-27 03           977 ( 3)         beq     :end
149C-7E 10 93        978 ( 3)         jmp     exe_line        ; True
149F-7E 10 1A        979 ( 3) .end    jmp     tb_main         ; Falseならば全て無視され行末まで進む
14A2-86 04           980 ( 2) .err04  ldaa    #4              ; "Illegal expression"
14A4-7E 15 4F        981 ( 3)         jmp     write_err_msg
14A7-                982
14A7-                983
14A7-                984      ; ------------------------------------------------
14A7-                985      ; ブロック転送
14A7-                986      ; Copy memory
14A7-                987      ;【引数】Source:転送元アドレス
14A7-                988      ;        Destination:転送先アドレス
14A7-                989      ;        Bytes:転送バイト数
14A7-                990      ;【使用】A, B, X, R0
14A7-                991      ;【返値】なし
14A7-                992      ; ------------------------------------------------
14A7-                993      mem_copy:
009D-                994      .Offset .eq     UR0
14A7-DC 94           995 ( 4)         ldd     <Bytes
14A9-27 33           996 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
14AB-                997            ; // オフセットの計算
14AB-DC 92           998 ( 4)         ldd     <Destination    ; dst - src
14AD-93 90           999 ( 4)         subd    <Source
14AF-DD 9D          1000 ( 4)         std     <:Offset        ; offset = dst - src
14B1-               1001            ; // 終了判定用のアドレスを計算
14B1-DC 90          1002 ( 4)         ldd     <Source
14B3-D3 94          1003 ( 4)         addd    <Bytes          ; src + bytes = 転元終了アドレス
14B5-DD 92          1004 ( 4)         std     <Destination    ; 転送終了アドレスを代入
14B7-               1005            ; // 転送開始
14B7-DE 90          1006 ( 4)         ldx     <Source         ; 転送開始アドレスを代入
14B9-               1007            ; // 転送するバイト数が奇数か偶数か判断。
14B9-               1008            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
14B9-DC 94          1009 ( 4)         ldd     <Bytes
14BB-04             1010 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
14BC-24 0E          1011 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
14BE-               1012            ; // Byte転送
14BE-A6 00          1013 ( 4)         ldaa    0,x             ; A <- [source]
14C0-18             1014 ( 2)         xgdx                    ; D = address, X = data
14C1-D3 9D          1015 ( 4)         addd    <:Offset        ; src - offset = dst
14C3-18             1016 ( 2)         xgdx                    ; D = data, X = address
14C4-A7 00          1017 ( 4)         staa    0,x             ; [dst] <- A
14C6-18             1018 ( 2)         xgdx                    ; D = address, X = data
14C7-93 9D          1019 ( 4)         subd    <:Offset        ; dst + offset = src
14C9-18             1020 ( 2)         xgdx                    ; D = data, X = address
14CA-20 0D          1021 ( 3)         bra     :odd
14CC-               1022            ; // Word転送
14CC-EC 00          1023 ( 5) .loop   ldd     0,x
14CE-18             1024 ( 2)         xgdx
14CF-D3 9D          1025 ( 4)         addd    <:Offset
14D1-18             1026 ( 2)         xgdx
14D2-ED 00          1027 ( 5)         std     0,x
14D4-18             1028 ( 2)         xgdx
14D5-93 9D          1029 ( 4)         subd    <:Offset
14D7-18             1030 ( 2)         xgdx
14D8-08             1031 ( 1)         inx
14D9-08             1032 ( 1) .odd    inx
14DA-9C 92          1033 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
14DC-26 EE          1034 ( 3)         bne     :loop
14DE-39             1035 ( 5) .end    rts
14DF-               1036
14DF-               1037
14DF-               1038      ; -----------------------------------------------------------------------
14DF-               1039      ; テーブル検索
14DF-               1040      ; Search the keyword table
14DF-               1041      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
14DF-               1042      ;【使用】A, B, X
14DF-               1043      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
14DF-               1044      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
14DF-               1045      ; -----------------------------------------------------------------------
14DF-               1046      search_table:
14DF-EC 05          1047 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
14E1-91 A5          1048 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
14E3-26 2F          1049 ( 3)         bne     :false
14E5-D1 A6          1050 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
14E7-26 2B          1051 ( 3)         bne     :false
14E9-EC 07          1052 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
14EB-4D             1053 ( 1)         tsta                    ; $00（終端記号）か？
14EC-27 1B          1054 ( 3)         beq     :true
14EE-91 A7          1055 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
14F0-26 22          1056 ( 3)         bne     :false
14F2-5D             1057 ( 1)         tstb                    ; $00（終端記号）か？
14F3-27 14          1058 ( 3)         beq     :true
14F5-D1 A8          1059 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
14F7-26 1B          1060 ( 3)         bne     :false
14F9-EC 09          1061 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
14FB-4D             1062 ( 1)         tsta                    ; $00（終端記号）か？
14FC-27 0B          1063 ( 3)         beq     :true
14FE-91 A9          1064 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
1500-26 12          1065 ( 3)         bne     :false
1502-5D             1066 ( 1)         tstb                    ; $00（終端記号）か？
1503-27 04          1067 ( 3)         beq     :true
1505-D1 AA          1068 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
1507-26 0B          1069 ( 3)         bne     :false
1509-E6 02          1070 ( 4) .true   ldab    2,x             ; B = 語長
150B-EE 03          1071 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
150D-31             1072 ( 1)         ins                     ; 元のリターンアドレスを削除
150E-31             1073 ( 1)         ins
150F-3C             1074 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1510-DE 8D          1075 ( 4)         ldx     <ExePointer
1512-3A             1076 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1513-39             1077 ( 5)         rts                     ; 命令ルーチンにジャンプ
1514-EE 00          1078 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1516-26 C7          1079 ( 3)         bne     :top
1518-DE 8D          1080 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
151A-0C             1081 ( 1)         clc                     ; false: C=0
151B-39             1082 ( 5)         rts
151C-               1083
151C-               1084
151C-               1085      ; ***********************************************************************
151C-               1086      ;   キーワードテーブル Keyword table
151C-               1087      ; ***********************************************************************
151C-               1088      ; レコードの構造 Record structure
151C-               1089      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
151C-               1090      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
151C-               1091      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
151C-               1092      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
151C-               1093      ; キーワードは2文字以上6文字以下
151C-               1094      CMD_TABLE
151C-15 25          1095      .new            .dw     :list
151E-03             1096                      .db     3
151F-10 03          1097                      .dw     cold_start
1521-6E 65 77 00    1098                      .az     "new"
1525-15 2F          1099      .list           .dw     SMT_TABLE:print
1527-04             1100                      .db     4
1528-13 ED          1101                      .dw     exe_list
152A-6C 69 73 74 
     00             1102                      .az     "list"
152F-               1103      SMT_TABLE
152F-15 3A          1104      .print          .dw     :input
1531-05             1105                      .db     5
1532-14 08          1106                      .dw     exe_print
1534-70 72 69 6E 
     74 00          1107                      .az     "print"
153A-15 45          1108      .input          .dw     :if
153C-05             1109                      .db     5
153D-14 52          1110                      .dw     exe_input
153F-69 6E 70 75 
     74 00          1111                      .az     "input"
1545-15 4D          1112      .if             .dw     :bottom
1547-02             1113                      .db     2
1548-14 8F          1114                      .dw     exe_if
154A-69 66 00       1115                      .az     "if"
154D-00 00          1116      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
154F-               1117
154F-               1118
154F-               1119      ; -----------------------------------------------------------------------
154F-               1120      ; エラーメッセージを表示する
154F-               1121      ; Write Error Messege
154F-               1122      ;【引数】A: エラーコード
154F-               1123      ;【使用】A, B, X
154F-               1124      ;【返値】なし
154F-               1125      ; -----------------------------------------------------------------------
154F-               1126      write_err_msg:
154F-7D 00 39       1127 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
1552-27 03          1128 ( 3)         beq     :1
1554-BD FF B2       1129 ( 6)         jsr     write_crlf
1557-CE 15 70       1130 ( 3) .1      ldx     #ERRMSG
155A-BD FF AF       1131 ( 6)         jsr     write_line
155D-16             1132 ( 1)         tab
155E-CE 15 78       1133 ( 3)         ldx     #ERRCODE
1561-3A             1134 ( 1)         abx
1562-EE 00          1135 ( 5)         ldx     0,x
1564-BD FF AF       1136 ( 6)         jsr     write_line
1567-BD FF B2       1137 ( 6)         jsr     write_crlf
156A-DE 80          1138 ( 4)         ldx     <StackPointer
156C-35             1139 ( 1)         txs
156D-7E 10 1A       1140 ( 3)         jmp     tb_main
1570-               1141
1570-45 52 52 4F 
     52 3A 20 00    1142      ERRMSG  .az     "ERROR: "
1578-15 88          1143      ERRCODE .dw     .err00
157A-15 95          1144              .dw     .err02
157C-15 A8          1145              .dw     .err04
157E-15 BB          1146              .dw     .err06
1580-15 D4          1147              .dw     .err08
1582-15 E0          1148              .dw     .err10
1584-15 F6          1149              .dw     .err12
1586-16 0A          1150              .dw     .err14
1588-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1151      .err00  .az     "Syntax error"
1595-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1152      .err02  .az     "Out of range value"
15A8-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1153      .err04  .az     "Illegal expression"
15BB-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1154      .err06  .az     "Calculate stack overflow"
15D4-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1155      .err08  .az     "Zero Divide"
15E0-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1156      .err10  .az     "Print statement error"
15F6-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1157      .err12  .az     "Invalid line number"
160A-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1158      .err14  .az     "Memory size over"
161B-               1159
161B-               1160
161B-               1161      ; ***********************************************************************
161B-               1162      ;   デバック用ルーチン Debugging routines
161B-               1163      ; ***********************************************************************
161B-               1164      ; -----------------------------------------------------------------------
161B-               1165      ; ユーザーレジスタを表示する
161B-               1166      ; Display user registers
161B-               1167      ; -----------------------------------------------------------------------
161B-36             1168 ( 4) PUTUR:  psha
161C-37             1169 ( 4)         pshb
161D-3C             1170 ( 5)         pshx
161E-CE 16 51       1171 ( 3)         ldx     #:MSGUR0
1621-BD FF AF       1172 ( 6)         jsr     write_line
1624-DC 9D          1173 ( 4)         ldd     <UR0
1626-BD FF BB       1174 ( 6)         jsr     write_word
1629-CE 16 56       1175 ( 3)         ldx     #:MSGUR1
162C-BD FF AF       1176 ( 6)         jsr     write_line
162F-DC 9F          1177 ( 4)         ldd     <UR1
1631-BD FF BB       1178 ( 6)         jsr     write_word
1634-CE 16 5C       1179 ( 3)         ldx     #:MSGUR2
1637-BD FF AF       1180 ( 6)         jsr     write_line
163A-DC A1          1181 ( 4)         ldd     <UR2
163C-BD FF BB       1182 ( 6)         jsr     write_word
163F-CE 16 62       1183 ( 3)         ldx     #:MSGUR3
1642-BD FF AF       1184 ( 6)         jsr     write_line
1645-DC A3          1185 ( 4)         ldd     <UR3
1647-BD FF BB       1186 ( 6)         jsr     write_word
164A-BD FF B2       1187 ( 6)         jsr     write_crlf
164D-38             1188 ( 4)         pulx
164E-33             1189 ( 3)         pulb
164F-32             1190 ( 3)         pula
1650-39             1191 ( 5)         rts
1651-55 52 30 3D 
     00             1192      .MSGUR0          .az     "UR0="
1656-20 55 52 31 
     3D 00          1193      .MSGUR1          .az     " UR1="
165C-20 55 52 32 
     3D 00          1194      .MSGUR2          .az     " UR2="
1662-20 55 52 33 
     3D 00          1195      .MSGUR3          .az     " UR3="
