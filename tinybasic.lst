0000-                 14
0000-                 15      ; ********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0000-                 46
0020-                 47      RAM_START       .eq     $0020
1FFF-                 48      RAM_END         .eq     $1fff
E000-                 49      ROM_START       .eq     $e000
FFFF-                 50      ROM_END         .eq     $ffff
0FFF-                 51      STACK           .eq     $0fff
0000-                 52
1000-                 53      PROGRAM_START   .eq     $1000
0100-                 54      Rx_BUFFER       .eq     $0100   ; SCI Rx Buffer ($0100-0148,73byte)
0148-                 55      Rx_BUFFER_END   .eq     $0148   ; 73byte（72character）
0149-                 56      CSTACK          .eq     $0149   ; 計算スタック (Calculate stack, 40byte)
01C2-                 57      VARIABLE        .eq     $01c2   ; 変数26文字 ($01c2-01f5, 52byte)
0400-                 58      USERAREATOP     .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 59      USERAREABTM     .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 60
0000-                 61      ; ***********************************************************************
0000-                 62      ;   システム変数 System variables
0000-                 63      ; ***********************************************************************
0000-                 64              .sm     RAM
0020-                 65              .or     $20
0020-                 66
0020-                 67      ; Interrupt Vector Hooking
0020-                 68      VEC_TRAP        .bs     3
0023-                 69      VEC_SCI         .bs     3
0026-                 70      VEC_TOF         .bs     3
0029-                 71      VEC_OCF         .bs     3
002C-                 72      VEC_ICF         .bs     3
002F-                 73      VEC_IRQ         .bs     3
0032-                 74      VEC_SWI         .bs     3
0035-                 75      VEC_NMI         .bs     3
0038-                 76      BreakPointFlag  .bs     1
0039-                 77      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 78      ; General-Purpose Registers
003A-                 79      R0              .bs     2
003C-                 80      R1              .bs     2
003E-                 81
003E-                 82      ; ***********************************************************************
003E-                 83      ;   変数 Variables
003E-                 84      ; ***********************************************************************
003E-                 85              .sm     RAM
0080-                 86              .or     $80
0080-                 87
0080-                 88      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                 89      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                 90      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                 91      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                 92      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                 93      Divisor         .bs     2       ; 除数
0089-                 94      Remainder       .bs     2       ; 剰余
008B-                 95      VariableAddr    .bs     2       ; 変数のアドレス
008D-                 96      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                 97      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                 98      Source          .bs     2       ; 転送元アドレス
0092-                 99      Destination     .bs     2       ; 転送先アドレス
0094-                100      Bytes           .bs     2       ; 転送バイト数
0096-                101      LineNumber      .bs     2       ; 行番号
0098-                102      LineLength      .bs     2       ; 行の長さ
009A-                103      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                104
009C-                105      ; General-Purpose Registers
009C-                106      UR0             *
009C-                107      UR0H            .bs     1
009D-                108      UR0L            .bs     1
009E-                109      UR1             *
009E-                110      UR1H            .bs     1
009F-                111      UR1L            .bs     1
00A0-                112      UR2             *
00A0-                113      UR2H            .bs     1
00A1-                114      UR2L            .bs     1
00A2-                115      UR3             *
00A2-                116      UR3H            .bs     1
00A3-                117      UR3L            .bs     1
00A4-                118      ; Work area
00A4-                119      COMPARE         .bs     6       ; 文字列比較用バッファ
00AA-                120
00AA-                121      ; ***********************************************************************
00AA-                122      ;   Program Start
00AA-                123      ; ***********************************************************************
0000-                124              .sm     CODE
1000-                125              .or     PROGRAM_START
1000-                126
1000-                127      init_tinybasic:
1000-30              128 ( 1)         tsx
1001-DF 80           129 ( 4)         stx     <StackPointer
1003-                130
1003-                131
1003-                132      cold_start:
1003-CE 04 00        133 ( 3)         ldx     #USERAREATOP
1006-DF 9A           134 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              135 ( 1)         clra
1009-5F              136 ( 1)         clrb
100A-ED 00           137 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           138 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                139
100E-                140
100E-                141      tb_main:
100E-C6 3E           142 ( 2)         ldab    #'>'
1010-BD FF AC        143 ( 6)         jsr     write_char
1013-BD FF A9        144 ( 6)         jsr     read_line
1016-CE 01 00        145 ( 3)         ldx     #Rx_BUFFER      ; 実行位置アドレスをセット
1019-                146            ; // 行番号判定
1019-BD 12 BA        147 ( 6)         jsr     get_int_from_decimal
101C-24 0A           148 ( 3)         bcc     direct_mode     ; 先頭が数値でなければダイレクトモード
101E-83 00 00        149 ( 3)         subd    #0
1021-2E 08           150 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
1023-86 0C           151 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1025-7E 15 08        152 ( 3)         jmp     write_err_msg
1028-                153
1028-                154      direct_mode:
1028-7E 10 84        155 ( 3)         jmp     exe_line
102B-                156
102B-                157      edit_mode:
102B-DF 8D           158 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
102D-DD 96           159 ( 4)         std     <LineNumber     ; 行番号を保存
102F-                160            ; // 行の長さを取得
102F-86 04           161 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1031-E6 00           162 ( 4) .loop   ldab    0,x
1033-27 04           163 ( 3)         beq     :1
1035-4C              164 ( 1)         inca                    ; 行の長さを+1
1036-08              165 ( 1)         inx                     ; バッファアドレスを+1
1037-20 F8           166 ( 3)         bra     :loop
1039-97 99           167 ( 3) .1      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
103B-                168            ; // 転送の準備
103B-DE 9A           169 ( 4)         ldx     <PrgmEndAddr    ; X <- プログラムの最終アドレス
103D-DC 9A           170 ( 4)         ldd     <PrgmEndAddr
103F-D3 98           171 ( 4)         addd    <LineLength     ; D <- 行の長さを足した最終アドレス
1041-18              172 ( 2)         xgdx
1042-8C 0D FD        173 ( 3)         cpx     #USERAREABTM    ; ユーザーエリアを超えていないかチェック
1045-18              174 ( 2)         xgdx
1046-24 24           175 ( 3)         bcc     :err14          ; "Memory size over"
1048-DD 9A           176 ( 4)         std     <PrgmEndAddr    ; 新しい最終アドレスを設定
104A-                177            ; // 行番号と行の長さを転送
104A-DC 96           178 ( 4)         ldd     <LineNumber     ; 行番号を取得
104C-ED 00           179 ( 5)         std     0,x
104E-08              180 ( 1)         inx
104F-08              181 ( 1)         inx
1050-D6 99           182 ( 3)         ldab    <LineLength+1   ; 行の長さを取得
1052-E7 00           183 ( 4)         stab    0,x
1054-                184            ; // mem_copyの引数を設定
1054-08              185 ( 1)         inx
1055-DF 92           186 ( 4)         stx     <Destination    ; 転送先アドレス（行の長さの直後）を設定
1057-4F              187 ( 1)         clra                    ; LineLengthの上位バイトをゼロにする
1058-C0 03           188 ( 2)         subb    #3              ; LineLengthから行番号・行の長さの3バイト分を引く
105A-DD 94           189 ( 4)         std     <Bytes          ; 転送バイト数を設定
105C-DC 8D           190 ( 4)         ldd     <ExePointer     ; 行番号の直後を指しているバッファアドレスを復帰
105E-DD 90           191 ( 4)         std     <Source         ; 転送元アドレスを設定
1060-BD 14 73        192 ( 6)         jsr     mem_copy
1063-                193            ; // 終端行の挿入
1063-DE 9A           194 ( 4)         ldx     <PrgmEndAddr
1065-4F              195 ( 1)         clra
1066-5F              196 ( 1)         clrb
1067-ED 00           197 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
1069-7E 10 0E        198 ( 3)         jmp     tb_main
106C-86 0E           199 ( 2) .err14  ldaa    #14              ; "Memory size over"
106E-7E 15 08        200 ( 3)         jmp     write_err_msg
1071-                201
1071-                202
1071-                203      ; -----------------------------------------------------------------------
1071-                204      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1071-                205      ; Is a multi statement mark?
1071-                206      ;【引数】X:実行位置アドレス
1071-                207      ;【使用】B, X
1071-                208      ;【返値】なし
1071-                209      ; -----------------------------------------------------------------------
1071-                210      is_multi:
1071-BD 13 83        211 ( 6)         jsr     skip_space
1074-27 07           212 ( 3)         beq     :end
1076-C1 3A           213 ( 2)         cmpb    #':'
1078-26 06           214 ( 3)         bne     :err00
107A-08              215 ( 1)         inx
107B-20 07           216 ( 3)         bra     exe_line
107D-7E 10 0E        217 ( 3) .end    jmp     tb_main
1080-4F              218 ( 1) .err00  clra                    ; "Syntax error"
1081-7E 15 08        219 ( 3)         jmp     write_err_msg
1084-                220
1084-                221
1084-                222      ; -----------------------------------------------------------------------
1084-                223      ; 一行実行
1084-                224      ; Execute one line
1084-                225      ;【引数】X:実行位置アドレス
1084-                226      ;【使用】A, B, X
1084-                227      ;【返値】なし
1084-                228      ; -----------------------------------------------------------------------
1084-                229      exe_line:
1084-BD 13 83        230 ( 6)         jsr     skip_space
1087-27 2D           231 ( 3)         beq     :end            ; 終端文字（$00）ならば終了
1089-                232            ; // 代入文のチェック
1089-BD 13 6E        233 ( 6)         jsr     is_variable     ; 変数か？
108C-24 12           234 ( 3)         bcc     :cmd            ; No. テーブル検索へ
108E-86 01           235 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1090-58              236 ( 1)         aslb                    ; B = 変数領域の下位バイト
1091-DD 8B           237 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1093-BD 13 83        238 ( 6)         jsr     skip_space      ; Yes. 代入文か？
1096-C1 3D           239 ( 2)         cmpb    #'='
1098-26 1F           240 ( 3)         bne     :err00          ; No. エラー処理へ
109A-08              241 ( 1)         inx                     ; Yes. 代入実行
109B-BD 13 C0        242 ( 6)         jsr     assign_to_var
109E-20 D1           243 ( 3)         bra     is_multi
10A0-EC 00           244 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
10A2-DD A4           245 ( 4)         std     <COMPARE
10A4-EC 02           246 ( 5)         ldd     2,x
10A6-DD A6           247 ( 4)         std     <COMPARE+2
10A8-EC 04           248 ( 5)         ldd     4,x
10AA-DD A8           249 ( 4)         std     <COMPARE+4
10AC-DF 8D           250 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
10AE-CE 14 E8        251 ( 3)         ldx     #SMT_TABLE      ; 文字列テーブルアドレスをセット
10B1-BD 14 AB        252 ( 6)         jsr     search_table    ; テーブル検索実行
10B4-24 03           253 ( 3)         bcc     :err00
10B6-7E 10 0E        254 ( 3) .end    jmp     tb_main
10B9-                255
10B9-4F              256 ( 1) .err00  clra                    ; syntax error.
10BA-7E 15 08        257 ( 3)         jmp     write_err_msg
10BD-                258
10BD-                259
10BD-                260      ; -----------------------------------------------------------------------
10BD-                261      ; 式を評価する
10BD-                262      ; Evaluate the expression
10BD-                263      ;【引数】B:アスキーコード X:実行位置アドレス
10BD-                264      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
10BD-                265      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
10BD-                266      ;        偽(C=0) / X:現在の実行位置アドレス
10BD-                267      ; -----------------------------------------------------------------------
10BD-                268      eval_expression:
00A0-                269      .SP     .eq     UR2
00A2-                270      .X      .eq     UR3
10BD-                271            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
10BD-DF A2           272 ( 4)         stx     <:X
10BF-30              273 ( 1)         tsx
10C0-DF A0           274 ( 4)         stx     <:SP
10C2-DE A2           275 ( 4)         ldx     <:X
10C4-                276            ; // 計算スタックの初期化
10C4-CC 01 72        277 ( 3)         ldd     #CSTACK+40+1    ; 40byte分
10C7-DD 82           278 ( 4)         std     <CStackPtr
10C9-                279            ; // 式評価開始
10C9-8D 08           280 ( 5)         bsr     expr_4th
10CB-                281            ; // 計算結果をスタックトップから取り出す
10CB-3C              282 ( 5)         pshx
10CC-DE 82           283 ( 4)         ldx     <CStackPtr
10CE-EC 00           284 ( 5)         ldd     0,x
10D0-38              285 ( 4)         pulx
10D1-0D              286 ( 1)         sec                     ; true:C=1
10D2-39              287 ( 5)         rts
10D3-                288
10D3-                289      expr_4th:
10D3-8D 50           290 ( 5)         bsr     expr_3rd
10D5-BD 13 83        291 ( 6) .loop   jsr     skip_space
10D8-C1 3D           292 ( 2)         cmpb    #'='            ; '='?
10DA-26 08           293 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
10DC-08              294 ( 1)         inx
10DD-8D 46           295 ( 5)         bsr     expr_3rd
10DF-BD 12 6D        296 ( 6)         jsr     CS_eq           ; EQual to
10E2-20 F1           297 ( 3)         bra     :loop
10E4-C1 3C           298 ( 2) .ltsign cmpb    #'<'            ; '<'?
10E6-26 22           299 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
10E8-08              300 ( 1)         inx
10E9-E6 00           301 ( 4)         ldab    0,x
10EB-C1 3E           302 ( 2)         cmpb    #'>'            ; '<>'?
10ED-26 08           303 ( 3)         bne     :lte
10EF-08              304 ( 1)         inx
10F0-8D 33           305 ( 5)         bsr     expr_3rd
10F2-BD 12 8E        306 ( 6)         jsr     CS_ne           ; Not Equal to
10F5-20 DE           307 ( 3)         bra     :loop
10F7-C1 3D           308 ( 2) .lte    cmpb    #'='            ; '<='?
10F9-26 08           309 ( 3)         bne     :lt
10FB-08              310 ( 1)         inx
10FC-8D 27           311 ( 5)         bsr     expr_3rd
10FE-BD 12 83        312 ( 6)         jsr     CS_lte          ; Less Than or Equal to
1101-20 D2           313 ( 3)         bra     :loop
1103-8D 20           314 ( 5) .lt     bsr     expr_3rd
1105-BD 12 78        315 ( 6)         jsr     CS_lt           ; Less Than
1108-20 CB           316 ( 3)         bra     :loop
110A-C1 3E           317 ( 2) .gtsign cmpb    #'>'            ; '>'?
110C-26 16           318 ( 3)         bne     :end
110E-08              319 ( 1)         inx
110F-E6 00           320 ( 4)         ldab    0,x
1111-C1 3D           321 ( 2)         cmpb    #'='            ; '>='?
1113-26 08           322 ( 3)         bne     :gt
1115-08              323 ( 1)         inx
1116-8D 0D           324 ( 5)         bsr     expr_3rd
1118-BD 12 A4        325 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
111B-20 B8           326 ( 3)         bra     :loop
111D-8D 06           327 ( 5) .gt     bsr     expr_3rd
111F-BD 12 99        328 ( 6)         jsr     CS_gt           ; Greater Than
1122-20 B1           329 ( 3)         bra     :loop
1124-39              330 ( 5) .end    rts
1125-                331
1125-                332      expr_3rd:
1125-8D 1C           333 ( 5)         bsr     expr_2nd
1127-BD 13 83        334 ( 6) .loop   jsr     skip_space
112A-C1 2B           335 ( 2)         cmpb    #'+'
112C-26 08           336 ( 3)         bne     :minus
112E-08              337 ( 1)         inx
112F-8D 12           338 ( 5)         bsr     expr_2nd
1131-BD 11 B8        339 ( 6)         jsr     CS_add
1134-20 F1           340 ( 3)         bra     :loop
1136-C1 2D           341 ( 2) .minus  cmpb    #'-'
1138-26 08           342 ( 3)         bne     :end
113A-08              343 ( 1)         inx
113B-8D 06           344 ( 5)         bsr     expr_2nd
113D-BD 11 C1        345 ( 6)         jsr     CS_sub
1140-20 E5           346 ( 3)         bra     :loop
1142-39              347 ( 5) .end    rts
1143-                348
1143-                349      expr_2nd:
1143-8D 28           350 ( 5)         bsr     expr_1st
1145-BD 13 83        351 ( 6) .loop   jsr     skip_space
1148-C1 2A           352 ( 2)         cmpb    #'*'
114A-26 08           353 ( 3)         bne     :div
114C-08              354 ( 1)         inx
114D-8D 1E           355 ( 5)         bsr     expr_1st
114F-BD 11 CA        356 ( 6)         jsr     CS_mul
1152-20 F1           357 ( 3)         bra     :loop
1154-C1 2F           358 ( 2) .div    cmpb    #'/'
1156-26 08           359 ( 3)         bne     :mod
1158-08              360 ( 1)         inx
1159-8D 12           361 ( 5)         bsr     expr_1st
115B-BD 11 E7        362 ( 6)         jsr     CS_div
115E-20 E5           363 ( 3)         bra     :loop
1160-C1 25           364 ( 2) .mod    cmpb    #'%'
1162-26 08           365 ( 3)         bne     :end
1164-08              366 ( 1)         inx
1165-8D 06           367 ( 5)         bsr     expr_1st
1167-BD 12 03        368 ( 6)         jsr     CS_mod
116A-20 D9           369 ( 3)         bra     :loop
116C-39              370 ( 5) .end    rts
116D-                371
116D-                372      expr_1st:
00A0-                373      .SP     .eq     UR2
00A2-                374      .X      .eq     UR3
116D-BD 13 83        375 ( 6)         jsr     skip_space
1170-BD 12 BA        376 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
1173-24 02           377 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
1175-20 1D           378 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1177-BD 13 6E        379 ( 6) .var    jsr     is_variable     ; 変数か？
117A-24 0A           380 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
117C-                381            ; // 変数値の取得
117C-3C              382 ( 5)         pshx                    ; 実行位置アドレスを退避
117D-86 01           383 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
117F-58              384 ( 1)         aslb                    ; B = 変数領域の下位バイト
1180-18              385 ( 2)         xgdx                    ; X = 変数のアドレス
1181-EC 00           386 ( 5)         ldd     0,x             ; D <- 変数の値
1183-38              387 ( 4)         pulx                    ; 実行位置アドレスを復帰
1184-20 0E           388 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
1186-C1 28           389 ( 2) .paren  cmpb    #'('
1188-26 1A           390 ( 3)         bne     :err
118A-08              391 ( 1)         inx
118B-BD 10 D3        392 ( 6)         jsr     expr_4th
118E-C1 29           393 ( 2)         cmpb    #')'
1190-26 12           394 ( 3)         bne     :err
1192-08              395 ( 1)         inx
1193-39              396 ( 5)         rts
1194-3C              397 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1195-DE 82           398 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1197-09              399 ( 1)         dex
1198-09              400 ( 1)         dex
1199-8C 01 47        401 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
119C-25 0D           402 ( 3)         bcs     :err06
119E-ED 00           403 ( 5)         std     0,x
11A0-DF 82           404 ( 4)         stx     <CStackPtr
11A2-38              405 ( 4)         pulx                    ; 実行位置アドレスを復帰
11A3-39              406 ( 5)         rts
11A4-                407            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
11A4-DE A0           408 ( 4) .err    ldx     <:SP
11A6-35              409 ( 1)         txs
11A7-DE A2           410 ( 4)         ldx     <:X
11A9-0C              411 ( 1)         clc                     ; false:C=0
11AA-39              412 ( 5)         rts
11AB-86 06           413 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
11AD-7E 15 08        414 ( 3)         jmp     write_err_msg
11B0-                415
11B0-                416      ;
11B0-                417      ; Arithmetic operator
11B0-                418      ;
11B0-                419      CS_store:
11B0-08              420 ( 1)         inx
11B1-08              421 ( 1)         inx
11B2-ED 00           422 ( 5)         std     0,x
11B4-DF 82           423 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
11B6-38              424 ( 4)         pulx                    ; 実行位置アドレスを復帰
11B7-39              425 ( 5)         rts
11B8-                426
11B8-3C              427 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
11B9-DE 82           428 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11BB-EC 02           429 ( 5)         ldd     2,x
11BD-E3 00           430 ( 5)         addd    0,x
11BF-20 EF           431 ( 3)         bra     CS_store
11C1-                432
11C1-3C              433 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
11C2-DE 82           434 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11C4-EC 02           435 ( 5)         ldd     2,x
11C6-A3 00           436 ( 5)         subd    0,x
11C8-20 E6           437 ( 3)         bra     CS_store
11CA-                438
11CA-                439      CS_mul:
009C-                440      .Result         .eq     UR0
11CA-3C              441 ( 5)         pshx                    ; 実行位置アドレスを退避
11CB-DE 82           442 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11CD-                443              ; B * D
11CD-A6 03           444 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
11CF-E6 01           445 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
11D1-3D              446 ( 7)         mul                     ; B * D
11D2-DD 9C           447 ( 4)         std     <:Result        ;「B*D」を保存
11D4-                448              ; A * D
11D4-EC 01           449 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
11D6-3D              450 ( 7)         mul                     ; A * D
11D7-DB 9C           451 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
11D9-D7 9C           452 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
11DB-                453              ; C * B
11DB-A6 00           454 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
11DD-E6 03           455 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
11DF-3D              456 ( 7)         mul                     ; C * B
11E0-DB 9C           457 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
11E2-17              458 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
11E3-D6 9D           459 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
11E5-20 C9           460 ( 3)         bra     CS_store
11E7-                461
11E7-                462      ;
11E7-                463      ; 符号付き割り算の考え方
11E7-                464      ; ・剰余は除数の符号と同一
11E7-                465      ;   ・ 7 / 3  = 商  2、剰余  1
11E7-                466      ;   ・-7 / 3  = 商 -3、剰余  2
11E7-                467      ;   ・ 7 / -3 = 商 -3、剰余 -2
11E7-                468      ;   ・-7 / -3 = 商  2、剰余 -1
11E7-                469      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
11E7-                470      ;       2.ただし、除数がゼロの場合は1は足さない
11E7-                471      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
11E7-                472      ;         除数の絶対値から剰余の絶対値を引く
11E7-                473      ;       2.その結果を除数と同じ符号にする
11E7-                474      ;       3.ただし、除数がゼロの場合は剰余もゼロ
11E7-                475      ;
11E7-3C              476 ( 5) CS_div: pshx                    ; 実行位置アドレスを退避
11E8-DE 82           477 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11EA-8D 37           478 ( 5)         bsr     div_uint        ; 除算実行
11EC-18              479 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
11ED-7D 00 85        480 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
11F0-27 0D           481 ( 3)         beq     :end            ; '+'なら終了
11F2-8C 00 00        482 ( 3)         cpx     #0              ; 剰余はゼロか？
11F5-27 03           483 ( 3)         beq     :sign
11F7-C3 00 01        484 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
11FA-43              485 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
11FB-53              486 ( 1)         comb
11FC-C3 00 01        487 ( 3)         addd    #1
11FF-DE 82           488 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1201-20 AD           489 ( 3)         bra     CS_store
1203-                490
1203-3C              491 ( 5) CS_mod: pshx                    ; 実行位置アドレスを退避
1204-DE 82           492 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1206-8D 1B           493 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1208-DD 89           494 ( 4)         std     <Remainder      ; 剰余はゼロか？
120A-27 13           495 ( 3)         beq     :end            ; ゼロであれば終了
120C-7D 00 85        496 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
120F-27 04           497 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
1211-DC 87           498 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1213-93 89           499 ( 4)         subd    <Remainder
1215-7D 00 86        500 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1218-27 05           501 ( 3)         beq     :end            ; '+'なら終了
121A-43              502 ( 1)         coma                    ; '-'なら2の補数にする
121B-53              503 ( 1)         comb
121C-C3 00 01        504 ( 3)         addd    #1
121F-DE 82           505 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1221-20 8D           506 ( 3)         bra     CS_store
1223-                507
1223-                508      div_uint:
009C-                509      .Counter        .eq     UR0H
1223-EC 00           510 ( 5)         ldd     0,x             ; ゼロ除算チェック
1225-27 41           511 ( 3)         beq     :err08          ; 除数がゼロならエラー
1227-5F              512 ( 1)         clrb
1228-D7 85           513 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
122A-D7 86           514 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
122C-C6 10           515 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
122E-D7 9C           516 ( 3)         stab    <:Counter
1230-                517              ; // 剰余の符号フラグの設定
1230-EC 00           518 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1232-2A 03           519 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1234-7C 00 86        520 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1237-                521              ; // 商の符号フラグの設定
1237-A8 02           522 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
1239-2A 03           523 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
123B-7C 00 85        524 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
123E-                525              ; // 除数を絶対値にする
123E-EC 00           526 ( 5) .2      ldd     0,x             ; D <- 除数
1240-2A 05           527 ( 3)         bpl     :3
1242-43              528 ( 1)         coma                    ; 除数が負なら絶対値にする
1243-53              529 ( 1)         comb
1244-C3 00 01        530 ( 3)         addd    #1
1247-DD 87           531 ( 4) .3      std     <Divisor        ; 除数を保存
1249-                532              ; // 非除数を絶対値にする
1249-EC 02           533 ( 5)         ldd     2,x             ; D <- 被除数
124B-2A 05           534 ( 3)         bpl     :4
124D-43              535 ( 1)         coma                    ; 被除数が負なら絶対値にする
124E-53              536 ( 1)         comb
124F-C3 00 01        537 ( 3)         addd    #1
1252-                538              ; // 除算実行
1252-18              539 ( 2) .4      xgdx                    ; X <- 被除数
1253-4F              540 ( 1)         clra                    ; D（WORK）をクリア
1254-5F              541 ( 1)         clrb
1255-18              542 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
1256-05              543 ( 1)         asld
1257-18              544 ( 2)         xgdx
1258-59              545 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
1259-49              546 ( 1)         rola
125A-93 87           547 ( 4)         subd    <Divisor        ; WORK - 除数
125C-08              548 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
125D-24 03           549 ( 3)         bcc     :5              ; WORKから除数を引けた？
125F-D3 87           550 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1261-09              551 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1262-7A 00 9C        552 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1265-26 EE           553 ( 3)         bne     :loop
1267-39              554 ( 5)         rts
1268-86 08           555 ( 2) .err08  ldaa    #8              ; "Zero Divide"
126A-7E 15 08        556 ( 3)         jmp     write_err_msg
126D-                557
126D-3C              558 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
126E-DE 82           559 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1270-EC 02           560 ( 5)         ldd     2,x
1272-A3 00           561 ( 5)         subd    0,x
1274-27 39           562 ( 3)         beq     CS_true
1276-20 3D           563 ( 3)         bra     CS_false
1278-                564
1278-3C              565 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1279-DE 82           566 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
127B-EC 02           567 ( 5)         ldd     2,x
127D-A3 00           568 ( 5)         subd    0,x
127F-2D 2E           569 ( 3)         blt     CS_true
1281-20 32           570 ( 3)         bra     CS_false
1283-                571
1283-3C              572 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1284-DE 82           573 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1286-EC 02           574 ( 5)         ldd     2,x
1288-A3 00           575 ( 5)         subd    0,x
128A-2F 23           576 ( 3)         ble     CS_true
128C-20 27           577 ( 3)         bra     CS_false
128E-                578
128E-3C              579 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
128F-DE 82           580 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1291-EC 02           581 ( 5)         ldd     2,x
1293-A3 00           582 ( 5)         subd    0,x
1295-26 18           583 ( 3)         bne     CS_true
1297-20 1C           584 ( 3)         bra     CS_false
1299-                585
1299-3C              586 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
129A-DE 82           587 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
129C-EC 02           588 ( 5)         ldd     2,x
129E-A3 00           589 ( 5)         subd    0,x
12A0-2E 0D           590 ( 3)         bgt     CS_true
12A2-20 11           591 ( 3)         bra     CS_false
12A4-                592
12A4-3C              593 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
12A5-DE 82           594 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12A7-EC 02           595 ( 5)         ldd     2,x
12A9-A3 00           596 ( 5)         subd    0,x
12AB-2C 02           597 ( 3)         bge     CS_true
12AD-20 06           598 ( 3)         bra     CS_false
12AF-                599
12AF-                600      CS_true:
12AF-CC 00 01        601 ( 3)         ldd     #1
12B2-7E 11 B0        602 ( 3)         jmp     CS_store
12B5-                603
12B5-                604      CS_false:
12B5-4F              605 ( 1)         clra
12B6-5F              606 ( 1)         clrb
12B7-7E 11 B0        607 ( 3)         jmp     CS_store
12BA-                608
12BA-                609      ; -----------------------------------------------------------------------
12BA-                610      ; テキストバッファの10進文字列から数値を取得する
12BA-                611      ; Get a integer from a decimal string in a text buffer
12BA-                612      ;【引数】X:バッファアドレス
12BA-                613      ;【使用】A, B, X, UR0, UR1
12BA-                614      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
12BA-                615      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
12BA-                616      ; -----------------------------------------------------------------------
12BA-                617      get_int_from_decimal:
009C-                618      .RetValue       .eq     UR0     ; Return Value
009E-                619      .TempValue      .eq     UR1     ; Temporary Value
12BA-4F              620 ( 1)         clra
12BB-5F              621 ( 1)         clrb
12BC-DD 9C           622 ( 4)         std     <:RetValue
12BE-97 9E           623 ( 3)         staa    <:TempValue
12C0-97 84           624 ( 3)         staa    <SignFlag
12C2-E6 00           625 ( 4)         ldab    0,x             ; 1文字取得
12C4-C1 2D           626 ( 2)         cmpb    #'-'            ; マイナス記号か？
12C6-26 05           627 ( 3)         bne     :1
12C8-7C 00 84        628 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
12CB-20 0B           629 ( 3)         bra     :next
12CD-C1 2B           630 ( 2) .1      cmpb    #'+'            ; プラス記号か？
12CF-27 07           631 ( 3)         beq     :next
12D1-BD FF C1        632 ( 6)         jsr     is_decimal_char ; 数字か？
12D4-24 36           633 ( 3)         bcc     :false          ; No. C=1で終了
12D6-20 13           634 ( 3)         bra     :first
12D8-08              635 ( 1) .next   inx                     ; 符号の次の1文字を取得
12D9-E6 00           636 ( 4)         ldab    0,x
12DB-BD FF C1        637 ( 6)         jsr     is_decimal_char ; 数字か？
12DE-24 40           638 ( 3)         bcc     :err04          ; No. エラー処理へ
12E0-20 09           639 ( 3)         bra     :first          ; Yes. これが最初の数字
12E2-DD 9C           640 ( 4) .loop   std     <:RetValue      ; 結果を退避
12E4-E6 00           641 ( 4)         ldab    0,x             ; 1文字取得
12E6-BD FF C1        642 ( 6)         jsr     is_decimal_char ; 数字か？
12E9-24 14           643 ( 3)         bcc     :end
12EB-C0 30           644 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
12ED-D7 9F           645 ( 3)         stab    <:TempValue+1
12EF-                646            ; // RetValue * 10 + TempValue
12EF-DC 9C           647 ( 4)         ldd     <:RetValue
12F1-05              648 ( 1)         asld                    ; * 2
12F2-05              649 ( 1)         asld                    ; * 4
12F3-D3 9C           650 ( 4)         addd    <:RetValue      ; * 5
12F5-05              651 ( 1)         asld                    ; * 10
12F6-D3 9E           652 ( 4)         addd    <:TempValue     ; += TempValue
12F8-08              653 ( 1)         inx                     ; ポインタを進める
12F9-25 20           654 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
12FB-2B 10           655 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
12FD-20 E3           656 ( 3)         bra     :loop
12FF-DC 9C           657 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
1301-7D 00 84        658 ( 4)         tst     <SignFlag       ; 符号チェック
1304-27 05           659 ( 3)         beq     :true
1306-43              660 ( 1)         coma                    ; 負なら2の補数に
1307-53              661 ( 1)         comb
1308-C3 00 01        662 ( 3)         addd    #1
130B-0D              663 ( 1) .true   sec
130C-39              664 ( 5) .false  rts
130D-                665
130D-                666      .overflow
130D-                667            ; // -32,768かどうかの判定
130D-18              668 ( 2)         xgdx
130E-8C 80 00        669 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
1311-18              670 ( 2)         xgdx
1312-26 07           671 ( 3)         bne     :err02          ; No. 範囲外
1314-7D 00 84        672 ( 4)         tst     <SignFlag       ; 符号チェック
1317-27 02           673 ( 3)         beq     :err02          ; 正ならば範囲外
1319-20 C7           674 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
131B-                675
131B-86 02           676 ( 2) .err02  ldaa    #2              ; "Out of range"
131D-7E 15 08        677 ( 3)         jmp     write_err_msg
1320-86 04           678 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1322-7E 15 08        679 ( 3)         jmp     write_err_msg
1325-                680
1325-                681
1325-                682      ; -----------------------------------------------------------------------
1325-                683      ; Dレジスタの数値をコンソールに出力する
1325-                684      ; Write Decimal Character converted from Integer
1325-                685      ;【引数】D:Integer
1325-                686      ;【使用】A, B, X
1325-                687      ;【返値】なし
1325-                688      ; -----------------------------------------------------------------------
1325-                689      write_integer:
009C-                690      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
009D-                691      .Counter        .eq     UR0L    ; 桁カウンター
1325-2A 0C           692 ( 3)         bpl     :plus           ; 符号判定
1327-37              693 ( 4)         pshb                    ; 負数なら'-'を出力する
1328-C6 2D           694 ( 2)         ldab    #'-'
132A-BD FF AC        695 ( 6)         jsr     write_char
132D-33              696 ( 3)         pulb
132E-43              697 ( 1)         coma                    ; 絶対値にする（2の補数にする）
132F-53              698 ( 1)         comb
1330-C3 00 01        699 ( 3)         addd    #1
1333-7F 00 9C        700 ( 5) .plus   clr     <:ZeroSuppress
1336-CE 13 66        701 ( 3)         ldx     #:CONST
1339-7F 00 9D        702 ( 5) .loop   clr     <:Counter
133C-A3 00           703 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
133E-25 05           704 ( 3)         bcs     :write
1340-7C 00 9D        705 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1343-20 F7           706 ( 3)         bra     :digit
1345-                707
1345-E3 00           708 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1347-37              709 ( 4)         pshb
1348-D6 9D           710 ( 3)         ldab    <:Counter
134A-27 03           711 ( 3)         beq     :1              ; この桁はゼロか？
134C-7C 00 9C        712 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
134F-7D 00 9C        713 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1352-27 05           714 ( 3)         beq     :2              ; No. この桁は表示しない
1354-CB 30           715 ( 2)         addb    #$30            ; Yes. この桁を表示する
1356-BD FF AC        716 ( 6)         jsr     write_char
1359-33              717 ( 3) .2      pulb
135A-08              718 ( 1)         inx                     ; 次の引く数へ
135B-08              719 ( 1)         inx
135C-8C 13 6E        720 ( 3)         cpx     #:CONST+8
135F-26 D8           721 ( 3)         bne     :loop
1361-CB 30           722 ( 2)         addb    #$30            ; 一の桁の数値を表示
1363-7E FF AC        723 ( 3)         jmp     write_char
1366-                724      ; Dから引いていく数
1366-27 10           725      .CONST  .dw     $2710           ; 10,000
1368-03 E8           726              .dw     $03e8           ; 1,000
136A-00 64           727              .dw     $0064           ; 100
136C-00 0A           728              .dw     $000a           ; 10
136E-                729
136E-                730
136E-                731      ; -----------------------------------------------------------------------
136E-                732      ; テキストバッファの英文字が変数か判定する
136E-                733      ; Is a character retrieved from a text buffer a variable?
136E-                734      ;【引数】X:バッファアドレス
136E-                735      ;【使用】A, B, X
136E-                736      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
136E-                737      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
136E-                738      ; -----------------------------------------------------------------------
136E-                739      is_variable:
136E-E6 00           740 ( 4)         ldab    0,x
1370-BD FF BE        741 ( 6)         jsr     is_alphabetic_char
1373-24 0D           742 ( 3)         bcc     :end
1375-17              743 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1376-E6 01           744 ( 4)         ldab    1,x                     ; 2文字目を取得
1378-BD FF BE        745 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
137B-16              746 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
137C-24 02           747 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
137E-0C              748 ( 1)         clc                             ; Yes. 変数ではない。C=0
137F-39              749 ( 5)         rts
1380-08              750 ( 1) .var    inx                             ; ポインタを進める
1381-0D              751 ( 1)         sec                             ; C=1
1382-39              752 ( 5) .end    rts
1383-                753
1383-                754
1383-                755      ; -----------------------------------------------------------------------
1383-                756      ; 空白を読み飛ばす
1383-                757      ; Skip Space
1383-                758      ;【引数】X:実行位置アドレス
1383-                759      ;【使用】B, X
1383-                760      ;【返値】B:アスキーコード（$00の時Z=1）
1383-                761      ;        X:実行位置アドレス
1383-                762      ; -----------------------------------------------------------------------
1383-                763      skip_space:
1383-E6 00           764 ( 4)         ldab    0,x
1385-27 07           765 ( 3)         beq     :end
1387-C1 20           766 ( 2)         cmpb    #SPACE
1389-22 03           767 ( 3)         bhi     :end
138B-08              768 ( 1)         inx
138C-20 F5           769 ( 3)         bra     skip_space
138E-39              770 ( 5) .end    rts
138F-                771
138F-                772
138F-                773      ; -----------------------------------------------------------------------
138F-                774      ; 引用符付きの文字列を出力する
138F-                775      ; Write Quoted Stirng
138F-                776      ;【引数】B:アスキーコード X:実行位置アドレス
138F-                777      ;【使用】A, B, X
138F-                778      ;【返値】真(C=1) / X:次の実行位置アドレス
138F-                779      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
138F-                780      ; -----------------------------------------------------------------------
138F-                781      write_quoted_str:
138F-C1 22           782 ( 2)         cmpb    #$22            ; 一重引用符か？
1391-27 04           783 ( 3)         beq     :1
1393-C1 27           784 ( 2)         cmpb    #$27            ; 二重引用符か？
1395-26 19           785 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
1397-17              786 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
1398-                787            ; // 終端の引用符をチェック
1398-3C              788 ( 5)         pshx
1399-08              789 ( 1) .check  inx
139A-E6 00           790 ( 4)         ldab    0,x
139C-27 14           791 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
139E-11              792 ( 1)         cba
139F-26 F8           793 ( 3)         bne     :check
13A1-38              794 ( 4)         pulx
13A2-                795            ; // 文字列の出力
13A2-08              796 ( 1) .loop   inx
13A3-E6 00           797 ( 4)         ldab    0,x
13A5-11              798 ( 1)         cba                     ; 保存した引用符との比較
13A6-27 05           799 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
13A8-BD FF AC        800 ( 6)         jsr     write_char
13AB-20 F5           801 ( 3)         bra     :loop
13AD-08              802 ( 1) .true   inx
13AE-0D              803 ( 1)         sec
13AF-39              804 ( 5)         rts
13B0-0C              805 ( 1) .false  clc
13B1-39              806 ( 5)         rts
13B2-86 0A           807 ( 2) .err10  ldaa    #10             ; "Print statement error"
13B4-7E 15 08        808 ( 3)         jmp     write_err_msg
13B7-                809
13B7-                810
13B7-                811      ; -----------------------------------------------------------------------
13B7-                812      ; タブを出力する
13B7-                813      ; Write tabs
13B7-                814      ;【引数】なし
13B7-                815      ;【使用】B
13B7-                816      ;【返値】なし
13B7-                817      ; -----------------------------------------------------------------------
13B7-                818      write_tab:
13B7-BD FF B5        819 ( 6) .top    jsr     write_space
13BA-7B 07 39        820 ( 4)         tim     #7,<TabCount
13BD-26 F8           821 ( 3)         bne     :top
13BF-39              822 ( 5)         rts
13C0-                823
13C0-                824
13C0-                825      ; -----------------------------------------------------------------------
13C0-                826      ; 式を評価して変数に値を代入する
13C0-                827      ; Evaluate an expression and assign a value to a variable
13C0-                828      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
13C0-                829      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
13C0-                830      ;【返値】D:Integer X:次の実行位置アドレス
13C0-                831      ; -----------------------------------------------------------------------
13C0-                832      assign_to_var:
13C0-BD 13 83        833 ( 6)         jsr     skip_space
13C3-BD 10 BD        834 ( 6)         jsr     eval_expression
13C6-24 07           835 ( 3)         bcc     :err04
13C8-3C              836 ( 5)         pshx                    ; 実行位置アドレスを退避
13C9-DE 8B           837 ( 4)         ldx     <VariableAddr
13CB-ED 00           838 ( 5)         std     0,x             ; 変数に結果を保存
13CD-38              839 ( 4)         pulx                    ; 実行位置アドレスを復帰
13CE-39              840 ( 5)         rts
13CF-86 04           841 ( 2) .err04  ldaa    #4              ; "Illegal expression"
13D1-7E 15 08        842 ( 3)         jmp     write_err_msg
13D4-                843
13D4-                844
13D4-                845      ; -----------------------------------------------------------------------
13D4-                846      ; Print文を実行する
13D4-                847      ; Execute 'print' statement
13D4-                848      ;【引数】X:実行位置アドレス
13D4-                849      ;【使用】B, X（下位ルーチンでA）
13D4-                850      ;【返値】なし
13D4-                851      ; -----------------------------------------------------------------------
13D4-                852      exe_print:
13D4-72 01 8F        853 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
13D7-BD 13 83        854 ( 6) .loop   jsr     skip_space
13DA-27 37           855 ( 3)         beq     :finish         ; 終端文字なら改行して終了
13DC-BD 13 8F        856 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
13DF-25 1B           857 ( 3)         bcs     :nlon
13E1-BD 10 BD        858 ( 6)         jsr     eval_expression
13E4-25 11           859 ( 3)         bcs     :int
13E6-                860            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
13E6-                861            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
13E6-C1 3B           862 ( 2) .check  cmpb    #';'
13E8-27 23           863 ( 3)         beq     :nloff
13EA-C1 2C           864 ( 2)         cmpb    #','
13EC-27 1C           865 ( 3)         beq     :tab
13EE-C1 3A           866 ( 2)         cmpb    #':'
13F0-27 21           867 ( 3)         beq     :finish
13F2-86 04           868 ( 2)         ldaa    #4              ; "Illegal expression"
13F4-7E 15 08        869 ( 3)         jmp     write_err_msg
13F7-3C              870 ( 5) .int    pshx                    ; 実行位置アドレスを退避
13F8-BD 13 25        871 ( 6)         jsr     write_integer   ; 評価した式を出力
13FB-38              872 ( 4)         pulx                    ; 実行位置アドレスを復帰
13FC-72 01 8F        873 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
13FF-BD 13 83        874 ( 6)         jsr     skip_space
1402-C1 3B           875 ( 2)         cmpb    #';'
1404-27 07           876 ( 3)         beq     :nloff
1406-C1 2C           877 ( 2)         cmpb    #','
1408-26 09           878 ( 3)         bne     :finish
140A-BD 13 B7        879 ( 6) .tab    jsr     write_tab       ; タブ出力
140D-7F 00 8F        880 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
1410-08              881 ( 1)         inx                     ; 次の文字へ
1411-20 C4           882 ( 3)         bra     :loop
1413-7D 00 8F        883 ( 4) .finish tst     <NewLineFlag
1416-27 03           884 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1418-BD FF B2        885 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
141B-7E 10 71        886 ( 3) .end    jmp     is_multi
141E-                887
141E-                888
141E-                889      ; -----------------------------------------------------------------------
141E-                890      ; input文を実行する
141E-                891      ; Execute 'input' statement
141E-                892      ; -----------------------------------------------------------------------
141E-                893      exe_input:
141E-BD 13 83        894 ( 6)         jsr     skip_space
1421-27 31           895 ( 3)         beq     :end            ; 終端文字なら改行して終了
1423-BD 13 8F        896 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1426-24 0A           897 ( 3)         bcc     :1
1428-E6 00           898 ( 4)         ldab    0,x
142A-C1 3B           899 ( 2)         cmpb    #';'
142C-26 29           900 ( 3)         bne     :err00
142E-08              901 ( 1)         inx
142F-BD 13 83        902 ( 6)         jsr     skip_space
1432-BD 13 6E        903 ( 6) .1      jsr     is_variable
1435-24 20           904 ( 3)         bcc     :err00
1437-86 01           905 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1439-58              906 ( 1)         aslb                    ; B = 変数領域の下位バイト
143A-DD 8B           907 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
143C-                908            ; // 変数の後に余計な文字がないか確認
143C-                909            ; // 例えば "input a+b" など
143C-DF 8D           910 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
143E-BD 13 83        911 ( 6)         jsr     skip_space
1441-27 06           912 ( 3)         beq     :read           ; 終端文字なら入力へ
1443-C1 3A           913 ( 2)         cmpb    #':'            ; ":"なら入力へ
1445-26 10           914 ( 3)         bne     :err00          ; それ以外の文字ならエラー
1447-DE 8D           915 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1449-BD FF A9        916 ( 6) .read   jsr     read_line
144C-CE 01 00        917 ( 3)         ldx     #Rx_BUFFER
144F-BD 13 C0        918 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
1452-DE 8D           919 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1454-7E 10 71        920 ( 3) .end    jmp     is_multi
1457-4F              921 ( 1) .err00  clra                    ; "Syntax error"
1458-7E 15 08        922 ( 3)         jmp     write_err_msg
145B-                923
145B-                924
145B-                925      ; -----------------------------------------------------------------------
145B-                926      ; if文を実行する
145B-                927      ; Execute 'if' statement
145B-                928      ;【引数】X:実行位置アドレス
145B-                929      ;【使用】B, X
145B-                930      ;【返値】なし
145B-                931      ; -----------------------------------------------------------------------
145B-BD 13 83        932 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
145E-27 0B           933 ( 3)         beq     :end            ; 終端文字なら終了
1460-BD 10 BD        934 ( 6)         jsr     eval_expression ; 式評価
1463-24 09           935 ( 3)         bcc     :err04
1465-5D              936 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
1466-27 03           937 ( 3)         beq     :end
1468-7E 10 84        938 ( 3)         jmp     exe_line        ; True
146B-7E 10 0E        939 ( 3) .end    jmp     tb_main         ; Falseならば全て無視され行末まで進む
146E-86 04           940 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1470-7E 15 08        941 ( 3)         jmp     write_err_msg
1473-                942
1473-                943
1473-                944      ; ------------------------------------------------
1473-                945      ; ブロック転送
1473-                946      ; Copy memory
1473-                947      ;【引数】Source:転送元アドレス
1473-                948      ;        Destination:転送先アドレス
1473-                949      ;        Bytes:転送バイト数
1473-                950      ;【使用】A, B, X, R0
1473-                951      ;【返値】なし
1473-                952      ; ------------------------------------------------
1473-                953      mem_copy:
009C-                954      .Offset .eq     UR0
1473-DC 94           955 ( 4)         ldd     <Bytes
1475-27 33           956 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
1477-                957            ; // オフセットの計算
1477-DC 92           958 ( 4)         ldd     <Destination    ; dst - src
1479-93 90           959 ( 4)         subd    <Source
147B-DD 9C           960 ( 4)         std     <:Offset        ; offset = dst - src
147D-                961            ; // 終了判定用のアドレスを計算
147D-DC 90           962 ( 4)         ldd     <Source
147F-D3 94           963 ( 4)         addd    <Bytes          ; src + bytes = 転元終了アドレス
1481-DD 92           964 ( 4)         std     <Destination    ; 転送終了アドレスを代入
1483-                965            ; // 転送開始
1483-DE 90           966 ( 4)         ldx     <Source         ; 転送開始アドレスを代入
1485-                967            ; // 転送するバイト数が奇数か偶数か判断。
1485-                968            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
1485-DC 94           969 ( 4)         ldd     <Bytes
1487-04              970 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
1488-24 0E           971 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
148A-                972            ; // Byte転送
148A-A6 00           973 ( 4)         ldaa    0,x             ; A <- [source]
148C-18              974 ( 2)         xgdx                    ; D = address, X = data
148D-D3 9C           975 ( 4)         addd    <:Offset        ; src - offset = dst
148F-18              976 ( 2)         xgdx                    ; D = data, X = address
1490-A7 00           977 ( 4)         staa    0,x             ; [dst] <- A
1492-18              978 ( 2)         xgdx                    ; D = address, X = data
1493-93 9C           979 ( 4)         subd    <:Offset        ; dst + offset = src
1495-18              980 ( 2)         xgdx                    ; D = data, X = address
1496-20 0D           981 ( 3)         bra     :odd
1498-                982            ; // Word転送
1498-EC 00           983 ( 5) .loop   ldd     0,x
149A-18              984 ( 2)         xgdx
149B-D3 9C           985 ( 4)         addd    <:Offset
149D-18              986 ( 2)         xgdx
149E-ED 00           987 ( 5)         std     0,x
14A0-18              988 ( 2)         xgdx
14A1-93 9C           989 ( 4)         subd    <:Offset
14A3-18              990 ( 2)         xgdx
14A4-08              991 ( 1)         inx
14A5-08              992 ( 1) .odd    inx
14A6-9C 92           993 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
14A8-26 EE           994 ( 3)         bne     :loop
14AA-39              995 ( 5) .end    rts
14AB-                996
14AB-                997
14AB-                998      ; -----------------------------------------------------------------------
14AB-                999      ; テーブル検索
14AB-               1000      ; Search the keyword table
14AB-               1001      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
14AB-               1002      ;【使用】A, B, X
14AB-               1003      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
14AB-               1004      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
14AB-               1005      ; -----------------------------------------------------------------------
14AB-               1006      search_table:
14AB-EC 05          1007 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
14AD-91 A4          1008 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
14AF-26 2F          1009 ( 3)         bne     :false
14B1-D1 A5          1010 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
14B3-26 2B          1011 ( 3)         bne     :false
14B5-EC 07          1012 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
14B7-4D             1013 ( 1)         tsta                    ; $00（終端記号）か？
14B8-27 1B          1014 ( 3)         beq     :true
14BA-91 A6          1015 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
14BC-26 22          1016 ( 3)         bne     :false
14BE-5D             1017 ( 1)         tstb                    ; $00（終端記号）か？
14BF-27 14          1018 ( 3)         beq     :true
14C1-D1 A7          1019 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
14C3-26 1B          1020 ( 3)         bne     :false
14C5-EC 09          1021 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
14C7-4D             1022 ( 1)         tsta                    ; $00（終端記号）か？
14C8-27 0B          1023 ( 3)         beq     :true
14CA-91 A8          1024 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
14CC-26 12          1025 ( 3)         bne     :false
14CE-5D             1026 ( 1)         tstb                    ; $00（終端記号）か？
14CF-27 04          1027 ( 3)         beq     :true
14D1-D1 A9          1028 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
14D3-26 0B          1029 ( 3)         bne     :false
14D5-E6 02          1030 ( 4) .true   ldab    2,x             ; B = 語長
14D7-EE 03          1031 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
14D9-31             1032 ( 1)         ins                     ; 元のリターンアドレスを削除
14DA-31             1033 ( 1)         ins
14DB-3C             1034 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
14DC-DE 8D          1035 ( 4)         ldx     <ExePointer
14DE-3A             1036 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
14DF-39             1037 ( 5)         rts                     ; 命令ルーチンにジャンプ
14E0-EE 00          1038 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
14E2-26 C7          1039 ( 3)         bne     :top
14E4-DE 8D          1040 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
14E6-0C             1041 ( 1)         clc                     ; false: C=0
14E7-39             1042 ( 5)         rts
14E8-               1043
14E8-               1044
14E8-               1045      ; ***********************************************************************
14E8-               1046      ;   キーワードテーブル Keyword table
14E8-               1047      ; ***********************************************************************
14E8-               1048      ; レコードの構造 Record structure
14E8-               1049      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
14E8-               1050      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
14E8-               1051      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
14E8-               1052      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
14E8-               1053      ; キーワードは2文字以上6文字以下
14E8-               1054      SMT_TABLE:      .eq     *
14E8-14 F3          1055      .print          .dw     :input
14EA-05             1056                      .db     5
14EB-13 D4          1057                      .dw     exe_print
14ED-70 72 69 6E 
     74 00          1058                      .az     "print"
14F3-14 FE          1059      .input          .dw     :if
14F5-05             1060                      .db     5
14F6-14 1E          1061                      .dw     exe_input
14F8-69 6E 70 75 
     74 00          1062                      .az     "input"
14FE-15 06          1063      .if             .dw     :bottom
1500-02             1064                      .db     2
1501-14 5B          1065                      .dw     exe_if
1503-69 66 00       1066                      .az     "if"
1506-00 00          1067      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
1508-               1068
1508-               1069
1508-               1070      ; -----------------------------------------------------------------------
1508-               1071      ; エラーメッセージを表示する
1508-               1072      ; Write Error Messege
1508-               1073      ;【引数】A: エラーコード
1508-               1074      ;【使用】A, B, X
1508-               1075      ;【返値】なし
1508-               1076      ; -----------------------------------------------------------------------
1508-               1077      write_err_msg:
1508-7D 00 39       1078 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
150B-27 03          1079 ( 3)         beq     :1
150D-BD FF B2       1080 ( 6)         jsr     write_crlf
1510-CE 15 29       1081 ( 3) .1      ldx     #ERRMSG
1513-BD FF AF       1082 ( 6)         jsr     write_line
1516-16             1083 ( 1)         tab
1517-CE 15 31       1084 ( 3)         ldx     #ERRCODE
151A-3A             1085 ( 1)         abx
151B-EE 00          1086 ( 5)         ldx     0,x
151D-BD FF AF       1087 ( 6)         jsr     write_line
1520-BD FF B2       1088 ( 6)         jsr     write_crlf
1523-DE 80          1089 ( 4)         ldx     <StackPointer
1525-35             1090 ( 1)         txs
1526-7E 10 0E       1091 ( 3)         jmp     tb_main
1529-               1092
1529-45 52 52 4F 
     52 3A 20 00    1093      ERRMSG  .az     "ERROR: "
1531-15 41          1094      ERRCODE .dw     .err00
1533-15 4E          1095              .dw     .err02
1535-15 61          1096              .dw     .err04
1537-15 74          1097              .dw     .err06
1539-15 8D          1098              .dw     .err08
153B-15 99          1099              .dw     .err10
153D-15 AF          1100              .dw     .err12
153F-15 C3          1101              .dw     .err14
1541-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1102      .err00  .az     "Syntax error"
154E-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1103      .err02  .az     "Out of range value"
1561-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1104      .err04  .az     "Illegal expression"
1574-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1105      .err06  .az     "Calculate stack overflow"
158D-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1106      .err08  .az     "Zero Divide"
1599-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1107      .err10  .az     "Print statement error"
15AF-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1108      .err12  .az     "Invalid line number"
15C3-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1109      .err14  .az     "Memory size over"
15D4-               1110
15D4-               1111
15D4-               1112      ; ***********************************************************************
15D4-               1113      ;   デバック用ルーチン Debugging routines
15D4-               1114      ; ***********************************************************************
15D4-               1115      ; -----------------------------------------------------------------------
15D4-               1116      ; ユーザーレジスタを表示する
15D4-               1117      ; Display user registers
15D4-               1118      ; -----------------------------------------------------------------------
15D4-36             1119 ( 4) PUTUR:  psha
15D5-37             1120 ( 4)         pshb
15D6-3C             1121 ( 5)         pshx
15D7-CE 16 0A       1122 ( 3)         ldx     #:MSGUR0
15DA-BD FF AF       1123 ( 6)         jsr     write_line
15DD-DC 9C          1124 ( 4)         ldd     <UR0
15DF-BD FF BB       1125 ( 6)         jsr     write_word
15E2-CE 16 0F       1126 ( 3)         ldx     #:MSGUR1
15E5-BD FF AF       1127 ( 6)         jsr     write_line
15E8-DC 9E          1128 ( 4)         ldd     <UR1
15EA-BD FF BB       1129 ( 6)         jsr     write_word
15ED-CE 16 15       1130 ( 3)         ldx     #:MSGUR2
15F0-BD FF AF       1131 ( 6)         jsr     write_line
15F3-DC A0          1132 ( 4)         ldd     <UR2
15F5-BD FF BB       1133 ( 6)         jsr     write_word
15F8-CE 16 1B       1134 ( 3)         ldx     #:MSGUR3
15FB-BD FF AF       1135 ( 6)         jsr     write_line
15FE-DC A2          1136 ( 4)         ldd     <UR3
1600-BD FF BB       1137 ( 6)         jsr     write_word
1603-BD FF B2       1138 ( 6)         jsr     write_crlf
1606-38             1139 ( 4)         pulx
1607-33             1140 ( 3)         pulb
1608-32             1141 ( 3)         pula
1609-39             1142 ( 5)         rts
160A-55 52 30 3D 
     00             1143      .MSGUR0          .az     "UR0="
160F-20 55 52 31 
     3D 00          1144      .MSGUR1          .az     " UR1="
1615-20 55 52 32 
     3D 00          1145      .MSGUR2          .az     " UR2="
161B-20 55 52 33 
     3D 00          1146      .MSGUR3          .az     " UR3="
