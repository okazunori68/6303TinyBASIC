0000-                 14
0000-                 15      ; ***********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ***********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ***********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0011-                 46      XON             .eq     $11     ; DC1
0013-                 47      XOFF            .eq     $13     ; DC3
0000-                 48
0020-                 49      RAM_START       .eq     $0020
1FFF-                 50      RAM_END         .eq     $1fff
E000-                 51      ROM_START       .eq     $e000
FFFF-                 52      ROM_END         .eq     $ffff
1000-                 53      PROGRAM_START   .eq     $1000   ; プログラム開始アドレス
0FFF-                 54      STACK           .eq     $0fff
0000-                 55
0400-                 56      USER_AREA_TOP   .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 57      USER_AREA_BTM   .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 58
0000-                 59      ; ***********************************************************************
0000-                 60      ;   システム変数 System variables
0000-                 61      ; ***********************************************************************
0000-                 62              .sm     RAM
0020-                 63              .or     $20
0020-                 64
0020-                 65      ; Interrupt Vector Hooking
0020-                 66      VEC_TRAP        .bs     3
0023-                 67      VEC_SCI         .bs     3
0026-                 68      VEC_TOF         .bs     3
0029-                 69      VEC_OCF         .bs     3
002C-                 70      VEC_ICF         .bs     3
002F-                 71      VEC_IRQ         .bs     3
0032-                 72      VEC_SWI         .bs     3
0035-                 73      VEC_NMI         .bs     3
0038-                 74      BreakPointFlag  .bs     1
0039-                 75      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 76      RxBffrQty       .bs     1       ; 受信バッファデータ数
003B-                 77      RxBffrReadPtr   .bs     2       ; 受信バッファ読み込みポインタ
003D-                 78      RxBffrWritePtr  .bs     2       ; 受信バッファ書き込みポインタ
003F-                 79      ; General-Purpose Registers
003F-                 80      R0              .bs     2
0041-                 81      R1              .bs     2
0043-                 82
0043-                 83      ; ***********************************************************************
0043-                 84      ;   システムワークエリア System work area
0043-                 85      ; ***********************************************************************
0043-                 86              .sm     RAM
0100-                 87              .or     $0100
0100-                 88      ; 各種バッファ
0100-                 89      Rx_BUFFER       .bs     64      ; 受信バッファ（$0100-$013f）
013F-                 90      Rx_BUFFER_END   .eq     *-1
0040-                 91      Rx_BFFR_SIZE    .eq     Rx_BUFFER_END-Rx_BUFFER+1
0140-                 92      TEXT_BFFR       .bs     73      ; テキストバッファ（$0140-$188: 73byte）
0188-                 93      TEXT_BFFR_END   .eq     *-1
0049-                 94      TEXT_BFFR_SIZE  .eq     TEXT_BFFR_END-TEXT_BFFR+1
0189-                 95
0189-                 96      ; ***********************************************************************
0189-                 97      ;   変数 Variables
0189-                 98      ; ***********************************************************************
0189-                 99              .sm     RAM
0080-                100              .or     $80
0080-                101
0080-                102      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                103      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                104      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                105      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                106      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                107      Divisor         .bs     2       ; 除数
0089-                108      Remainder       .bs     2       ; 剰余
008B-                109      VariableAddr    .bs     2       ; 変数のアドレス
008D-                110      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                111      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                112      Source          .bs     2       ; 転送元アドレス
0092-                113      Destination     .bs     2       ; 転送先アドレス
0094-                114      Bytes           .bs     2       ; 転送バイト数
0096-                115      LineNumber      .bs     2       ; 行番号
0098-                116      LineLength      .bs     2       ; 行の長さ
009A-                117      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                118      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                119      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                120      ModuloMode      .bs     1       ; 剰余演算フラグ 0 = tranc, 1以上 = floor
00A0-                121      ToSubFlag       .bs     1       ; 分岐モードフラグ 0 = goto, 1 = gosub
00A1-                122      SStackPtr       .bs     2       ; サブルーチンスタック（Subroutine stack）ポインタ
00A3-                123      ArrayAddr       .bs     2       ; 配列変数の先頭アドレス
00A5-                124      MaxSubscript    .bs     2       ; 配列の最大添字数
00A7-                125      RndNumber       .bs     2       ; 乱数値
00A9-                126
00A9-                127      ; General-Purpose Registers
00A9-                128      UR0             *
00A9-                129      UR0H            .bs     1
00AA-                130      UR0L            .bs     1
00AB-                131      UR1             *
00AB-                132      UR1H            .bs     1
00AC-                133      UR1L            .bs     1
00AD-                134      UR2             *
00AD-                135      UR2H            .bs     1
00AE-                136      UR2L            .bs     1
00AF-                137      UR3             *
00AF-                138      UR3H            .bs     1
00B0-                139      UR3L            .bs     1
00B1-                140      ; Work area
00B1-                141      COMPARE         .bs     6       ; 文字列比較用バッファ
00B7-                142
00B7-                143      ; ***********************************************************************
00B7-                144      ;   ワークエリア work area
00B7-                145      ; ***********************************************************************
00B7-                146              .sm     RAM
0200-                147              .or     $0200
0200-                148      CSTACK          .bs     40      ; 計算スタック (Calculate stack)
0227-                149      CSTACK_BTM      .eq     *-1
0028-                150      CSTACK_SIZE     .eq     CSTACK_BTM-CSTACK+1
0228-                151      SSTACK          .bs     40      ; サブルーチンスタック (Subroutine stack)
024F-                152      SSTACK_BTM      .eq     *-1
0028-                153      SSTACK_SIZE     .eq     SSTACK_BTM-SSTACK+1
02C2-                154              .or     $02c2
02C2-                155      VARIABLE        .bs     52      ; 変数26文字 ($01c2-01f5)
02F5-                156      VARIABLE_END    .eq     *-1
0034-                157      VARIABLE_SIZE   .eq     VARIABLE_END-VARIABLE+1
02F6-                158
02F6-                159      ; ***********************************************************************
02F6-                160      ;   Program Start
02F6-                161      ; ***********************************************************************
0000-                162              .sm     CODE
1000-                163              .or     PROGRAM_START
1000-                164
1000-                165      init_tinybasic:
1000-30              166 ( 1)         tsx
1001-DF 80           167 ( 4)         stx     <StackPointer
1003-                168
1003-                169
1003-                170      cold_start:
1003-                171            ; // プログラムエリアの初期化
1003-CE 04 00        172 ( 3)         ldx     #USER_AREA_TOP
1006-DF 9A           173 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              174 ( 1)         clra
1009-5F              175 ( 1)         clrb
100A-ED 00           176 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           177 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                178            ; // 各種フラグの初期化
100E-97 9F           179 ( 3)         staa    <ModuloMode     ; 剰余演算をtrunc（0への切捨て除算）にする
1010-97 A0           180 ( 3)         staa    <ToSubFlag      ; 分岐モードを0 = gotoにする
1012-                181            ; // 変数領域の初期化
1012-CE 02 C2        182 ( 3)         ldx     #VARIABLE
1015-ED 00           183 ( 5) .loop   std     0,x
1017-08              184 ( 1)         inx
1018-08              185 ( 1)         inx
1019-8C 02 F6        186 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
101C-26 F7           187 ( 3)         bne     :loop
101E-                188            ; // 配列変数の初期化
101E-CC 04 02        189 ( 3)         ldd     #USER_AREA_TOP+2
1021-DD A3           190 ( 4)         std     <ArrayAddr
1023-CC 09 FF        191 ( 3)         ldd     #USER_AREA_BTM+2-USER_AREA_TOP
1026-04              192 ( 1)         lsrd
1027-DD A5           193 ( 4)         std     <MaxSubscript
1029-                194            ; // スタックポインタの初期化
1029-CE 02 50        195 ( 3)         ldx     #SSTACK_BTM+1
102C-DF A1           196 ( 4)         stx     <SStackPtr
102E-                197            ; // 乱数のSeed値の設定
102E-DC 09           198 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
1030-27 FC           199 ( 3)         beq     :seed           ; Seedはゼロ以外
1032-DD A7           200 ( 4)         std     <RndNumber
1034-                201
1034-                202
1034-                203      tb_main:
1034-72 01 9C        204 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
1037-C6 3E           205 ( 2)         ldab    #'>'
1039-BD FF AC        206 ( 6)         jsr     write_char
103C-BD FF A9        207 ( 6)         jsr     read_line
103F-CE 01 40        208 ( 3)         ldx     #TEXT_BFFR      ; 実行位置アドレスをセット
1042-                209            ; // 行番号判定
1042-BD 14 AA        210 ( 6)         jsr     get_int_from_decimal
1045-24 0A           211 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
1047-83 00 00        212 ( 3)         subd    #0
104A-2E 08           213 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
104C-86 0C           214 ( 2) .err12  ldaa    #12             ; "Invalid line number"
104E-7E 18 CA        215 ( 3)         jmp     write_err_msg
1051-                216
1051-                217      ; 実行モード（ダイレクトモード）
1051-                218      execute_mode:
1051-7E 11 8A        219 ( 3)         jmp     exe_line
1054-                220
1054-                221      ; 行編集モード
1054-                222      ; 空行か否か、空行でなければ同じ行番号か否かで処理を振り分ける
1054-                223      edit_mode:
1054-DF 8D           224 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1056-DD 96           225 ( 4)         std     <LineNumber     ; 行番号を保存
1058-                226            ; // 空行チェック
1058-BD 15 73        227 ( 6)         jsr     skip_space
105B-26 02           228 ( 3)         bne     :1
105D-20 1B           229 ( 3)         bra     delete_line     ; 空行だったら削除ルーチンへ
105F-                230      .1    ; // 入力行の長さチェック（Aレジスタに文字数）
105F-DE 8D           231 ( 4)         ldx     <ExePointer     ; バッファアドレスを復帰
1061-86 04           232 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1063-E6 00           233 ( 4) .loop   ldab    0,x
1065-27 04           234 ( 3)         beq     :2
1067-4C              235 ( 1)         inca                    ; 行の長さを+1
1068-08              236 ( 1)         inx                     ; バッファアドレスを+1
1069-20 F8           237 ( 3)         bra     :loop
106B-97 99           238 ( 3) .2      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
106D-                239            ; // 同じ行があるかどうか確認
106D-CE 04 00        240 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
1070-BD 15 D7        241 ( 6)         jsr     scan_line_num   ; 行番号検索
1073-DF 9D           242 ( 4)         stx     <ExeLineAddr    ; 検索した行アドレスをExeLineAddrに退避しておく
1075-24 29           243 ( 3)         bcc     not_same_line_num
1077-7E 11 00        244 ( 3)         jmp     same_line_num
107A-                245
107A-                246      ; 一行削除
107A-                247      delete_line:
107A-CE 04 00        248 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
107D-BD 15 D7        249 ( 6)         jsr     scan_line_num   ; 行番号検索
1080-24 1B           250 ( 3)         bcc     :end            ; 同じ行がなければ何もしない
1082-                251            ; // 転送先アドレスの設定（既存の行の先頭アドレス）
1082-DF 92           252 ( 4)         stx     <Destination
1084-                253            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1084-E6 02           254 ( 4)         ldab    2,x
1086-D7 99           255 ( 3)         stab    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存しておく
1088-3A              256 ( 1)         abx
1089-DF 90           257 ( 4)         stx     <Source
108B-                258            ; // 転送バイト数の設定（プログラム終端アドレス - 次の行の先頭アドレス + 2）
108B-DC 9A           259 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
108D-93 90           260 ( 4)         subd    <Source         ; - 次の行の先頭アドレス
108F-C3 00 02        261 ( 3)         addd    #2              ; + 2
1092-DD 94           262 ( 4)         std     <Bytes
1094-                263            ; // ブロック転送
1094-BD 17 9E        264 ( 6)         jsr     mem_move
1097-                265            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス - 行の長さ）
1097-DC 9A           266 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1099-93 98           267 ( 4)         subd    <LineLength     ; - 行の長さ
109B-DD 9A           268 ( 4)         std     <PrgmEndAddr
109D-7E 11 58        269 ( 3) .end    jmp     array_index
10A0-                270
10A0-                271      ; 同じ行番号がなかった場合の処理
10A0-                272      not_same_line_num:
10A0-                273            ; // D:次に大きな行番号 X:次に大きな行の先頭アドレス
10A0-83 00 00        274 ( 3)         subd    #0              ; tstd
10A3-27 22           275 ( 3)         beq     :add            ; 最終行より後ろ（D=$0000）だったら入力行挿入
10A5-                276            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10A5-DC 9A           277 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10A7-D3 98           278 ( 4)         addd    <LineLength     ; + 行の長さ
10A9-8D 48           279 ( 5)         bsr     check_pgrm_end
10AB-DD 9A           280 ( 4)         std     <PrgmEndAddr
10AD-                281            ; // 転送元アドレスの設定（次に大きな行の先頭アドレス）
10AD-DF 90           282 ( 4)         stx     <Source
10AF-                283            ; // 転送先アドレスの設定（次に大きな行の先頭アドレス + 行の長さ）
10AF-D6 99           284 ( 3)         ldab    <LineLength+1   ; 行の長さ
10B1-3A              285 ( 1)         abx                     ; + 次に大きな行の先頭アドレス
10B2-DF 92           286 ( 4)         stx     <Destination
10B4-                287            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
10B4-DC 9A           288 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10B6-93 90           289 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
10B8-C3 00 02        290 ( 3)         addd    #2              ; + 2
10BB-DD 94           291 ( 4)         std     <Bytes
10BD-                292            ; // ブロック転送
10BD-BD 17 9E        293 ( 6)         jsr     mem_move
10C0-                294            ; // 入力行の挿入
10C0-DE 9D           295 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
10C2-8D 16           296 ( 5)         bsr     insert_new_line
10C4-7E 11 58        297 ( 3)         jmp     array_index
10C7-                298      .add
10C7-                299            ; // D:$0000 X:プログラム終端アドレス
10C7-                300            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10C7-DC 9A           301 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10C9-D3 98           302 ( 4)         addd    <LineLength     ; + 行の長さ
10CB-8D 26           303 ( 5)         bsr     check_pgrm_end
10CD-DD 9A           304 ( 4)         std     <PrgmEndAddr
10CF-                305            ; // 入力行の挿入
10CF-8D 09           306 ( 5)         bsr     insert_new_line
10D1-                307            ; // 終端行の挿入
10D1-DE 9A           308 ( 4)         ldx     <PrgmEndAddr
10D3-4F              309 ( 1)         clra
10D4-5F              310 ( 1)         clrb
10D5-ED 00           311 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
10D7-7E 11 58        312 ( 3)         jmp     array_index
10DA-                313
10DA-                314      ; 入力行の転送
10DA-                315      insert_new_line:
10DA-DC 96           316 ( 4)         ldd     <LineNumber     ; 行番号を転送
10DC-ED 00           317 ( 5)         std     0,x
10DE-08              318 ( 1)         inx
10DF-08              319 ( 1)         inx
10E0-D6 99           320 ( 3)         ldab    <LineLength+1   ; 行の長さを転送
10E2-E7 00           321 ( 4)         stab    0,x
10E4-08              322 ( 1)         inx
10E5-                323            ; // 転送先アドレスの設定（現在の位置）
10E5-DF 92           324 ( 4)         stx     <Destination
10E7-                325            ; // 転送バイト数の設定（行の長さ - 3（行番号 - 長さ））
10E7-4F              326 ( 1)         clra                    ; 行の長さ（A=0,B=下位8bit）
10E8-C0 03           327 ( 2)         subb    #3              ; - 3
10EA-DD 94           328 ( 4)         std     <Bytes
10EC-                329            ; // 転送元アドレスの設定（入力された行）
10EC-DC 8D           330 ( 4)         ldd     <ExePointer     ; バッファアドレスを復帰（行番号の直後を指している）
10EE-DD 90           331 ( 4)         std     <Source
10F0-                332            ; // ブロック転送
10F0-7E 17 9E        333 ( 3)         jmp     mem_move        ; 飛び先でrts
10F3-                334
10F3-                335      ; プログラムエリアを超えていないか確認
10F3-                336      check_pgrm_end:
10F3-18              337 ( 2)         xgdx
10F4-8C 0D FD        338 ( 3)         cpx     #USER_AREA_BTM
10F7-18              339 ( 2)         xgdx
10F8-24 01           340 ( 3)         bcc     :err14
10FA-39              341 ( 5)         rts
10FB-86 0E           342 ( 2) .err14  ldaa    #14              ; "Memory size over"
10FD-7E 18 CA        343 ( 3)         jmp     write_err_msg
1100-                344
1100-                345      ; 同じ行番号があった場合、既存の行との長さの差で処理を振り分ける
1100-                346      same_line_num:
1100-                347            ; // D:行番号 X:既存の行の開始アドレス
1100-96 99           348 ( 3)         ldaa    <LineLength+1   ; 入力行の長さを取得
1102-A0 02           349 ( 4)         suba    2,x             ; **Aレジスタ** = 入力行の長さ - 既存行の長さ
1104-2B 2D           350 ( 3)         bmi     short_length    ; 入力行の長さ < 既存行の長さ
1106-27 26           351 ( 3)         beq     same_length     ; 入力行の長さ = 既存行の長さ
1108-                352
1108-                353      ; 入力行が既存の行より長い場合
1108-                354      long_length:                    ; 入力行の長さ > 既存行の長さ
1108-                355            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1108-E6 02           356 ( 4)         ldab    2,x
110A-3A              357 ( 1)         abx
110B-DF 90           358 ( 4)         stx     <Source
110D-                359            ; // 転送先アドレスの設定（次の行の先頭アドレス + 入力行の長さ - 既存行の長さ）
110D-16              360 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
110E-4F              361 ( 1)         clra
110F-DD AB           362 ( 4)         std     <UR1            ; 入力行の長さ - 既存行の長さを後で使うためにUR1に保存
1111-3A              363 ( 1)         abx                     ; 次の行の先頭アドレス + （入力行の長さ - 既存行の長さ）
1112-DF 92           364 ( 4)         stx     <Destination
1114-                365            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1114-DC 9A           366 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1116-93 90           367 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1118-C3 00 02        368 ( 3)         addd    #2              ; + 2
111B-DD 94           369 ( 4)         std     <Bytes
111D-                370            ; // 新しいプログラム終端アドレスの設定
111D-                371            ; // （プログラム終端アドレス + 入力行の長さ - 既存行の長さ）
111D-DC 9A           372 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
111F-D3 AB           373 ( 4)         addd    <UR1            ; + 入力行の長さ - 既存行の長さ
1121-8D D0           374 ( 5)         bsr     check_pgrm_end
1123-DD 9A           375 ( 4)         std     <PrgmEndAddr
1125-                376            ; // ブロック転送
1125-BD 17 9E        377 ( 6)         jsr     mem_move
1128-                378            ; // 入力行の挿入
1128-DE 9D           379 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
112A-8D AE           380 ( 5)         bsr     insert_new_line
112C-20 2A           381 ( 3)         bra     array_index
112E-                382
112E-                383      ; 入力行と既存の行が同じ長さの場合
112E-                384      same_length:
112E-8D AA           385 ( 5)         bsr     insert_new_line
1130-7E 10 34        386 ( 3)         jmp     tb_main
1133-                387
1133-                388      ; 入力行が既存の行より短い場合
1133-                389      short_Length:
1133-                390            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1133-E6 02           391 ( 4)         ldab    2,x
1135-3A              392 ( 1)         abx
1136-DF 90           393 ( 4)         stx     <Source
1138-                394            ; // 転送先アドレスの設定（次の行の先頭アドレス - 既存行の長さ + 入力行の長さ）
1138-16              395 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
1139-50              396 ( 1)         negb                    ; 絶対値にする
113A-4F              397 ( 1)         clra
113B-DD AB           398 ( 4)         std     <UR1            ; 既存行の長さ - 入力行の長さ
113D-18              399 ( 2)         xgdx
113E-93 AB           400 ( 4)         subd    <UR1            ; 次の行の先頭アドレス - （既存行の長さ - 入力行の長さ）
1140-DD 92           401 ( 4)         std     <Destination
1142-                402            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1142-DC 9A           403 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1144-93 90           404 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1146-C3 00 02        405 ( 3)         addd    #2              ; + 2
1149-DD 94           406 ( 4)         std     <Bytes
114B-                407            ; // ブロック転送
114B-BD 17 9E        408 ( 6)         jsr     mem_move
114E-                409            ; // 新しいプログラム終端アドレスの設定
114E-                410            ; // （プログラム終端アドレス - 既存行の長さ + 入力行の長さ）
114E-DC 9A           411 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1150-93 AB           412 ( 4)         subd    <UR1            ; - （既存行の長さ - 入力行の長さ）
1152-DD 9A           413 ( 4)         std     <PrgmEndAddr
1154-                414            ; // 入力行の挿入
1154-DE 9D           415 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1156-8D 82           416 ( 5)         bsr     insert_new_line
1158-                417
1158-                418      array_index:
1158-DC 9A           419 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
115A-C3 00 02        420 ( 3)         addd    #2              ; + 2
115D-DD A3           421 ( 4)         std     <ArrayAddr      ; 配列変数の先頭アドレス
115F-CC 0D FF        422 ( 3)         ldd     #USER_AREA_BTM+2
1162-93 A3           423 ( 4)         subd    <ArrayAddr
1164-04              424 ( 1)         lsrd
1165-DD A5           425 ( 4)         std     <MaxSubscript
1167-7E 10 34        426 ( 3)         jmp     tb_main
116A-                427
116A-                428
116A-                429      ; -----------------------------------------------------------------------
116A-                430      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
116A-                431      ; Is a multi statement mark?
116A-                432      ;【引数】X:実行位置アドレス
116A-                433      ;【使用】B, X
116A-                434      ;【返値】なし
116A-                435      ; -----------------------------------------------------------------------
116A-                436      is_multi:
116A-BD 15 73        437 ( 6)         jsr     skip_space
116D-27 0B           438 ( 3)         beq     eol_process
116F-C1 3A           439 ( 2)         cmpb    #':'
1171-26 03           440 ( 3)         bne     :err00
1173-08              441 ( 1)         inx
1174-20 14           442 ( 3)         bra     exe_line
1176-4F              443 ( 1) .err00  clra                    ; "Syntax error"
1177-7E 18 CA        444 ( 3)         jmp     write_err_msg
117A-                445
117A-                446
117A-                447      ; -----------------------------------------------------------------------
117A-                448      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
117A-                449      ;  - directモードであればそのまま終了
117A-                450      ;  - runモードであれば次の行のポインタを設定してrts
117A-                451      ; End-of-line processing
117A-                452      ;  - If in direct mode, terminate execution
117A-                453      ;  - If run mode, set the pointer to the next line and rts
117A-                454      ;【引数】なし
117A-                455      ;【使用】A, B, X
117A-                456      ;【返値】なし
117A-                457      ; -----------------------------------------------------------------------
117A-                458      eol_process:
117A-                459            ; // runモードであれば次の行のポインタを設定してrts
117A-7D 00 9C        460 ( 4)         tst     <ExeStateFlag
117D-26 08           461 ( 3)         bne     :end
117F-DE 9D           462 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
1181-E6 02           463 ( 4)         ldab    2,x             ; 行の長さを取得
1183-3A              464 ( 1)         abx                     ; 次の行の先頭アドレスを取得
1184-DF 9D           465 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
1186-39              466 ( 5)         rts
1187-7E 10 34        467 ( 3) .end    jmp     tb_main         ; directモードであればそのまま終了
118A-                468
118A-                469
118A-                470      ; -----------------------------------------------------------------------
118A-                471      ; 一行実行
118A-                472      ; Execute one line
118A-                473      ;【引数】X:実行位置アドレス
118A-                474      ;【使用】A, B, X
118A-                475      ;【返値】なし
118A-                476      ; -----------------------------------------------------------------------
118A-                477      exe_line:
118A-BD 15 73        478 ( 6)         jsr     skip_space
118D-27 EB           479 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
118F-                480            ; // 配列変数のチェック
118F-C1 40           481 ( 2)         cmpb    #'@'
1191-26 1B           482 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
1193-E6 01           483 ( 4)         ldab    1,x
1195-C1 28           484 ( 2)         cmpb    #'('            ; 直後の文字は'('？
1197-26 4A           485 ( 3)         bne     :err00          ; No. "Syntax error"
1199-08              486 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
119A-08              487 ( 1)         inx
119B-BD 11 EC        488 ( 6)         jsr     eval_expression ; 添字を取得する
119E-24 47           489 ( 3)         bcc     :err04
11A0-                490            ; // ')'の確認
11A0-37              491 ( 4)         pshb                    ; 添字の下位8bitを退避
11A1-E6 00           492 ( 4)         ldab    0,x
11A3-C1 29           493 ( 2)         cmpb    #')'
11A5-26 3C           494 ( 3)         bne     :err00
11A7-33              495 ( 3)         pulb                    ; 添字の下位8bitを復帰
11A8-08              496 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
11A9-BD 15 B0        497 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
11AC-20 08           498 ( 3)         bra     :let
11AE-BD 15 5E        499 ( 6) .var    jsr     is_variable     ; 変数か？
11B1-24 12           500 ( 3)         bcc     :cmd            ; No. テーブル検索へ
11B3-86 02           501 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
11B5-58              502 ( 1)         aslb                    ; B = 変数領域の下位バイト
11B6-DD 8B           503 ( 4) .let    std     <VariableAddr   ; 変数アドレスを保存
11B8-                504            ; // 代入文のチェック
11B8-BD 15 73        505 ( 6)         jsr     skip_space      ; Yes. 代入文か？
11BB-C1 3D           506 ( 2)         cmpb    #'='
11BD-26 24           507 ( 3)         bne     :err00          ; No. エラー処理へ
11BF-08              508 ( 1)         inx                     ; Yes. 代入実行
11C0-BD 15 C3        509 ( 6)         jsr     assign_to_var
11C3-20 A5           510 ( 3)         bra     is_multi
11C5-                511            ; // コマンド・ステートメントのチェック
11C5-EC 00           512 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
11C7-DD B1           513 ( 4)         std     <COMPARE
11C9-EC 02           514 ( 5)         ldd     2,x
11CB-DD B3           515 ( 4)         std     <COMPARE+2
11CD-EC 04           516 ( 5)         ldd     4,x
11CF-DD B5           517 ( 4)         std     <COMPARE+4
11D1-DF 8D           518 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
11D3-7D 00 9C        519 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
11D6-27 05           520 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
11D8-CE 18 4C        521 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
11DB-20 03           522 ( 3)         bra     :2
11DD-CE 18 68        523 ( 3) .1      ldx     #SMT_TABLE
11E0-BD 18 0F        524 ( 6) .2      jsr     search_table    ; テーブル検索実行
11E3-4F              525 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
11E4-7E 18 CA        526 ( 3)         jmp     write_err_msg
11E7-86 04           527 ( 2) .err04  ldaa    #4              ; "Illegal expression"
11E9-7E 18 CA        528 ( 3)         jmp     write_err_msg
11EC-                529
11EC-                530
11EC-                531      ; -----------------------------------------------------------------------
11EC-                532      ; 式を評価する
11EC-                533      ; Evaluate the expression
11EC-                534      ;【引数】B:アスキーコード X:実行位置アドレス
11EC-                535      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
11EC-                536      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
11EC-                537      ;        偽(C=0) / X:現在の実行位置アドレス
11EC-                538      ; -----------------------------------------------------------------------
11EC-                539      eval_expression:
00AD-                540      .SP     .eq     UR2
00AF-                541      .X      .eq     UR3
11EC-                542            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
11EC-DF AF           543 ( 4)         stx     <:X
11EE-30              544 ( 1)         tsx
11EF-DF AD           545 ( 4)         stx     <:SP
11F1-DE AF           546 ( 4)         ldx     <:X
11F3-                547            ; // 計算スタックの初期化
11F3-CC 02 28        548 ( 3)         ldd     #CSTACK_BTM+1
11F6-DD 82           549 ( 4)         std     <CStackPtr
11F8-                550            ; // 式評価開始
11F8-8D 08           551 ( 5)         bsr     expr_4th
11FA-                552            ; // 計算結果をスタックトップから取り出す
11FA-3C              553 ( 5)         pshx
11FB-DE 82           554 ( 4)         ldx     <CStackPtr
11FD-EC 00           555 ( 5)         ldd     0,x
11FF-38              556 ( 4)         pulx
1200-0D              557 ( 1)         sec                     ; true:C=1
1201-39              558 ( 5)         rts
1202-                559
1202-                560      expr_4th:
1202-8D 50           561 ( 5)         bsr     expr_3rd
1204-BD 15 73        562 ( 6) .loop   jsr     skip_space
1207-C1 3D           563 ( 2)         cmpb    #'='            ; '='?
1209-26 08           564 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
120B-08              565 ( 1)         inx
120C-8D 46           566 ( 5)         bsr     expr_3rd
120E-BD 14 5D        567 ( 6)         jsr     CS_eq           ; EQual to
1211-20 F1           568 ( 3)         bra     :loop
1213-C1 3C           569 ( 2) .ltsign cmpb    #'<'            ; '<'?
1215-26 22           570 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1217-08              571 ( 1)         inx
1218-E6 00           572 ( 4)         ldab    0,x
121A-C1 3E           573 ( 2)         cmpb    #'>'            ; '<>'?
121C-26 08           574 ( 3)         bne     :lte
121E-08              575 ( 1)         inx
121F-8D 33           576 ( 5)         bsr     expr_3rd
1221-BD 14 7E        577 ( 6)         jsr     CS_ne           ; Not Equal to
1224-20 DE           578 ( 3)         bra     :loop
1226-C1 3D           579 ( 2) .lte    cmpb    #'='            ; '<='?
1228-26 08           580 ( 3)         bne     :lt
122A-08              581 ( 1)         inx
122B-8D 27           582 ( 5)         bsr     expr_3rd
122D-BD 14 73        583 ( 6)         jsr     CS_lte          ; Less Than or Equal to
1230-20 D2           584 ( 3)         bra     :loop
1232-8D 20           585 ( 5) .lt     bsr     expr_3rd
1234-BD 14 68        586 ( 6)         jsr     CS_lt           ; Less Than
1237-20 CB           587 ( 3)         bra     :loop
1239-C1 3E           588 ( 2) .gtsign cmpb    #'>'            ; '>'?
123B-26 16           589 ( 3)         bne     :end
123D-08              590 ( 1)         inx
123E-E6 00           591 ( 4)         ldab    0,x
1240-C1 3D           592 ( 2)         cmpb    #'='            ; '>='?
1242-26 08           593 ( 3)         bne     :gt
1244-08              594 ( 1)         inx
1245-8D 0D           595 ( 5)         bsr     expr_3rd
1247-BD 14 94        596 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
124A-20 B8           597 ( 3)         bra     :loop
124C-8D 06           598 ( 5) .gt     bsr     expr_3rd
124E-BD 14 89        599 ( 6)         jsr     CS_gt           ; Greater Than
1251-20 B1           600 ( 3)         bra     :loop
1253-39              601 ( 5) .end    rts
1254-                602
1254-                603      expr_3rd:
1254-8D 1C           604 ( 5)         bsr     expr_2nd
1256-BD 15 73        605 ( 6) .loop   jsr     skip_space
1259-C1 2B           606 ( 2)         cmpb    #'+'
125B-26 08           607 ( 3)         bne     :minus
125D-08              608 ( 1)         inx
125E-8D 12           609 ( 5)         bsr     expr_2nd
1260-BD 13 27        610 ( 6)         jsr     CS_add
1263-20 F1           611 ( 3)         bra     :loop
1265-C1 2D           612 ( 2) .minus  cmpb    #'-'
1267-26 08           613 ( 3)         bne     :end
1269-08              614 ( 1)         inx
126A-8D 06           615 ( 5)         bsr     expr_2nd
126C-BD 13 30        616 ( 6)         jsr     CS_sub
126F-20 E5           617 ( 3)         bra     :loop
1271-39              618 ( 5) .end    rts
1272-                619
1272-                620      expr_2nd:
1272-8D 28           621 ( 5)         bsr     expr_1st
1274-BD 15 73        622 ( 6) .loop   jsr     skip_space
1277-C1 2A           623 ( 2)         cmpb    #'*'
1279-26 08           624 ( 3)         bne     :div
127B-08              625 ( 1)         inx
127C-8D 1E           626 ( 5)         bsr     expr_1st
127E-BD 13 39        627 ( 6)         jsr     CS_mul
1281-20 F1           628 ( 3)         bra     :loop
1283-C1 2F           629 ( 2) .div    cmpb    #'/'
1285-26 08           630 ( 3)         bne     :mod
1287-08              631 ( 1)         inx
1288-8D 12           632 ( 5)         bsr     expr_1st
128A-BD 13 56        633 ( 6)         jsr     CS_div
128D-20 E5           634 ( 3)         bra     :loop
128F-C1 25           635 ( 2) .mod    cmpb    #'%'
1291-26 08           636 ( 3)         bne     :end
1293-08              637 ( 1)         inx
1294-8D 06           638 ( 5)         bsr     expr_1st
1296-BD 13 6F        639 ( 6)         jsr     CS_mod
1299-20 D9           640 ( 3)         bra     :loop
129B-39              641 ( 5) .end    rts
129C-                642
129C-                643      expr_1st:
00AD-                644      .SP     .eq     UR2
00AF-                645      .X      .eq     UR3
129C-BD 15 73        646 ( 6)         jsr     skip_space
129F-BD 14 AA        647 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
12A2-24 02           648 ( 3)         bcc     :array          ; 数字でなければ配列変数のチェックへ
12A4-20 59           649 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
12A6-C1 40           650 ( 2) .array  cmpb    #'@'
12A8-26 22           651 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
12AA-E6 01           652 ( 4)         ldab    1,x
12AC-C1 28           653 ( 2)         cmpb    #'('            ; 直後の文字は'('？
12AE-26 66           654 ( 3)         bne     :err00          ; No. "Syntax error"
12B0-08              655 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
12B1-08              656 ( 1)         inx
12B2-BD 12 02        657 ( 6)         jsr     expr_4th        ; 添字を取得する
12B5-                658            ; // ')'の確認
12B5-C1 29           659 ( 2)         cmpb    #')'
12B7-26 5D           660 ( 3)         bne     :err00
12B9-3C              661 ( 5)         pshx                    ; 実行位置アドレスを退避
12BA-DE 82           662 ( 4)         ldx     <CStackPtr
12BC-EC 00           663 ( 5)         ldd     0,x             ; 添字の取得
12BE-08              664 ( 1)         inx
12BF-08              665 ( 1)         inx
12C0-DF 82           666 ( 4)         stx     <CStackPtr
12C2-BD 15 B0        667 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
12C5-18              668 ( 2)         xgdx                    ; X = 配列変数のアドレス
12C6-EC 00           669 ( 5)         ldd     0,x             ; 配列変数値を取得
12C8-38              670 ( 4)         pulx                    ; 実行位置アドレスを復帰
12C9-08              671 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
12CA-20 33           672 ( 3)         bra     :push
12CC-BD 15 5E        673 ( 6) .var    jsr     is_variable     ; 変数か？
12CF-24 0A           674 ( 3)         bcc     :func           ; 変数でなければカッコのチェックへ
12D1-                675            ; // 変数値の取得
12D1-3C              676 ( 5)         pshx                    ; 実行位置アドレスを退避
12D2-86 02           677 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
12D4-58              678 ( 1)         aslb                    ; B = 変数領域の下位バイト
12D5-18              679 ( 2)         xgdx                    ; X = 変数のアドレス
12D6-EC 00           680 ( 5)         ldd     0,x             ; D <- 変数の値
12D8-38              681 ( 4)         pulx                    ; 実行位置アドレスを復帰
12D9-20 24           682 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
12DB-EC 00           683 ( 5) .func   ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
12DD-DD B1           684 ( 4)         std     <COMPARE
12DF-EC 02           685 ( 5)         ldd     2,x
12E1-DD B3           686 ( 4)         std     <COMPARE+2
12E3-EC 04           687 ( 5)         ldd     4,x
12E5-DD B5           688 ( 4)         std     <COMPARE+4
12E7-DF 8D           689 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
12E9-CE 18 BE        690 ( 3)         ldx     #FUNC_TABLE
12EC-BD 18 0F        691 ( 6)         jsr     search_table    ; テーブル検索実行。飛び先でrts
12EF-E6 00           692 ( 4)         ldab    0,x             ; 該当関数がなかった場合はもう一度文字を読み込む
12F1-C1 28           693 ( 2) .paren  cmpb    #'('
12F3-26 1A           694 ( 3)         bne     :err
12F5-08              695 ( 1)         inx
12F6-BD 12 02        696 ( 6)         jsr     expr_4th
12F9-C1 29           697 ( 2)         cmpb    #')'
12FB-26 12           698 ( 3)         bne     :err
12FD-08              699 ( 1)         inx
12FE-39              700 ( 5)         rts
12FF-3C              701 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1300-DE 82           702 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1302-09              703 ( 1)         dex
1303-09              704 ( 1)         dex
1304-8C 01 FE        705 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
1307-25 11           706 ( 3)         bcs     :err06
1309-ED 00           707 ( 5)         std     0,x
130B-DF 82           708 ( 4)         stx     <CStackPtr
130D-38              709 ( 4)         pulx                    ; 実行位置アドレスを復帰
130E-39              710 ( 5)         rts
130F-                711            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
130F-DE AD           712 ( 4) .err    ldx     <:SP
1311-35              713 ( 1)         txs
1312-DE AF           714 ( 4)         ldx     <:X
1314-0C              715 ( 1)         clc                     ; false:C=0
1315-39              716 ( 5)         rts
1316-4F              717 ( 1) .err00  clra                    ; "Syntax error"
1317-7E 18 CA        718 ( 3)         jmp     write_err_msg
131A-86 06           719 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
131C-7E 18 CA        720 ( 3)         jmp     write_err_msg
131F-                721
131F-                722      ;
131F-                723      ; Arithmetic operator
131F-                724      ;
131F-                725      CS_store:
131F-08              726 ( 1)         inx
1320-08              727 ( 1)         inx
1321-ED 00           728 ( 5)         std     0,x
1323-DF 82           729 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
1325-38              730 ( 4)         pulx                    ; 実行位置アドレスを復帰
1326-39              731 ( 5)         rts
1327-                732
1327-3C              733 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
1328-DE 82           734 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
132A-EC 02           735 ( 5)         ldd     2,x
132C-E3 00           736 ( 5)         addd    0,x
132E-20 EF           737 ( 3)         bra     CS_store
1330-                738
1330-3C              739 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
1331-DE 82           740 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1333-EC 02           741 ( 5)         ldd     2,x
1335-A3 00           742 ( 5)         subd    0,x
1337-20 E6           743 ( 3)         bra     CS_store
1339-                744
1339-                745      CS_mul:
00A9-                746      .Result         .eq     UR0
1339-3C              747 ( 5)         pshx                    ; 実行位置アドレスを退避
133A-DE 82           748 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
133C-                749              ; B * D
133C-A6 03           750 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
133E-E6 01           751 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
1340-3D              752 ( 7)         mul                     ; B * D
1341-DD A9           753 ( 4)         std     <:Result        ;「B*D」を保存
1343-                754              ; A * D
1343-EC 01           755 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
1345-3D              756 ( 7)         mul                     ; A * D
1346-DB A9           757 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
1348-D7 A9           758 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
134A-                759              ; C * B
134A-A6 00           760 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
134C-E6 03           761 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
134E-3D              762 ( 7)         mul                     ; C * B
134F-DB A9           763 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1351-17              764 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1352-D6 AA           765 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
1354-20 C9           766 ( 3)         bra     CS_store
1356-                767
1356-                768      ;
1356-                769      ; trunc : 符号付き割り算の考え方
1356-                770      ; ・剰余は被除数の符号と同一
1356-                771      ;   ・ 7 / 3  = 商  2、剰余  1
1356-                772      ;   ・-7 / 3  = 商 -2、剰余 -1
1356-                773      ;   ・ 7 / -3 = 商 -2、剰余  1
1356-                774      ;   ・-7 / -3 = 商  2、剰余 -1
1356-                775      ;
1356-7D 00 9F        776 ( 4) CS_div: tst     <ModuloMode
1359-26 7A           777 ( 3)         bne     CS_div2
135B-3C              778 ( 5)         pshx                    ; 実行位置アドレスを退避
135C-DE 82           779 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
135E-8D 2B           780 ( 5)         bsr     div_uint        ; 除算実行
1360-18              781 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1361-7D 00 85        782 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1364-27 05           783 ( 3)         beq     :end            ; '+'なら終了
1366-43              784 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1367-53              785 ( 1)         comb
1368-C3 00 01        786 ( 3)         addd    #1
136B-DE 82           787 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
136D-20 B0           788 ( 3)         bra     CS_store
136F-                789
136F-7D 00 9F        790 ( 4) CS_mod: tst     <ModuloMode
1372-26 7E           791 ( 3)         bne     CS_mod2
1374-3C              792 ( 5)         pshx                    ; 実行位置アドレスを退避
1375-DE 82           793 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1377-8D 12           794 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1379-DD 89           795 ( 4)         std     <Remainder      ; 剰余はゼロか？
137B-27 0A           796 ( 3)         beq     :end            ; ゼロであれば終了
137D-7D 00 86        797 ( 4)         tst     <RemSignFlag    ; 剰余の符号チェック
1380-27 05           798 ( 3)         beq     :end            ; '+'なら終了
1382-43              799 ( 1) .sign   coma                    ; '-'なら2の補数にする
1383-53              800 ( 1)         comb
1384-C3 00 01        801 ( 3)         addd    #1
1387-DE 82           802 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1389-20 94           803 ( 3)         bra     CS_store
138B-                804
138B-                805      div_uint:
00A9-                806      .Counter        .eq     UR0H
138B-EC 00           807 ( 5)         ldd     0,x             ; ゼロ除算チェック
138D-27 41           808 ( 3)         beq     :err08          ; 除数がゼロならエラー
138F-5F              809 ( 1)         clrb
1390-D7 85           810 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1392-D7 86           811 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1394-C6 10           812 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1396-D7 A9           813 ( 3)         stab    <:Counter
1398-                814              ; // 剰余の符号フラグの設定
1398-EC 02           815 ( 5)         ldd     2,x             ; Dレジスタに被除数を代入
139A-2A 03           816 ( 3)         bpl     :1              ; 被除数が正であれば剰余の符号は正（0）
139C-7C 00 86        817 ( 6)         inc     <RemSignFlag    ; 被除数が負であれば剰余の符号は負（1）
139F-                818              ; // 商の符号フラグの設定
139F-A8 00           819 ( 4) .1      eora    0,x             ; 被除数の符号と除数の符号のXORを取る
13A1-2A 03           820 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
13A3-7C 00 85        821 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
13A6-                822              ; // 除数を絶対値にする
13A6-EC 00           823 ( 5) .2      ldd     0,x             ; D <- 除数
13A8-2A 05           824 ( 3)         bpl     :3
13AA-43              825 ( 1)         coma                    ; 除数が負なら絶対値にする
13AB-53              826 ( 1)         comb
13AC-C3 00 01        827 ( 3)         addd    #1
13AF-DD 87           828 ( 4) .3      std     <Divisor        ; 除数を保存
13B1-                829              ; // 被除数を絶対値にする
13B1-EC 02           830 ( 5)         ldd     2,x             ; D <- 被除数
13B3-2A 05           831 ( 3)         bpl     :4
13B5-43              832 ( 1)         coma                    ; 被除数が負なら絶対値にする
13B6-53              833 ( 1)         comb
13B7-C3 00 01        834 ( 3)         addd    #1
13BA-                835              ; // 除算実行
13BA-18              836 ( 2) .4      xgdx                    ; X <- 被除数
13BB-4F              837 ( 1)         clra                    ; D（WORK）をクリア
13BC-5F              838 ( 1)         clrb
13BD-18              839 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
13BE-05              840 ( 1)         asld
13BF-18              841 ( 2)         xgdx
13C0-59              842 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
13C1-49              843 ( 1)         rola
13C2-93 87           844 ( 4)         subd    <Divisor        ; WORK - 除数
13C4-08              845 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
13C5-24 03           846 ( 3)         bcc     :5              ; WORKから除数を引けた？
13C7-D3 87           847 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
13C9-09              848 ( 1)         dex                     ; XレジスタのLSBを0に戻す
13CA-7A 00 A9        849 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
13CD-26 EE           850 ( 3)         bne     :loop
13CF-39              851 ( 5)         rts
13D0-86 08           852 ( 2) .err08  ldaa    #8              ; "Zero Divide"
13D2-7E 18 CA        853 ( 3)         jmp     write_err_msg
13D5-                854
13D5-                855      ;
13D5-                856      ; floor : 符号付き割り算の考え方
13D5-                857      ; ・剰余は除数の符号と同一
13D5-                858      ;   ・ 7 / 3  = 商  2、剰余  1
13D5-                859      ;   ・-7 / 3  = 商 -3、剰余  2
13D5-                860      ;   ・ 7 / -3 = 商 -3、剰余 -2
13D5-                861      ;   ・-7 / -3 = 商  2、剰余 -1
13D5-                862      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
13D5-                863      ;       2.ただし、除数がゼロの場合は1は足さない
13D5-                864      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
13D5-                865      ;         除数の絶対値から剰余の絶対値を引く
13D5-                866      ;       2.その結果を除数と同じ符号にする
13D5-                867      ;       3.ただし、除数がゼロの場合は剰余もゼロ
13D5-                868      ;
13D5-                869      CS_div2:
13D5-3C              870 ( 5)         pshx                    ; 実行位置アドレスを退避
13D6-DE 82           871 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13D8-8D 39           872 ( 5)         bsr     div_uint2       ; 除算実行
13DA-18              873 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
13DB-7D 00 85        874 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
13DE-27 0D           875 ( 3)         beq     :end            ; '+'なら終了
13E0-8C 00 00        876 ( 3)         cpx     #0              ; 剰余はゼロか？
13E3-27 03           877 ( 3)         beq     :sign
13E5-C3 00 01        878 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
13E8-43              879 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
13E9-53              880 ( 1)         comb
13EA-C3 00 01        881 ( 3)         addd    #1
13ED-DE 82           882 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
13EF-7E 13 1F        883 ( 3)         jmp     CS_store
13F2-                884
13F2-                885      CS_mod2:
13F2-3C              886 ( 5)         pshx                    ; 実行位置アドレスを退避
13F3-DE 82           887 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13F5-8D 1C           888 ( 5)         bsr     div_uint2        ; 除算実行。D = 剰余
13F7-DD 89           889 ( 4)         std     <Remainder      ; 剰余はゼロか？
13F9-27 13           890 ( 3)         beq     :end            ; ゼロであれば終了
13FB-7D 00 85        891 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
13FE-27 04           892 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
1400-DC 87           893 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1402-93 89           894 ( 4)         subd    <Remainder
1404-7D 00 86        895 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1407-27 05           896 ( 3)         beq     :end            ; '+'なら終了
1409-43              897 ( 1)         coma                    ; '-'なら2の補数にする
140A-53              898 ( 1)         comb
140B-C3 00 01        899 ( 3)         addd    #1
140E-DE 82           900 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1410-7E 13 1F        901 ( 3)         jmp     CS_store
1413-                902
1413-                903      div_uint2:
00A9-                904      .Counter        .eq     UR0H
1413-EC 00           905 ( 5)         ldd     0,x             ; ゼロ除算チェック
1415-27 41           906 ( 3)         beq     :err08          ; 除数がゼロならエラー
1417-5F              907 ( 1)         clrb
1418-D7 85           908 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
141A-D7 86           909 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
141C-C6 10           910 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
141E-D7 A9           911 ( 3)         stab    <:Counter
1420-                912              ; // 剰余の符号フラグの設定
1420-EC 00           913 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1422-2A 03           914 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1424-7C 00 86        915 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1427-                916              ; // 商の符号フラグの設定
1427-A8 02           917 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
1429-2A 03           918 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
142B-7C 00 85        919 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
142E-                920              ; // 除数を絶対値にする
142E-EC 00           921 ( 5) .2      ldd     0,x             ; D <- 除数
1430-2A 05           922 ( 3)         bpl     :3
1432-43              923 ( 1)         coma                    ; 除数が負なら絶対値にする
1433-53              924 ( 1)         comb
1434-C3 00 01        925 ( 3)         addd    #1
1437-DD 87           926 ( 4) .3      std     <Divisor        ; 除数を保存
1439-                927              ; // 被除数を絶対値にする
1439-EC 02           928 ( 5)         ldd     2,x             ; D <- 被除数
143B-2A 05           929 ( 3)         bpl     :4
143D-43              930 ( 1)         coma                    ; 被除数が負なら絶対値にする
143E-53              931 ( 1)         comb
143F-C3 00 01        932 ( 3)         addd    #1
1442-                933              ; // 除算実行
1442-18              934 ( 2) .4      xgdx                    ; X <- 被除数
1443-4F              935 ( 1)         clra                    ; D（WORK）をクリア
1444-5F              936 ( 1)         clrb
1445-18              937 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
1446-05              938 ( 1)         asld
1447-18              939 ( 2)         xgdx
1448-59              940 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
1449-49              941 ( 1)         rola
144A-93 87           942 ( 4)         subd    <Divisor        ; WORK - 除数
144C-08              943 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
144D-24 03           944 ( 3)         bcc     :5              ; WORKから除数を引けた？
144F-D3 87           945 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1451-09              946 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1452-7A 00 A9        947 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1455-26 EE           948 ( 3)         bne     :loop
1457-39              949 ( 5)         rts
1458-86 08           950 ( 2) .err08  ldaa    #8              ; "Zero Divide"
145A-7E 18 CA        951 ( 3)         jmp     write_err_msg
145D-                952
145D-3C              953 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
145E-DE 82           954 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1460-EC 02           955 ( 5)         ldd     2,x
1462-A3 00           956 ( 5)         subd    0,x
1464-27 39           957 ( 3)         beq     CS_true
1466-20 3D           958 ( 3)         bra     CS_false
1468-                959
1468-3C              960 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1469-DE 82           961 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
146B-EC 02           962 ( 5)         ldd     2,x
146D-A3 00           963 ( 5)         subd    0,x
146F-2D 2E           964 ( 3)         blt     CS_true
1471-20 32           965 ( 3)         bra     CS_false
1473-                966
1473-3C              967 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1474-DE 82           968 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1476-EC 02           969 ( 5)         ldd     2,x
1478-A3 00           970 ( 5)         subd    0,x
147A-2F 23           971 ( 3)         ble     CS_true
147C-20 27           972 ( 3)         bra     CS_false
147E-                973
147E-3C              974 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
147F-DE 82           975 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1481-EC 02           976 ( 5)         ldd     2,x
1483-A3 00           977 ( 5)         subd    0,x
1485-26 18           978 ( 3)         bne     CS_true
1487-20 1C           979 ( 3)         bra     CS_false
1489-                980
1489-3C              981 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
148A-DE 82           982 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
148C-EC 02           983 ( 5)         ldd     2,x
148E-A3 00           984 ( 5)         subd    0,x
1490-2E 0D           985 ( 3)         bgt     CS_true
1492-20 11           986 ( 3)         bra     CS_false
1494-                987
1494-3C              988 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
1495-DE 82           989 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1497-EC 02           990 ( 5)         ldd     2,x
1499-A3 00           991 ( 5)         subd    0,x
149B-2C 02           992 ( 3)         bge     CS_true
149D-20 06           993 ( 3)         bra     CS_false
149F-                994
149F-                995      CS_true:
149F-CC 00 01        996 ( 3)         ldd     #1
14A2-7E 13 1F        997 ( 3)         jmp     CS_store
14A5-                998
14A5-                999      CS_false:
14A5-4F             1000 ( 1)         clra
14A6-5F             1001 ( 1)         clrb
14A7-7E 13 1F       1002 ( 3)         jmp     CS_store
14AA-               1003
14AA-               1004      ; -----------------------------------------------------------------------
14AA-               1005      ; テキストバッファの10進文字列から数値を取得する
14AA-               1006      ; Get a integer from a decimal string in a text buffer
14AA-               1007      ;【引数】X:バッファアドレス
14AA-               1008      ;【使用】A, B, X, UR0, UR1
14AA-               1009      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
14AA-               1010      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
14AA-               1011      ; -----------------------------------------------------------------------
14AA-               1012      get_int_from_decimal:
00A9-               1013      .RetValue       .eq     UR0     ; Return Value
00AB-               1014      .TempValue      .eq     UR1     ; Temporary Value
14AA-4F             1015 ( 1)         clra
14AB-5F             1016 ( 1)         clrb
14AC-DD A9          1017 ( 4)         std     <:RetValue
14AE-97 AB          1018 ( 3)         staa    <:TempValue
14B0-97 84          1019 ( 3)         staa    <SignFlag
14B2-E6 00          1020 ( 4)         ldab    0,x             ; 1文字取得
14B4-C1 2D          1021 ( 2)         cmpb    #'-'            ; マイナス記号か？
14B6-26 05          1022 ( 3)         bne     :1
14B8-7C 00 84       1023 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
14BB-20 0B          1024 ( 3)         bra     :next
14BD-C1 2B          1025 ( 2) .1      cmpb    #'+'            ; プラス記号か？
14BF-27 07          1026 ( 3)         beq     :next
14C1-BD FF C1       1027 ( 6)         jsr     is_decimal_char ; 数字か？
14C4-24 36          1028 ( 3)         bcc     :false          ; No. C=1で終了
14C6-20 13          1029 ( 3)         bra     :first
14C8-08             1030 ( 1) .next   inx                     ; 符号の次の1文字を取得
14C9-E6 00          1031 ( 4)         ldab    0,x
14CB-BD FF C1       1032 ( 6)         jsr     is_decimal_char ; 数字か？
14CE-24 40          1033 ( 3)         bcc     :err04          ; No. エラー処理へ
14D0-20 09          1034 ( 3)         bra     :first          ; Yes. これが最初の数字
14D2-DD A9          1035 ( 4) .loop   std     <:RetValue      ; 結果を退避
14D4-E6 00          1036 ( 4)         ldab    0,x             ; 1文字取得
14D6-BD FF C1       1037 ( 6)         jsr     is_decimal_char ; 数字か？
14D9-24 14          1038 ( 3)         bcc     :end
14DB-C0 30          1039 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
14DD-D7 AC          1040 ( 3)         stab    <:TempValue+1
14DF-               1041            ; // RetValue * 10 + TempValue
14DF-DC A9          1042 ( 4)         ldd     <:RetValue
14E1-05             1043 ( 1)         asld                    ; * 2
14E2-05             1044 ( 1)         asld                    ; * 4
14E3-D3 A9          1045 ( 4)         addd    <:RetValue      ; * 5
14E5-05             1046 ( 1)         asld                    ; * 10
14E6-D3 AB          1047 ( 4)         addd    <:TempValue     ; += TempValue
14E8-08             1048 ( 1)         inx                     ; ポインタを進める
14E9-25 20          1049 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
14EB-2B 10          1050 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
14ED-20 E3          1051 ( 3)         bra     :loop
14EF-DC A9          1052 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
14F1-7D 00 84       1053 ( 4)         tst     <SignFlag       ; 符号チェック
14F4-27 05          1054 ( 3)         beq     :true
14F6-43             1055 ( 1)         coma                    ; 負なら2の補数に
14F7-53             1056 ( 1)         comb
14F8-C3 00 01       1057 ( 3)         addd    #1
14FB-0D             1058 ( 1) .true   sec
14FC-39             1059 ( 5) .false  rts
14FD-               1060
14FD-               1061      .overflow
14FD-               1062            ; // -32,768かどうかの判定
14FD-18             1063 ( 2)         xgdx
14FE-8C 80 00       1064 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
1501-18             1065 ( 2)         xgdx
1502-26 07          1066 ( 3)         bne     :err02          ; No. 範囲外
1504-7D 00 84       1067 ( 4)         tst     <SignFlag       ; 符号チェック
1507-27 02          1068 ( 3)         beq     :err02          ; 正ならば範囲外
1509-20 C7          1069 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
150B-               1070
150B-86 02          1071 ( 2) .err02  ldaa    #2              ; "Out of range"
150D-7E 18 CA       1072 ( 3)         jmp     write_err_msg
1510-86 04          1073 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1512-7E 18 CA       1074 ( 3)         jmp     write_err_msg
1515-               1075
1515-               1076
1515-               1077      ; -----------------------------------------------------------------------
1515-               1078      ; Dレジスタの数値をコンソールに出力する
1515-               1079      ; Write Decimal Character converted from Integer
1515-               1080      ;【引数】D:Integer
1515-               1081      ;【使用】A, B, X
1515-               1082      ;【返値】なし
1515-               1083      ; -----------------------------------------------------------------------
1515-               1084      write_integer:
00A9-               1085      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00AA-               1086      .Counter        .eq     UR0L    ; 桁カウンター
1515-2A 0C          1087 ( 3)         bpl     :plus           ; 符号判定
1517-37             1088 ( 4)         pshb                    ; 負数なら'-'を出力する
1518-C6 2D          1089 ( 2)         ldab    #'-'
151A-BD FF AC       1090 ( 6)         jsr     write_char
151D-33             1091 ( 3)         pulb
151E-43             1092 ( 1)         coma                    ; 絶対値にする（2の補数にする）
151F-53             1093 ( 1)         comb
1520-C3 00 01       1094 ( 3)         addd    #1
1523-7F 00 A9       1095 ( 5) .plus   clr     <:ZeroSuppress
1526-CE 15 56       1096 ( 3)         ldx     #:CONST
1529-7F 00 AA       1097 ( 5) .loop   clr     <:Counter
152C-A3 00          1098 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
152E-25 05          1099 ( 3)         bcs     :write
1530-7C 00 AA       1100 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1533-20 F7          1101 ( 3)         bra     :digit
1535-               1102
1535-E3 00          1103 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1537-37             1104 ( 4)         pshb
1538-D6 AA          1105 ( 3)         ldab    <:Counter
153A-27 03          1106 ( 3)         beq     :1              ; この桁はゼロか？
153C-7C 00 A9       1107 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
153F-7D 00 A9       1108 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1542-27 05          1109 ( 3)         beq     :2              ; No. この桁は表示しない
1544-CB 30          1110 ( 2)         addb    #$30            ; Yes. この桁を表示する
1546-BD FF AC       1111 ( 6)         jsr     write_char
1549-33             1112 ( 3) .2      pulb
154A-08             1113 ( 1)         inx                     ; 次の引く数へ
154B-08             1114 ( 1)         inx
154C-8C 15 5E       1115 ( 3)         cpx     #:CONST+8
154F-26 D8          1116 ( 3)         bne     :loop
1551-CB 30          1117 ( 2)         addb    #$30            ; 一の桁の数値を表示
1553-7E FF AC       1118 ( 3)         jmp     write_char
1556-               1119      ; Dから引いていく数
1556-27 10          1120      .CONST  .dw     $2710           ; 10,000
1558-03 E8          1121              .dw     $03e8           ; 1,000
155A-00 64          1122              .dw     $0064           ; 100
155C-00 0A          1123              .dw     $000a           ; 10
155E-               1124
155E-               1125
155E-               1126      ; -----------------------------------------------------------------------
155E-               1127      ; テキストバッファの英文字が変数か判定する
155E-               1128      ; Is a character retrieved from a text buffer a variable?
155E-               1129      ;【引数】X:バッファアドレス
155E-               1130      ;【使用】A, B, X
155E-               1131      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
155E-               1132      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
155E-               1133      ; -----------------------------------------------------------------------
155E-               1134      is_variable:
155E-E6 00          1135 ( 4)         ldab    0,x
1560-BD FF BE       1136 ( 6)         jsr     is_alphabetic_char
1563-24 0D          1137 ( 3)         bcc     :end
1565-17             1138 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1566-E6 01          1139 ( 4)         ldab    1,x                     ; 2文字目を取得
1568-BD FF BE       1140 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
156B-16             1141 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
156C-24 02          1142 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
156E-0C             1143 ( 1)         clc                             ; Yes. 変数ではない。C=0
156F-39             1144 ( 5)         rts
1570-08             1145 ( 1) .var    inx                             ; ポインタを進める
1571-0D             1146 ( 1)         sec                             ; C=1
1572-39             1147 ( 5) .end    rts
1573-               1148
1573-               1149
1573-               1150      ; -----------------------------------------------------------------------
1573-               1151      ; 空白を読み飛ばす
1573-               1152      ; Skip Space
1573-               1153      ;【引数】X:実行位置アドレス
1573-               1154      ;【使用】B, X
1573-               1155      ;【返値】B:アスキーコード（$00の時Z=1）
1573-               1156      ;        X:実行位置アドレス
1573-               1157      ; -----------------------------------------------------------------------
1573-               1158      skip_space:
1573-E6 00          1159 ( 4)         ldab    0,x
1575-27 07          1160 ( 3)         beq     :end
1577-C1 20          1161 ( 2)         cmpb    #SPACE
1579-22 03          1162 ( 3)         bhi     :end
157B-08             1163 ( 1)         inx
157C-20 F5          1164 ( 3)         bra     skip_space
157E-39             1165 ( 5) .end    rts
157F-               1166
157F-               1167
157F-               1168      ; -----------------------------------------------------------------------
157F-               1169      ; 引用符付きの文字列を出力する
157F-               1170      ; Write Quoted Stirng
157F-               1171      ;【引数】B:アスキーコード X:実行位置アドレス
157F-               1172      ;【使用】A, B, X
157F-               1173      ;【返値】真(C=1) / X:次の実行位置アドレス
157F-               1174      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
157F-               1175      ; -----------------------------------------------------------------------
157F-               1176      write_quoted_str:
157F-C1 22          1177 ( 2)         cmpb    #$22            ; 一重引用符か？
1581-27 04          1178 ( 3)         beq     :1
1583-C1 27          1179 ( 2)         cmpb    #$27            ; 二重引用符か？
1585-26 19          1180 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
1587-17             1181 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
1588-               1182            ; // 終端の引用符をチェック
1588-3C             1183 ( 5)         pshx
1589-08             1184 ( 1) .check  inx
158A-E6 00          1185 ( 4)         ldab    0,x
158C-27 14          1186 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
158E-11             1187 ( 1)         cba
158F-26 F8          1188 ( 3)         bne     :check
1591-38             1189 ( 4)         pulx
1592-               1190            ; // 文字列の出力
1592-08             1191 ( 1) .loop   inx
1593-E6 00          1192 ( 4)         ldab    0,x
1595-11             1193 ( 1)         cba                     ; 保存した引用符との比較
1596-27 05          1194 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
1598-BD FF AC       1195 ( 6)         jsr     write_char
159B-20 F5          1196 ( 3)         bra     :loop
159D-08             1197 ( 1) .true   inx
159E-0D             1198 ( 1)         sec
159F-39             1199 ( 5)         rts
15A0-0C             1200 ( 1) .false  clc
15A1-39             1201 ( 5)         rts
15A2-86 0A          1202 ( 2) .err10  ldaa    #10             ; "Print statement error"
15A4-7E 18 CA       1203 ( 3)         jmp     write_err_msg
15A7-               1204
15A7-               1205
15A7-               1206      ; -----------------------------------------------------------------------
15A7-               1207      ; タブを出力する
15A7-               1208      ; Write tabs
15A7-               1209      ;【引数】なし
15A7-               1210      ;【使用】B
15A7-               1211      ;【返値】なし
15A7-               1212      ; -----------------------------------------------------------------------
15A7-               1213      write_tab:
15A7-BD FF B5       1214 ( 6) .top    jsr     write_space
15AA-7B 07 39       1215 ( 4)         tim     #7,<TabCount
15AD-26 F8          1216 ( 3)         bne     :top
15AF-39             1217 ( 5)         rts
15B0-               1218
15B0-               1219
15B0-               1220      ; -----------------------------------------------------------------------
15B0-               1221      ; 配列変数のアドレスを取得する
15B0-               1222      ; Set the address of the array variable
15B0-               1223      ;【引数】D:添字
15B0-               1224      ;【使用】A, B
15B0-               1225      ;【返値】D:配列変数のアドレス
15B0-               1226      ; -----------------------------------------------------------------------
15B0-               1227      set_array_addr:
15B0-18             1228 ( 2)         xgdx
15B1-9C A5          1229 ( 4)         cpx     <MaxSubscript   ; 取得した添字 > 添字の最大値？
15B3-22 09          1230 ( 3)         bhi     :err22          ; Yes. エラー処理
15B5-18             1231 ( 2)         xgdx
15B6-05             1232 ( 1)         asld                    ; 添字を2倍にする
15B7-D3 A3          1233 ( 4)         addd    <ArrayAddr
15B9-39             1234 ( 5)         rts
15BA-4F             1235 ( 1) .err00  clra                    ; "Syntax error"
15BB-7E 18 CA       1236 ( 3)         jmp     write_err_msg
15BE-86 16          1237 ( 2) .err22  ldaa    #22             ; "Subscript is out of range"
15C0-7E 18 CA       1238 ( 3)         jmp     write_err_msg
15C3-               1239
15C3-               1240
15C3-               1241      ; -----------------------------------------------------------------------
15C3-               1242      ; 式を評価して変数に値を代入する
15C3-               1243      ; Evaluate an expression and assign a value to a variable
15C3-               1244      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
15C3-               1245      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
15C3-               1246      ;【返値】D:Integer X:次の実行位置アドレス
15C3-               1247      ; -----------------------------------------------------------------------
15C3-               1248      assign_to_var:
15C3-BD 15 73       1249 ( 6)         jsr     skip_space
15C6-BD 11 EC       1250 ( 6)         jsr     eval_expression
15C9-24 07          1251 ( 3)         bcc     :err04
15CB-3C             1252 ( 5)         pshx                    ; 実行位置アドレスを退避
15CC-DE 8B          1253 ( 4)         ldx     <VariableAddr
15CE-ED 00          1254 ( 5)         std     0,x             ; 変数に結果を保存
15D0-38             1255 ( 4)         pulx                    ; 実行位置アドレスを復帰
15D1-39             1256 ( 5)         rts
15D2-86 04          1257 ( 2) .err04  ldaa    #4              ; "Illegal expression"
15D4-7E 18 CA       1258 ( 3)         jmp     write_err_msg
15D7-               1259
15D7-               1260
15D7-               1261      ; -----------------------------------------------------------------------
15D7-               1262      ; 同じ行番号を検索する
15D7-               1263      ; Scan equal line number
15D7-               1264      ;【引数】LineNumber:検索対象の行番号 X:検索を開始する行頭アドレス
15D7-               1265      ;【使用】A, B, X
15D7-               1266      ;【返値】真(C=1) / D:行番号 X:その行の開始アドレス
15D7-               1267      ;        偽(C=0) / D:次に大きな行番号 X:次に大きな行の開始アドレス
15D7-               1268      ;                  またはD:$0000 X:プログラム終了アドレス
15D7-               1269      ; -----------------------------------------------------------------------
15D7-               1270      scan_line_num:
15D7-EC 00          1271 ( 5) .loop   ldd     0,x             ; D:行番号
15D9-27 0F          1272 ( 3)         beq     :false          ; プログラム終端まで来たので偽
15DB-18             1273 ( 2)         xgdx
15DC-9C 96          1274 ( 4)         cpx     <LineNumber
15DE-18             1275 ( 2)         xgdx
15DF-27 07          1276 ( 3)         beq     :true           ; 同一の行番号が見つかったので真
15E1-2E 07          1277 ( 3)         bgt     :false          ; 対象の行番号より大きくなったので偽
15E3-E6 02          1278 ( 4)         ldab    2,x
15E5-3A             1279 ( 1)         abx
15E6-20 EF          1280 ( 3)         bra     :loop
15E8-0D             1281 ( 1) .true   sec
15E9-39             1282 ( 5)         rts
15EA-0C             1283 ( 1) .false  clc
15EB-39             1284 ( 5)         rts
15EC-               1285
15EC-               1286
15EC-               1287      ; -----------------------------------------------------------------------
15EC-               1288      ; runコマンドを実行する
15EC-               1289      ; Execute 'run' command
15EC-               1290      ;【引数】なし
15EC-               1291      ;【使用】A, B, X
15EC-               1292      ;【返値】なし
15EC-               1293      ; -----------------------------------------------------------------------
15EC-               1294      exe_run:
15EC-               1295            ; // 乱数のSeed値の設定
15EC-DC 09          1296 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
15EE-27 FC          1297 ( 3)         beq     :seed           ; Seedはゼロ以外
15F0-DD A7          1298 ( 4)         std     <RndNumber
15F2-               1299            ; // 変数領域の初期化
15F2-CE 02 C2       1300 ( 3)         ldx     #VARIABLE
15F5-4F             1301 ( 1)         clra
15F6-5F             1302 ( 1)         clrb
15F7-ED 00          1303 ( 5) .1      std     0,x
15F9-08             1304 ( 1)         inx
15FA-08             1305 ( 1)         inx
15FB-8C 02 F6       1306 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
15FE-26 F7          1307 ( 3)         bne     :1
1600-7F 00 9C       1308 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
1603-CE 04 00       1309 ( 3)         ldx     #USER_AREA_TOP
1606-DF 9D          1310 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
1608-EC 00          1311 ( 5)         ldd     0,x
160A-27 08          1312 ( 3)         beq     :end            ; 行番号が$0000なら終了
160C-08             1313 ( 1)         inx
160D-08             1314 ( 1)         inx
160E-08             1315 ( 1)         inx
160F-BD 11 8A       1316 ( 6)         jsr     exe_line        ; 一行実行
1612-20 F2          1317 ( 3)         bra     :loop
1614-7E 10 34       1318 ( 3) .end    jmp     tb_main
1617-               1319
1617-               1320
1617-               1321      ; -----------------------------------------------------------------------
1617-               1322      ; listコマンドを実行する
1617-               1323      ; Execute 'list' command
1617-               1324      ;【引数】なし
1617-               1325      ;【使用】A, B, X
1617-               1326      ;【返値】なし
1617-               1327      ; -----------------------------------------------------------------------
1617-               1328      exe_list:
1617-CE 04 00       1329 ( 3)         ldx     #USER_AREA_TOP
161A-               1330            ; // 行番号出力
161A-EC 00          1331 ( 5) .loop   ldd     0,x
161C-27 11          1332 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
161E-3C             1333 ( 5)         pshx
161F-BD 15 15       1334 ( 6)         jsr     write_integer
1622-38             1335 ( 4)         pulx
1623-               1336            ; // 本文出力
1623-08             1337 ( 1)         inx                     ; 本文までスキップ
1624-08             1338 ( 1)         inx
1625-08             1339 ( 1)         inx
1626-BD FF AF       1340 ( 6)         jsr     write_line
1629-BD FF B2       1341 ( 6)         jsr     write_crlf
162C-08             1342 ( 1)         inx                     ; 次の行番号へ
162D-20 EB          1343 ( 3)         bra     :loop
162F-7E 10 34       1344 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1632-               1345
1632-               1346
1632-               1347      ; -----------------------------------------------------------------------
1632-               1348      ; Print文を実行する
1632-               1349      ; Execute 'print' statement
1632-               1350      ;【引数】X:実行位置アドレス
1632-               1351      ;【使用】B, X（下位ルーチンでA）
1632-               1352      ;【返値】なし
1632-               1353      ; -----------------------------------------------------------------------
1632-               1354      exe_print:
1632-72 01 8F       1355 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1635-BD 15 73       1356 ( 6) .loop   jsr     skip_space
1638-27 37          1357 ( 3)         beq     :finish         ; 終端文字なら改行して終了
163A-BD 15 7F       1358 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
163D-25 1B          1359 ( 3)         bcs     :nlon
163F-BD 11 EC       1360 ( 6)         jsr     eval_expression
1642-25 11          1361 ( 3)         bcs     :int
1644-               1362            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
1644-               1363            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
1644-C1 3B          1364 ( 2) .check  cmpb    #';'
1646-27 23          1365 ( 3)         beq     :nloff
1648-C1 2C          1366 ( 2)         cmpb    #','
164A-27 1C          1367 ( 3)         beq     :tab
164C-C1 3A          1368 ( 2)         cmpb    #':'
164E-27 21          1369 ( 3)         beq     :finish
1650-86 04          1370 ( 2)         ldaa    #4              ; "Illegal expression"
1652-7E 18 CA       1371 ( 3)         jmp     write_err_msg
1655-3C             1372 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1656-BD 15 15       1373 ( 6)         jsr     write_integer   ; 評価した式を出力
1659-38             1374 ( 4)         pulx                    ; 実行位置アドレスを復帰
165A-72 01 8F       1375 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
165D-BD 15 73       1376 ( 6)         jsr     skip_space
1660-C1 3B          1377 ( 2)         cmpb    #';'
1662-27 07          1378 ( 3)         beq     :nloff
1664-C1 2C          1379 ( 2)         cmpb    #','
1666-26 09          1380 ( 3)         bne     :finish
1668-BD 15 A7       1381 ( 6) .tab    jsr     write_tab       ; タブ出力
166B-7F 00 8F       1382 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
166E-08             1383 ( 1)         inx                     ; 次の文字へ
166F-20 C4          1384 ( 3)         bra     :loop
1671-7D 00 8F       1385 ( 4) .finish tst     <NewLineFlag
1674-27 03          1386 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1676-BD FF B2       1387 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
1679-7E 11 6A       1388 ( 3) .end    jmp     is_multi
167C-               1389
167C-               1390
167C-               1391      ; -----------------------------------------------------------------------
167C-               1392      ; input文を実行する
167C-               1393      ; Execute 'input' statement
167C-               1394      ; -----------------------------------------------------------------------
167C-               1395      exe_input:
167C-BD 15 73       1396 ( 6)         jsr     skip_space
167F-27 31          1397 ( 3)         beq     :end            ; 終端文字なら改行して終了
1681-BD 15 7F       1398 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1684-24 0A          1399 ( 3)         bcc     :1
1686-E6 00          1400 ( 4)         ldab    0,x
1688-C1 3B          1401 ( 2)         cmpb    #';'
168A-26 29          1402 ( 3)         bne     :err00
168C-08             1403 ( 1)         inx
168D-BD 15 73       1404 ( 6)         jsr     skip_space
1690-BD 15 5E       1405 ( 6) .1      jsr     is_variable
1693-24 20          1406 ( 3)         bcc     :err00
1695-86 02          1407 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1697-58             1408 ( 1)         aslb                    ; B = 変数領域の下位バイト
1698-DD 8B          1409 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
169A-               1410            ; // 変数の後に余計な文字がないか確認
169A-               1411            ; // 例えば "input a+b" など
169A-DF 8D          1412 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
169C-BD 15 73       1413 ( 6)         jsr     skip_space
169F-27 06          1414 ( 3)         beq     :read           ; 終端文字なら入力へ
16A1-C1 3A          1415 ( 2)         cmpb    #':'            ; ":"なら入力へ
16A3-26 10          1416 ( 3)         bne     :err00          ; それ以外の文字ならエラー
16A5-DE 8D          1417 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16A7-BD FF A9       1418 ( 6) .read   jsr     read_line
16AA-CE 01 40       1419 ( 3)         ldx     #TEXT_BFFR
16AD-BD 15 C3       1420 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
16B0-DE 8D          1421 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16B2-7E 11 6A       1422 ( 3) .end    jmp     is_multi
16B5-4F             1423 ( 1) .err00  clra                    ; "Syntax error"
16B6-7E 18 CA       1424 ( 3)         jmp     write_err_msg
16B9-               1425
16B9-               1426
16B9-               1427      ; -----------------------------------------------------------------------
16B9-               1428      ; if文を実行する
16B9-               1429      ; Execute 'if' statement
16B9-               1430      ;【引数】X:実行位置アドレス
16B9-               1431      ;【使用】B, X
16B9-               1432      ;【返値】なし
16B9-               1433      ; -----------------------------------------------------------------------
16B9-BD 15 73       1434 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
16BC-27 0B          1435 ( 3)         beq     :end            ; 終端文字なら終了
16BE-BD 11 EC       1436 ( 6)         jsr     eval_expression ; 式評価
16C1-24 09          1437 ( 3)         bcc     :err04
16C3-5D             1438 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
16C4-27 03          1439 ( 3)         beq     :end
16C6-7E 11 8A       1440 ( 3)         jmp     exe_line        ; True
16C9-7E 11 7A       1441 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
16CC-86 04          1442 ( 2) .err04  ldaa    #4              ; "Illegal expression"
16CE-7E 18 CA       1443 ( 3)         jmp     write_err_msg
16D1-               1444
16D1-               1445
16D1-               1446      ; -----------------------------------------------------------------------
16D1-               1447      ; gosub文を実行する
16D1-               1448      ; Execute 'gosub' statement
16D1-               1449      ;【引数】X:実行位置アドレス
16D1-               1450      ;【使用】A, B, X
16D1-               1451      ;【返値】なし
16D1-               1452      ; -----------------------------------------------------------------------
16D1-               1453      exe_gosub:
16D1-72 01 A0       1454 ( 6)         oim     #1,<ToSubFlag   ; 分岐モードを1 = gosubにする
16D4-               1455              ; そのままexe_gotoに続く
16D4-               1456
16D4-               1457
16D4-               1458      ; -----------------------------------------------------------------------
16D4-               1459      ; goto文を実行する
16D4-               1460      ; Execute 'goto' statement
16D4-               1461      ;【引数】X:実行位置アドレス
16D4-               1462      ;【使用】A, B, X
16D4-               1463      ;【返値】なし
16D4-               1464      ; -----------------------------------------------------------------------
16D4-               1465      exe_goto:
16D4-BD 15 73       1466 ( 6)         jsr     skip_space      ; 空白を読み飛ばし
16D7-27 3F          1467 ( 3)         beq     :err00          ; 終端文字"Syntax error"
16D9-BD 11 EC       1468 ( 6)         jsr     eval_expression ; 式評価
16DC-24 3E          1469 ( 3)         bcc     :err04          ; "Illegal expression"
16DE-2B 41          1470 ( 3)         bmi     :err12          ; "Invalid line number"
16E0-DD 96          1471 ( 4)         std     <LineNumber     ; 飛び先になる行番号を一時保存
16E2-7D 00 A0       1472 ( 4)         tst     ToSubFlag
16E5-27 17          1473 ( 3)         beq     :to             ; 分岐モードが0=gotoなら:toへ
16E7-18             1474 ( 2)         xgdx                    ; D = ExePointer
16E8-DE A1          1475 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
16EA-8C 02 28       1476 ( 3)         cpx     #SSTACK         ; 既にスタック最上位か？
16ED-27 3C          1477 ( 3)         beq     :err18          ; Yes. "Subroutine stack overflow"
16EF-09             1478 ( 1)         dex
16F0-09             1479 ( 1)         dex
16F1-ED 00          1480 ( 5)         std     0,x             ; ExePointerをスタックに積む
16F3-DC 9D          1481 ( 4)         ldd     <ExeLineAddr
16F5-09             1482 ( 1)         dex
16F6-09             1483 ( 1)         dex
16F7-ED 00          1484 ( 5)         std     0,x             ; ExeLineAddrをスタックに積む
16F9-DF A1          1485 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
16FB-7F 00 A0       1486 ( 5)         clr     ToSubFlag       ; 分岐モードを0 = gotoに戻す
16FE-DE 9D          1487 ( 4) .to     ldx     <ExeLineAddr    ; X <- 実行中の行の先頭アドレス
1700-EC 00          1488 ( 5)         ldd     0,x             ; 今実行している行の行番号を取得
1702-18             1489 ( 2)         xgdx
1703-9C 96          1490 ( 4)         cpx     <LineNumber     ; 現在の行番号と飛び先の行番号を比較
1705-18             1491 ( 2)         xgdx
1706-25 03          1492 ( 3)         bcs     :1              ; 現在の行番号 > 飛び先の行番号 = ここから検索
1708-CE 04 00       1493 ( 3)         ldx     #USER_AREA_TOP  ; 現在の行番号 < 飛び先の行番号 = 先頭から検索
170B-BD 15 D7       1494 ( 6) .1      jsr     scan_line_num   ; 同じ行番号を探す
170E-24 16          1495 ( 3)         bcc     :err16          ; "Undefined line number"
1710-DF 9D          1496 ( 4)         stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
1712-08             1497 ( 1)         inx
1713-08             1498 ( 1)         inx
1714-08             1499 ( 1)         inx
1715-7E 11 8A       1500 ( 3)         jmp     exe_line
1718-               1501
1718-4F             1502 ( 1) .err00  clra                    ; "Syntax error"
1719-7E 18 CA       1503 ( 3)         jmp     write_err_msg
171C-86 04          1504 ( 2) .err04  ldaa    #4              ; "Illegal expression"
171E-7E 18 CA       1505 ( 3)         jmp     write_err_msg
1721-86 0C          1506 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1723-7E 18 CA       1507 ( 3)         jmp     write_err_msg
1726-86 10          1508 ( 2) .err16  ldaa    #16             ; "Undefined line number"
1728-7E 18 CA       1509 ( 3)         jmp     write_err_msg
172B-86 12          1510 ( 2) .err18  ldaa    #18             ; "Subroutine stack overflow"
172D-7E 18 CA       1511 ( 3)         jmp     write_err_msg
1730-               1512
1730-               1513
1730-               1514      ; -----------------------------------------------------------------------
1730-               1515      ; return文を実行する
1730-               1516      ; Execute 'return' statement
1730-               1517      ;【引数】X:実行位置アドレス
1730-               1518      ;【使用】A, B, X
1730-               1519      ;【返値】なし
1730-               1520      ; -----------------------------------------------------------------------
1730-               1521      exe_return:
1730-DE A1          1522 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
1732-8C 02 50       1523 ( 3)         cpx     #SSTACK_BTM+1   ; 既にスタックの底か？
1735-27 10          1524 ( 3)         beq     :err20          ; Yes. "Return without gosub"
1737-EC 00          1525 ( 5)         ldd     0,x
1739-DD 9D          1526 ( 4)         std     <ExeLineAddr    ; ExeLineAddrをスタックから復帰
173B-08             1527 ( 1)         inx
173C-08             1528 ( 1)         inx
173D-EC 00          1529 ( 5)         ldd     0,x             ; D = ExePointer
173F-08             1530 ( 1)         inx
1740-08             1531 ( 1)         inx
1741-DF A1          1532 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
1743-18             1533 ( 2)         xgdx                    ; X = ExePointer
1744-7E 11 6A       1534 ( 3)         jmp     is_multi
1747-               1535
1747-86 14          1536 ( 2) .err20  ldaa    #20             ; "Return without gosub"
1749-7E 18 CA       1537 ( 3)         jmp     write_err_msg
174C-               1538
174C-               1539
174C-               1540      ; -----------------------------------------------------------------------
174C-               1541      ; trunc文を実行する
174C-               1542      ; Execute 'trunc' statement
174C-               1543      ;【引数】X:実行位置アドレス
174C-               1544      ;【使用】B, X
174C-               1545      ;【返値】なし
174C-               1546      ; -----------------------------------------------------------------------
174C-               1547      exe_trunc:
174C-7F 00 9F       1548 ( 5)         clr     <ModuloMode     ; tranc = 0 にする
174F-7E 11 6A       1549 ( 3)         jmp     is_multi
1752-               1550
1752-               1551
1752-               1552      ; -----------------------------------------------------------------------
1752-               1553      ; floor文を実行する
1752-               1554      ; Execute 'trunc' statement
1752-               1555      ;【引数】X:実行位置アドレス
1752-               1556      ;【使用】B, X
1752-               1557      ;【返値】なし
1752-               1558      ; -----------------------------------------------------------------------
1752-               1559      exe_floor:
1752-72 01 9F       1560 ( 6)         oim     #1,<ModuloMode  ; floor = 1以上 にする
1755-7E 11 6A       1561 ( 3)         jmp     is_multi
1758-               1562
1758-               1563
1758-               1564      ; -----------------------------------------------------------------------
1758-               1565      ; rnd関数を実行する
1758-               1566      ; Execute 'rnd' function
1758-               1567      ;【引数】X:実行位置アドレス
1758-               1568      ;【使用】A, B, X
1758-               1569      ;【返値】D:乱数値 X:次の実行位置アドレス
1758-               1570      ; -----------------------------------------------------------------------
1758-               1571      exe_rnd:
1758-               1572            ; // xorshiftで乱数生成
1758-D6 A7          1573 ( 3)         ldab    <RndNumber
175A-54             1574 ( 1)         lsrb
175B-D6 A8          1575 ( 3)         ldab    <RndNumber+1
175D-56             1576 ( 1)         rorb
175E-D8 A7          1577 ( 3)         eorb    <RndNumber
1760-D7 A7          1578 ( 3)         stab    <RndNumber
1762-56             1579 ( 1)         rorb
1763-D8 A8          1580 ( 3)         eorb    <RndNumber+1
1765-D7 A8          1581 ( 3)         stab    <RndNumber+1
1767-17             1582 ( 1)         tba
1768-98 A7          1583 ( 3)         eora    <RndNumber
176A-97 A7          1584 ( 3)         staa    <RndNumber
176C-84 7F          1585 ( 2)         anda    #$7f            ; 生成される乱数は0〜32,767となる
176E-BD 12 FF       1586 ( 6)         jsr     expr_1st:push   ; 乱数を計算スタックにプッシュ
1771-BD 12 02       1587 ( 6)         jsr     expr_4th        ; 引数を取得する
1774-               1588            ; // ')'の確認
1774-C1 29          1589 ( 2)         cmpb    #')'
1776-26 1D          1590 ( 3)         bne     :err00
1778-3C             1591 ( 5)         pshx                    ; 実行位置アドレスを退避
1779-               1592            ; // 計算スタックの引数を+1する
1779-DE 82          1593 ( 4)         ldx     <CStackPtr
177B-EC 00          1594 ( 5)         ldd     0,x
177D-2F 1A          1595 ( 3)         ble     :err02          ; 引数が正の実数でなければ"Out of range"
177F-C3 00 01       1596 ( 3)         addd    #1
1782-ED 00          1597 ( 5)         std     0,x
1784-DF 82          1598 ( 4)         stx     <CStackPtr
1786-               1599            ; // rnd(32768)の場合、生成された乱数を32768+1つまり-32768で割らないといけない
1786-               1600            ; // 結果を正の数とするために一時的にtruncモードにする
1786-D6 9F          1601 ( 3)         ldab    <ModuloMode     ; 剰余演算フラグを保存
1788-37             1602 ( 4)         pshb
1789-7F 00 9F       1603 ( 5)         clr     ModuloMode      ; 剰余演算フラグをtrancにする
178C-BD 13 6F       1604 ( 6)         jsr     CS_mod          ; 乱数 / (引数 + 1)
178F-33             1605 ( 3)         pulb                    ; 剰余演算フラグを復帰
1790-D7 9F          1606 ( 3)         stab    <ModuloMode
1792-38             1607 ( 4)         pulx                    ; 実行位置アドレスを復帰
1793-08             1608 ( 1)         inx                     ; 次の実行位置アドレスに
1794-39             1609 ( 5)         rts                     ; expr_2ndの2行目に戻る
1795-4F             1610 ( 1) .err00  clra                    ; "Syntax error"
1796-7E 18 CA       1611 ( 3)         jmp     write_err_msg
1799-86 02          1612 ( 2) .err02  ldaa    #2              ; "Out of range"
179B-7E 18 CA       1613 ( 3)         jmp     write_err_msg
179E-               1614
179E-               1615
179E-               1616      ; ------------------------------------------------
179E-               1617      ; ブロック転送
179E-               1618      ; Move memory
179E-               1619      ;【引数】Source:転送元アドレス
179E-               1620      ;        Destination:転送先アドレス
179E-               1621      ;        Bytes:転送バイト数
179E-               1622      ;【使用】A, B, X, UR0
179E-               1623      ;【返値】なし
179E-               1624      ; ------------------------------------------------
179E-               1625      mem_move:
179E-DC 94          1626 ( 4)         ldd     <Bytes
17A0-27 0A          1627 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
17A2-DC 90          1628 ( 4)         ldd     <Source
17A4-93 92          1629 ( 4)         subd    <Destination    ; Source - Destination
17A6-27 04          1630 ( 3)         beq     :end            ; 転送元と転送先が同じなら即終了
17A8-24 03          1631 ( 3)         bcc     LDIR            ; Source > Destination
17AA-20 31          1632 ( 3)         bra     LDDR            ; Source < Destination
17AC-39             1633 ( 5) .end    rts
17AD-               1634
17AD-               1635      ; ------------------------------------------------
17AD-               1636      ; 前方から転送（LDIR）
17AD-               1637      ; Load, Increment and Repeat
17AD-               1638      ;【引数】Source:転送元アドレス
17AD-               1639      ;        Destination:転送先アドレス
17AD-               1640      ;        Bytes:転送バイト数
17AD-               1641      ;【使用】A, B, X, UR0
17AD-               1642      ;【返値】なし
17AD-               1643      ; ------------------------------------------------
17AD-               1644      LDIR:
00A9-               1645      .Offset .eq     UR0
17AD-               1646             ; // オフセットの計算。既にDレジスタに入っている
17AD-DD A9          1647 ( 4)        std     <:Offset        ; Offset = Source - Destination
17AF-               1648            ; // 終了判定用のアドレスを計算
17AF-DC 90          1649 ( 4)         ldd     <Source         ; 転送終了アドレス = Source - Bytes
17B1-D3 94          1650 ( 4)         addd    <Bytes
17B3-DD 92          1651 ( 4)         std     <Destination    ; 転送終了アドレスをDestinationに代入
17B5-               1652            ; // 転送開始
17B5-DE 90          1653 ( 4)         ldx     <Source         ; 転送開始アドレスをXに代入
17B7-               1654            ; // 転送するバイト数が奇数か偶数か判断。
17B7-               1655            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
17B7-DC 94          1656 ( 4)         ldd     <Bytes
17B9-04             1657 ( 1)         lsrd                    ; 転送バイト数 / 2, 奇数ならC=1
17BA-24 0E          1658 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
17BC-               1659            ; // Byte転送
17BC-A6 00          1660 ( 4)         ldaa    0,x             ; A <- [Source]
17BE-18             1661 ( 2)         xgdx                    ; D = address, X = data
17BF-93 A9          1662 ( 4)         subd    <:Offset        ; Source - Offset = Destination
17C1-18             1663 ( 2)         xgdx                    ; D = data, X = address
17C2-A7 00          1664 ( 4)         staa    0,x             ; [Destination] <- A
17C4-18             1665 ( 2)         xgdx                    ; D = address, X = data
17C5-D3 A9          1666 ( 4)         addd    <:Offset        ; Destination + Offset = Source
17C7-18             1667 ( 2)         xgdx                    ; D = data, X = address
17C8-20 0D          1668 ( 3)         bra     :odd            ; 飛び先でinx
17CA-               1669            ; // Word転送
17CA-EC 00          1670 ( 5) .loop   ldd     0,x
17CC-18             1671 ( 2)         xgdx
17CD-93 A9          1672 ( 4)         subd    <:Offset
17CF-18             1673 ( 2)         xgdx
17D0-ED 00          1674 ( 5)         std     0,x
17D2-18             1675 ( 2)         xgdx
17D3-D3 A9          1676 ( 4)         addd    <:Offset
17D5-18             1677 ( 2)         xgdx
17D6-08             1678 ( 1)         inx
17D7-08             1679 ( 1) .odd    inx
17D8-9C 92          1680 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
17DA-26 EE          1681 ( 3)         bne     :loop
17DC-39             1682 ( 5)         rts
17DD-               1683
17DD-               1684      ; ------------------------------------------------
17DD-               1685      ; 後方から転送（LDDR）
17DD-               1686      ; Load, Decrement and Repeat
17DD-               1687      ;【引数】Source:転送元アドレス
17DD-               1688      ;        Destination:転送先アドレス
17DD-               1689      ;        Bytes:転送バイト数
17DD-               1690      ;【使用】A, B, X, UR0
17DD-               1691      ;【返値】なし
17DD-               1692      ; ------------------------------------------------
17DD-               1693      LDDR:
00A9-               1694      .Offset .eq     UR0
17DD-               1695            ; // オフセットの計算
17DD-DC 92          1696 ( 4)         ldd     <Destination
17DF-93 90          1697 ( 4)         subd    <Source
17E1-DD A9          1698 ( 4)         std     <:Offset         ; Offset = Destination - Source
17E3-               1699            ; // 転送終了アドレスは既にDestinationに代入済み
17E3-               1700            ; // 転送開始アドレスの計算。一番後ろから
17E3-DC 90          1701 ( 4)         ldd     <Source         ; 転送開始アドレス = Source + Bytes
17E5-D3 94          1702 ( 4)         addd    <Bytes
17E7-18             1703 ( 2)         xgdx                    ; X = 転送開始アドレス
17E8-               1704            ; // 転送するバイト数が奇数か偶数か判断。
17E8-               1705            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
17E8-DC 94          1706 ( 4)         ldd     <Bytes
17EA-04             1707 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
17EB-24 0F          1708 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
17ED-               1709            ; // Byte転送
17ED-09             1710 ( 1)         dex
17EE-A6 00          1711 ( 4)         ldaa    0,x             ; A <- [Source]
17F0-18             1712 ( 2)         xgdx                    ; D = address, X = data
17F1-D3 A9          1713 ( 4)         addd    <:Offset        ; Source + Offset = Destination
17F3-18             1714 ( 2)         xgdx                    ; D = data, X = address
17F4-A7 00          1715 ( 4)         staa    0,x             ; [Destination] <- A
17F6-18             1716 ( 2)         xgdx                    ; D = address, X = data
17F7-93 A9          1717 ( 4)         subd    <:Offset        ; Destination - Offset = Source
17F9-18             1718 ( 2)         xgdx                    ; D = data, X = address
17FA-20 0E          1719 ( 3)         bra     :odd
17FC-               1720            ; // Word転送
17FC-09             1721 ( 1) .loop   dex
17FD-09             1722 ( 1)         dex
17FE-EC 00          1723 ( 5)         ldd     0,x
1800-18             1724 ( 2)         xgdx
1801-D3 A9          1725 ( 4)         addd    <:Offset
1803-18             1726 ( 2)         xgdx
1804-ED 00          1727 ( 5)         std     0,x
1806-18             1728 ( 2)         xgdx
1807-93 A9          1729 ( 4)         subd    <:Offset
1809-18             1730 ( 2)         xgdx
180A-9C 90          1731 ( 4) .odd    cpx     <Source         ; 転送終了アドレスと現在のアドレスを比較
180C-26 EE          1732 ( 3)         bne     :loop
180E-39             1733 ( 5)         rts
180F-               1734
180F-               1735
180F-               1736      ; -----------------------------------------------------------------------
180F-               1737      ; テーブル検索
180F-               1738      ; Search the keyword table
180F-               1739      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
180F-               1740      ;【使用】A, B, X
180F-               1741      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
180F-               1742      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
180F-               1743      ; -----------------------------------------------------------------------
180F-               1744      search_table:
180F-EC 05          1745 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
1811-91 B1          1746 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1813-26 2F          1747 ( 3)         bne     :false
1815-D1 B2          1748 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
1817-26 2B          1749 ( 3)         bne     :false
1819-EC 07          1750 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
181B-4D             1751 ( 1)         tsta                    ; $00（終端記号）か？
181C-27 1B          1752 ( 3)         beq     :true
181E-91 B3          1753 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
1820-26 22          1754 ( 3)         bne     :false
1822-5D             1755 ( 1)         tstb                    ; $00（終端記号）か？
1823-27 14          1756 ( 3)         beq     :true
1825-D1 B4          1757 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
1827-26 1B          1758 ( 3)         bne     :false
1829-EC 09          1759 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
182B-4D             1760 ( 1)         tsta                    ; $00（終端記号）か？
182C-27 0B          1761 ( 3)         beq     :true
182E-91 B5          1762 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
1830-26 12          1763 ( 3)         bne     :false
1832-5D             1764 ( 1)         tstb                    ; $00（終端記号）か？
1833-27 04          1765 ( 3)         beq     :true
1835-D1 B6          1766 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
1837-26 0B          1767 ( 3)         bne     :false
1839-E6 02          1768 ( 4) .true   ldab    2,x             ; B = 語長
183B-EE 03          1769 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
183D-31             1770 ( 1)         ins                     ; 元のリターンアドレスを削除
183E-31             1771 ( 1)         ins
183F-3C             1772 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1840-DE 8D          1773 ( 4)         ldx     <ExePointer
1842-3A             1774 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1843-39             1775 ( 5)         rts                     ; 命令ルーチンにジャンプ
1844-EE 00          1776 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1846-26 C7          1777 ( 3)         bne     :top
1848-DE 8D          1778 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
184A-0C             1779 ( 1)         clc                     ; false: C=0
184B-39             1780 ( 5)         rts
184C-               1781
184C-               1782
184C-               1783      ; ***********************************************************************
184C-               1784      ;   キーワードテーブル Keyword table
184C-               1785      ; ***********************************************************************
184C-               1786      ; レコードの構造 Record structure
184C-               1787      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
184C-               1788      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
184C-               1789      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
184C-               1790      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
184C-               1791      ; キーワードは2文字以上6文字以下
184C-               1792      CMD_TABLE
184C-18 55          1793      .run            .dw     :new
184E-03             1794                      .db     3
184F-15 EC          1795                      .dw     exe_run
1851-72 75 6E 00    1796                      .az     "run"
1855-18 5E          1797      .new            .dw     :list
1857-03             1798                      .db     3
1858-10 03          1799                      .dw     cold_start
185A-6E 65 77 00    1800                      .az     "new"
185E-18 68          1801      .list           .dw     SMT_TABLE:print
1860-04             1802                      .db     4
1861-16 17          1803                      .dw     exe_list
1863-6C 69 73 74 
     00             1804                      .az     "list"
1868-               1805      SMT_TABLE
1868-18 73          1806      .print          .dw     :input
186A-05             1807                      .db     5
186B-16 32          1808                      .dw     exe_print
186D-70 72 69 6E 
     74 00          1809                      .az     "print"
1873-18 7E          1810      .input          .dw     :if
1875-05             1811                      .db     5
1876-16 7C          1812                      .dw     exe_input
1878-69 6E 70 75 
     74 00          1813                      .az     "input"
187E-18 86          1814      .if             .dw     :goto
1880-02             1815                      .db     2
1881-16 B9          1816                      .dw     exe_if
1883-69 66 00       1817                      .az     "if"
1886-18 90          1818      .goto           .dw     :gosub
1888-04             1819                      .db     4
1889-16 D4          1820                      .dw     exe_goto
188B-67 6F 74 6F 
     00             1821                      .az     "goto"
1890-18 9B          1822      .gosub          .dw     :return
1892-05             1823                      .db     5
1893-16 D1          1824                      .dw     exe_gosub
1895-67 6F 73 75 
     62 00          1825                      .az     "gosub"
189B-18 A6          1826      .return         .dw     :trunc
189D-06             1827                      .db     6
189E-17 30          1828                      .dw     exe_return
18A0-72 65 74 75 
     72 6E          1829                      .as     "return"        ; 6文字なので終端不要。'.as'を使用する
18A6-18 B1          1830      .trunc          .dw     :floor
18A8-05             1831                      .db     5
18A9-17 4C          1832                      .dw     exe_trunc
18AB-74 72 75 6E 
     63 00          1833                      .az     "trunc"
18B1-18 BC          1834      .floor          .dw     :bottom
18B3-05             1835                      .db     5
18B4-17 52          1836                      .dw     exe_floor
18B6-66 6C 6F 6F 
     72 00          1837                      .az     "floor"
18BC-00 00          1838      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18BE-               1839
18BE-               1840      FUNC_TABLE
18BE-18 C8          1841      .rnd            .dw     :bottom
18C0-04             1842                      .db     4
18C1-17 58          1843                      .dw     exe_rnd
18C3-72 6E 64 28 
     00             1844                      .az     "rnd("
18C8-00 00          1845      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18CA-               1846
18CA-               1847
18CA-               1848      ; -----------------------------------------------------------------------
18CA-               1849      ; エラーメッセージを表示する
18CA-               1850      ; Write Error Messege
18CA-               1851      ;【引数】A: エラーコード
18CA-               1852      ;【使用】A, B, X
18CA-               1853      ;【返値】なし
18CA-               1854      ; -----------------------------------------------------------------------
18CA-               1855      write_err_msg:
18CA-7D 00 39       1856 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
18CD-27 03          1857 ( 3)         beq     :1
18CF-BD FF B2       1858 ( 6)         jsr     write_crlf
18D2-CE 18 FD       1859 ( 3) .1      ldx     #ERRMSG1
18D5-BD FF AF       1860 ( 6)         jsr     write_line
18D8-16             1861 ( 1)         tab
18D9-CE 19 09       1862 ( 3)         ldx     #ERRCODE
18DC-3A             1863 ( 1)         abx
18DD-EE 00          1864 ( 5)         ldx     0,x
18DF-BD FF AF       1865 ( 6)         jsr     write_line
18E2-7D 00 9C       1866 ( 4)         tst     ExeStateFlag    ; 実行モードか？
18E5-26 0D          1867 ( 3)         bne     :2              ; No. 行番号を表示せずにスキップ
18E7-CE 19 04       1868 ( 3)         ldx     #ERRMSG2        ; Yes. 行番号を表示する
18EA-BD FF AF       1869 ( 6)         jsr     write_line
18ED-DE 9D          1870 ( 4)         ldx     <ExeLineAddr
18EF-EC 00          1871 ( 5)         ldd     0,x
18F1-BD 15 15       1872 ( 6)         jsr     write_integer
18F4-BD FF B2       1873 ( 6) .2      jsr     write_crlf
18F7-DE 80          1874 ( 4)         ldx     <StackPointer
18F9-35             1875 ( 1)         txs
18FA-7E 10 34       1876 ( 3)         jmp     tb_main
18FD-               1877
18FD-4F 6F 70 73 
     21 20 00       1878      ERRMSG1 .az     "Oops! "
1904-20 69 6E 20 
     00             1879      ERRMSG2 .az     " in "
1909-19 21          1880      ERRCODE .dw     .err00
190B-19 2E          1881              .dw     .err02
190D-19 41          1882              .dw     .err04
190F-19 54          1883              .dw     .err06
1911-19 6D          1884              .dw     .err08
1913-19 79          1885              .dw     .err10
1915-19 8F          1886              .dw     .err12
1917-19 A3          1887              .dw     .err14
1919-19 B4          1888              .dw     .err16
191B-19 CA          1889              .dw     .err18
191D-19 E4          1890              .dw     .err20
191F-19 F9          1891              .dw     .err22
1921-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1892      .err00  .az     "Syntax error"
192E-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1893      .err02  .az     "Out of range value"
1941-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1894      .err04  .az     "Illegal expression"
1954-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1895      .err06  .az     "Calculate stack overflow"
196D-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1896      .err08  .az     "Zero Divide"
1979-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1897      .err10  .az     "Print statement error"
198F-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1898      .err12  .az     "Invalid line number"
19A3-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1899      .err14  .az     "Memory size over"
19B4-55 6E 64 65 
     66 69 6E 65 
     64 20 6C 69 
     6E 65 20 6E 
     75 6D 62 65 
     72 00          1900      .err16  .az     "Undefined line number"
19CA-53 75 62 72 
     6F 75 74 69 
     6E 65 20 73 
     74 61 63 6B 
     20 6F 76 65 
     72 66 6C 6F 
     77 00          1901      .err18  .az     "Subroutine stack overflow"
19E4-52 65 74 75 
     72 6E 20 77 
     69 74 68 6F 
     75 74 20 67 
     6F 73 75 62 
     00             1902      .err20  .az     "Return without gosub"
19F9-53 75 62 73 
     63 72 69 70 
     74 20 69 73 
     20 6F 75 74 
     20 6F 66 20 
     72 61 6E 67 
     65 00          1903      .err22  .az     "Subscript is out of range"
1A13-               1904
1A13-               1905
1A13-               1906      ; ***********************************************************************
1A13-               1907      ;   デバック用ルーチン Debugging routines
1A13-               1908      ; ***********************************************************************
1A13-               1909      ; -----------------------------------------------------------------------
1A13-               1910      ; ユーザーレジスタを表示する
1A13-               1911      ; Display user registers
1A13-               1912      ; -----------------------------------------------------------------------
1A13-36             1913 ( 4) PUTUR:  psha
1A14-37             1914 ( 4)         pshb
1A15-3C             1915 ( 5)         pshx
1A16-CE 1A 49       1916 ( 3)         ldx     #:MSGUR0
1A19-BD FF AF       1917 ( 6)         jsr     write_line
1A1C-DC A9          1918 ( 4)         ldd     <UR0
1A1E-BD FF BB       1919 ( 6)         jsr     write_word
1A21-CE 1A 4E       1920 ( 3)         ldx     #:MSGUR1
1A24-BD FF AF       1921 ( 6)         jsr     write_line
1A27-DC AB          1922 ( 4)         ldd     <UR1
1A29-BD FF BB       1923 ( 6)         jsr     write_word
1A2C-CE 1A 54       1924 ( 3)         ldx     #:MSGUR2
1A2F-BD FF AF       1925 ( 6)         jsr     write_line
1A32-DC AD          1926 ( 4)         ldd     <UR2
1A34-BD FF BB       1927 ( 6)         jsr     write_word
1A37-CE 1A 5A       1928 ( 3)         ldx     #:MSGUR3
1A3A-BD FF AF       1929 ( 6)         jsr     write_line
1A3D-DC AF          1930 ( 4)         ldd     <UR3
1A3F-BD FF BB       1931 ( 6)         jsr     write_word
1A42-BD FF B2       1932 ( 6)         jsr     write_crlf
1A45-38             1933 ( 4)         pulx
1A46-33             1934 ( 3)         pulb
1A47-32             1935 ( 3)         pula
1A48-39             1936 ( 5)         rts
1A49-55 52 30 3D 
     00             1937      .MSGUR0          .az     "UR0="
1A4E-20 55 52 31 
     3D 00          1938      .MSGUR1          .az     " UR1="
1A54-20 55 52 32 
     3D 00          1939      .MSGUR2          .az     " UR2="
1A5A-20 55 52 33 
     3D 00          1940      .MSGUR3          .az     " UR3="
