0000-                 14
0000-                 15      ; ********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0000-                 46
0020-                 47      RAM_START       .eq     $0020
1FFF-                 48      RAM_END         .eq     $1fff
E000-                 49      ROM_START       .eq     $e000
FFFF-                 50      ROM_END         .eq     $ffff
0FFF-                 51      STACK           .eq     $0fff
0000-                 52
1000-                 53      PROGRAM_START   .eq     $1000
0100-                 54      Rx_BUFFER       .eq     $0100   ; SCI Rx Buffer ($0100-0148,73byte)
0148-                 55      Rx_BUFFER_END   .eq     $0148   ; 73byte（72character）
0149-                 56      CSTACK          .eq     $0149   ; 計算スタック (Calculate stack, 40byte)
01C2-                 57      VARIABLE        .eq     $01c2   ; 変数26文字 ($01c2-01f5, 52byte)
0000-                 58
0000-                 59      ; ***********************************************************************
0000-                 60      ;   システム変数 System variables
0000-                 61      ; ***********************************************************************
0000-                 62              .sm     RAM
0020-                 63              .or     $20
0020-                 64
0020-                 65      ; Interrupt Vector Hooking
0020-                 66      VEC_TRAP        .bs     3
0023-                 67      VEC_SCI         .bs     3
0026-                 68      VEC_TOF         .bs     3
0029-                 69      VEC_OCF         .bs     3
002C-                 70      VEC_ICF         .bs     3
002F-                 71      VEC_IRQ         .bs     3
0032-                 72      VEC_SWI         .bs     3
0035-                 73      VEC_NMI         .bs     3
0038-                 74      BreakPointFlag  .bs     1
0039-                 75      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 76      ; General-Purpose Registers
003A-                 77      R0              .bs     2
003C-                 78      R1              .bs     2
003E-                 79
003E-                 80      ; ***********************************************************************
003E-                 81      ;   変数 Variables
003E-                 82      ; ***********************************************************************
003E-                 83              .sm     RAM
0080-                 84              .or     $80
0080-                 85
0080-                 86      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                 87      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                 88      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                 89      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                 90      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                 91      Divisor         .bs     2       ; 除数
0089-                 92      Remainder       .bs     2       ; 剰余
008B-                 93      VariableAddr    .bs     2       ; 変数のアドレス
008D-                 94      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                 95      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                 96
0090-                 97      ; General-Purpose Registers
0090-                 98      UR0             *
0090-                 99      UR0H            .bs     1
0091-                100      UR0L            .bs     1
0092-                101      UR1             *
0092-                102      UR1H            .bs     1
0093-                103      UR1L            .bs     1
0094-                104      UR2             *
0094-                105      UR2H            .bs     1
0095-                106      UR2L            .bs     1
0096-                107      UR3             *
0096-                108      UR3H            .bs     1
0097-                109      UR3L            .bs     1
0098-                110      ; Work area
0098-                111      COMPARE         .bs     6       ; 文字列比較用バッファ
009E-                112
009E-                113      ; ***********************************************************************
009E-                114      ;   Program Start
009E-                115      ; ***********************************************************************
0000-                116              .sm     CODE
1000-                117              .or     PROGRAM_START
1000-                118
1000-                119      init_tinybasic:
1000-30              120 ( 1)         tsx
1001-DF 80           121 ( 4)         stx     <StackPointer
1003-                122
1003-                123      tb_main:
1003-C6 3E           124 ( 2)         ldab    #'>'
1005-BD FF AC        125 ( 6)         jsr     write_char
1008-BD FF A9        126 ( 6)         jsr     read_line
100B-CE 01 00        127 ( 3)         ldx     #Rx_BUFFER      ; 実行位置アドレスをセット
100E-7E 10 24        128 ( 3)         jmp     exe_line
1011-                129
1011-                130
1011-                131      ; -----------------------------------------------------------------------
1011-                132      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1011-                133      ; Is a multi statement mark?
1011-                134      ;【引数】X:実行位置アドレス
1011-                135      ;【使用】B, X
1011-                136      ;【返値】なし
1011-                137      ; -----------------------------------------------------------------------
1011-                138      is_multi:
1011-BD 13 23        139 ( 6)         jsr     skip_space
1014-27 07           140 ( 3)         beq     :end
1016-C1 3A           141 ( 2)         cmpb    #':'
1018-26 06           142 ( 3)         bne     :err00
101A-08              143 ( 1)         inx
101B-20 07           144 ( 3)         bra     exe_line
101D-7E 10 03        145 ( 3) .end    jmp     tb_main
1020-4F              146 ( 1) .err00  clra                    ; "Syntax error"
1021-7E 14 70        147 ( 3)         jmp     write_err_msg
1024-                148
1024-                149
1024-                150      ; -----------------------------------------------------------------------
1024-                151      ; 一行実行
1024-                152      ; Execute one line
1024-                153      ;【引数】X:実行位置アドレス
1024-                154      ;【使用】A, B, X
1024-                155      ;【返値】なし
1024-                156      ; -----------------------------------------------------------------------
1024-                157      exe_line:
1024-BD 13 23        158 ( 6)         jsr     skip_space
1027-27 2D           159 ( 3)         beq     :end            ; 終端文字（$00）ならば終了
1029-                160            ; // 代入文のチェック
1029-BD 13 0E        161 ( 6)         jsr     is_variable     ; 変数か？
102C-24 12           162 ( 3)         bcc     :cmd            ; No. テーブル検索へ
102E-86 01           163 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1030-58              164 ( 1)         aslb                    ; B = 変数領域の下位バイト
1031-DD 8B           165 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1033-BD 13 23        166 ( 6)         jsr     skip_space      ; Yes. 代入文か？
1036-C1 3D           167 ( 2)         cmpb    #'='
1038-26 1F           168 ( 3)         bne     :err00          ; No. エラー処理へ
103A-08              169 ( 1)         inx                     ; Yes. 代入実行
103B-BD 13 60        170 ( 6)         jsr     assign_to_var
103E-20 D1           171 ( 3)         bra     is_multi
1040-EC 00           172 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
1042-DD 98           173 ( 4)         std     <COMPARE
1044-EC 02           174 ( 5)         ldd     2,x
1046-DD 9A           175 ( 4)         std     <COMPARE+2
1048-EC 04           176 ( 5)         ldd     4,x
104A-DD 9C           177 ( 4)         std     <COMPARE+4
104C-DF 8D           178 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
104E-CE 14 50        179 ( 3)         ldx     #SMT_TABLE      ; 文字列テーブルアドレスをセット
1051-BD 14 13        180 ( 6)         jsr     search_table    ; テーブル検索実行
1054-24 03           181 ( 3)         bcc     :err00
1056-7E 10 03        182 ( 3) .end    jmp     tb_main
1059-                183
1059-4F              184 ( 1) .err00  clra                    ; syntax error.
105A-7E 14 70        185 ( 3)         jmp     write_err_msg
105D-                186
105D-                187
105D-                188      ; -----------------------------------------------------------------------
105D-                189      ; 式を評価する
105D-                190      ; Evaluate the expression
105D-                191      ;【引数】B:アスキーコード X:実行位置アドレス
105D-                192      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
105D-                193      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
105D-                194      ;        偽(C=0) / X:現在の実行位置アドレス
105D-                195      ; -----------------------------------------------------------------------
105D-                196      eval_expression:
0094-                197      .SP     .eq     UR2
0096-                198      .X      .eq     UR3
105D-                199            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
105D-DF 96           200 ( 4)         stx     <:X
105F-30              201 ( 1)         tsx
1060-DF 94           202 ( 4)         stx     <:SP
1062-DE 96           203 ( 4)         ldx     <:X
1064-                204            ; // 計算スタックの初期化
1064-CC 01 72        205 ( 3)         ldd     #CSTACK+40+1    ; 40byte分
1067-DD 82           206 ( 4)         std     <CStackPtr
1069-                207            ; // 式評価開始
1069-8D 08           208 ( 5)         bsr     expr_4th
106B-                209            ; // 計算結果をスタックトップから取り出す
106B-3C              210 ( 5)         pshx
106C-DE 82           211 ( 4)         ldx     <CStackPtr
106E-EC 00           212 ( 5)         ldd     0,x
1070-38              213 ( 4)         pulx
1071-0D              214 ( 1)         sec                     ; true:C=1
1072-39              215 ( 5)         rts
1073-                216
1073-                217      expr_4th:
1073-8D 50           218 ( 5)         bsr     expr_3rd
1075-BD 13 23        219 ( 6) .loop   jsr     skip_space
1078-C1 3D           220 ( 2)         cmpb    #'='            ; '='?
107A-26 08           221 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
107C-08              222 ( 1)         inx
107D-8D 46           223 ( 5)         bsr     expr_3rd
107F-BD 12 0D        224 ( 6)         jsr     CS_eq           ; EQual to
1082-20 F1           225 ( 3)         bra     :loop
1084-C1 3C           226 ( 2) .ltsign cmpb    #'<'            ; '<'?
1086-26 22           227 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1088-08              228 ( 1)         inx
1089-E6 00           229 ( 4)         ldab    0,x
108B-C1 3E           230 ( 2)         cmpb    #'>'            ; '<>'?
108D-26 08           231 ( 3)         bne     :lte
108F-08              232 ( 1)         inx
1090-8D 33           233 ( 5)         bsr     expr_3rd
1092-BD 12 2E        234 ( 6)         jsr     CS_ne           ; Not Equal to
1095-20 DE           235 ( 3)         bra     :loop
1097-C1 3D           236 ( 2) .lte    cmpb    #'='            ; '<='?
1099-26 08           237 ( 3)         bne     :lt
109B-08              238 ( 1)         inx
109C-8D 27           239 ( 5)         bsr     expr_3rd
109E-BD 12 23        240 ( 6)         jsr     CS_lte          ; Less Than or Equal to
10A1-20 D2           241 ( 3)         bra     :loop
10A3-8D 20           242 ( 5) .lt     bsr     expr_3rd
10A5-BD 12 18        243 ( 6)         jsr     CS_lt           ; Less Than
10A8-20 CB           244 ( 3)         bra     :loop
10AA-C1 3E           245 ( 2) .gtsign cmpb    #'>'            ; '>'?
10AC-26 16           246 ( 3)         bne     :end
10AE-08              247 ( 1)         inx
10AF-E6 00           248 ( 4)         ldab    0,x
10B1-C1 3D           249 ( 2)         cmpb    #'='            ; '>='?
10B3-26 08           250 ( 3)         bne     :gt
10B5-08              251 ( 1)         inx
10B6-8D 0D           252 ( 5)         bsr     expr_3rd
10B8-BD 12 44        253 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
10BB-20 B8           254 ( 3)         bra     :loop
10BD-8D 06           255 ( 5) .gt     bsr     expr_3rd
10BF-BD 12 39        256 ( 6)         jsr     CS_gt           ; Greater Than
10C2-20 B1           257 ( 3)         bra     :loop
10C4-39              258 ( 5) .end    rts
10C5-                259
10C5-                260      expr_3rd:
10C5-8D 1C           261 ( 5)         bsr     expr_2nd
10C7-BD 13 23        262 ( 6) .loop   jsr     skip_space
10CA-C1 2B           263 ( 2)         cmpb    #'+'
10CC-26 08           264 ( 3)         bne     :minus
10CE-08              265 ( 1)         inx
10CF-8D 12           266 ( 5)         bsr     expr_2nd
10D1-BD 11 58        267 ( 6)         jsr     CS_add
10D4-20 F1           268 ( 3)         bra     :loop
10D6-C1 2D           269 ( 2) .minus  cmpb    #'-'
10D8-26 08           270 ( 3)         bne     :end
10DA-08              271 ( 1)         inx
10DB-8D 06           272 ( 5)         bsr     expr_2nd
10DD-BD 11 61        273 ( 6)         jsr     CS_sub
10E0-20 E5           274 ( 3)         bra     :loop
10E2-39              275 ( 5) .end    rts
10E3-                276
10E3-                277      expr_2nd:
10E3-8D 28           278 ( 5)         bsr     expr_1st
10E5-BD 13 23        279 ( 6) .loop   jsr     skip_space
10E8-C1 2A           280 ( 2)         cmpb    #'*'
10EA-26 08           281 ( 3)         bne     :div
10EC-08              282 ( 1)         inx
10ED-8D 1E           283 ( 5)         bsr     expr_1st
10EF-BD 11 6A        284 ( 6)         jsr     CS_mul
10F2-20 F1           285 ( 3)         bra     :loop
10F4-C1 2F           286 ( 2) .div    cmpb    #'/'
10F6-26 08           287 ( 3)         bne     :mod
10F8-08              288 ( 1)         inx
10F9-8D 12           289 ( 5)         bsr     expr_1st
10FB-BD 11 87        290 ( 6)         jsr     CS_div
10FE-20 E5           291 ( 3)         bra     :loop
1100-C1 25           292 ( 2) .mod    cmpb    #'%'
1102-26 08           293 ( 3)         bne     :end
1104-08              294 ( 1)         inx
1105-8D 06           295 ( 5)         bsr     expr_1st
1107-BD 11 A3        296 ( 6)         jsr     CS_mod
110A-20 D9           297 ( 3)         bra     :loop
110C-39              298 ( 5) .end    rts
110D-                299
110D-                300      expr_1st:
0094-                301      .SP     .eq     UR2
0096-                302      .X      .eq     UR3
110D-BD 13 23        303 ( 6)         jsr     skip_space
1110-BD 12 5A        304 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
1113-24 02           305 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
1115-20 1D           306 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1117-BD 13 0E        307 ( 6) .var    jsr     is_variable     ; 変数か？
111A-24 0A           308 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
111C-                309            ; // 変数値の取得
111C-3C              310 ( 5)         pshx                    ; 実行位置アドレスを退避
111D-86 01           311 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
111F-58              312 ( 1)         aslb                    ; B = 変数領域の下位バイト
1120-18              313 ( 2)         xgdx                    ; X = 変数のアドレス
1121-EC 00           314 ( 5)         ldd     0,x             ; D <- 変数の値
1123-38              315 ( 4)         pulx                    ; 実行位置アドレスを復帰
1124-20 0E           316 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
1126-C1 28           317 ( 2) .paren  cmpb    #'('
1128-26 1A           318 ( 3)         bne     :err
112A-08              319 ( 1)         inx
112B-BD 10 73        320 ( 6)         jsr     expr_4th
112E-C1 29           321 ( 2)         cmpb    #')'
1130-26 12           322 ( 3)         bne     :err
1132-08              323 ( 1)         inx
1133-39              324 ( 5)         rts
1134-3C              325 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1135-DE 82           326 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1137-09              327 ( 1)         dex
1138-09              328 ( 1)         dex
1139-8C 01 47        329 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
113C-25 0D           330 ( 3)         bcs     :err06
113E-ED 00           331 ( 5)         std     0,x
1140-DF 82           332 ( 4)         stx     <CStackPtr
1142-38              333 ( 4)         pulx                    ; 実行位置アドレスを復帰
1143-39              334 ( 5)         rts
1144-                335            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
1144-DE 94           336 ( 4) .err    ldx     <:SP
1146-35              337 ( 1)         txs
1147-DE 96           338 ( 4)         ldx     <:X
1149-0C              339 ( 1)         clc                     ; false:C=0
114A-39              340 ( 5)         rts
114B-86 06           341 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
114D-7E 14 70        342 ( 3)         jmp     write_err_msg
1150-                343
1150-                344      ;
1150-                345      ; Arithmetic operator
1150-                346      ;
1150-                347      CS_store:
1150-08              348 ( 1)         inx
1151-08              349 ( 1)         inx
1152-ED 00           350 ( 5)         std     0,x
1154-DF 82           351 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
1156-38              352 ( 4)         pulx                    ; 実行位置アドレスを復帰
1157-39              353 ( 5)         rts
1158-                354
1158-3C              355 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
1159-DE 82           356 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
115B-EC 02           357 ( 5)         ldd     2,x
115D-E3 00           358 ( 5)         addd    0,x
115F-20 EF           359 ( 3)         bra     CS_store
1161-                360
1161-3C              361 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
1162-DE 82           362 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1164-EC 02           363 ( 5)         ldd     2,x
1166-A3 00           364 ( 5)         subd    0,x
1168-20 E6           365 ( 3)         bra     CS_store
116A-                366
116A-                367      CS_mul:
0090-                368      .Result         .eq     UR0
116A-3C              369 ( 5)         pshx                    ; 実行位置アドレスを退避
116B-DE 82           370 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
116D-                371              ; B * D
116D-A6 03           372 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
116F-E6 01           373 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
1171-3D              374 ( 7)         mul                     ; B * D
1172-DD 90           375 ( 4)         std     <:Result        ;「B*D」を保存
1174-                376              ; A * D
1174-EC 01           377 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
1176-3D              378 ( 7)         mul                     ; A * D
1177-DB 90           379 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
1179-D7 90           380 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
117B-                381              ; C * B
117B-A6 00           382 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
117D-E6 03           383 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
117F-3D              384 ( 7)         mul                     ; C * B
1180-DB 90           385 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1182-17              386 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1183-D6 91           387 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
1185-20 C9           388 ( 3)         bra     CS_store
1187-                389
1187-                390      ;
1187-                391      ; 符号付き割り算の考え方
1187-                392      ; ・剰余は除数の符号と同一
1187-                393      ;   ・ 7 / 3  = 商  2、剰余  1
1187-                394      ;   ・-7 / 3  = 商 -3、剰余  2
1187-                395      ;   ・ 7 / -3 = 商 -3、剰余 -2
1187-                396      ;   ・-7 / -3 = 商  2、剰余 -1
1187-                397      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
1187-                398      ;       2.ただし、除数がゼロの場合は1は足さない
1187-                399      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
1187-                400      ;         除数の絶対値から剰余の絶対値を引く
1187-                401      ;       2.その結果を除数と同じ符号にする
1187-                402      ;       3.ただし、除数がゼロの場合は剰余もゼロ
1187-                403      ;
1187-3C              404 ( 5) CS_div: pshx                    ; 実行位置アドレスを退避
1188-DE 82           405 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
118A-8D 37           406 ( 5)         bsr     div_uint        ; 除算実行
118C-18              407 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
118D-7D 00 85        408 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1190-27 0D           409 ( 3)         beq     :end            ; '+'なら終了
1192-8C 00 00        410 ( 3)         cpx     #0              ; 剰余はゼロか？
1195-27 03           411 ( 3)         beq     :sign
1197-C3 00 01        412 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
119A-43              413 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
119B-53              414 ( 1)         comb
119C-C3 00 01        415 ( 3)         addd    #1
119F-DE 82           416 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
11A1-20 AD           417 ( 3)         bra     CS_store
11A3-                418
11A3-3C              419 ( 5) CS_mod: pshx                    ; 実行位置アドレスを退避
11A4-DE 82           420 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11A6-8D 1B           421 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
11A8-DD 89           422 ( 4)         std     <Remainder      ; 剰余はゼロか？
11AA-27 13           423 ( 3)         beq     :end            ; ゼロであれば終了
11AC-7D 00 85        424 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
11AF-27 04           425 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
11B1-DC 87           426 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
11B3-93 89           427 ( 4)         subd    <Remainder
11B5-7D 00 86        428 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
11B8-27 05           429 ( 3)         beq     :end            ; '+'なら終了
11BA-43              430 ( 1)         coma                    ; '-'なら2の補数にする
11BB-53              431 ( 1)         comb
11BC-C3 00 01        432 ( 3)         addd    #1
11BF-DE 82           433 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
11C1-20 8D           434 ( 3)         bra     CS_store
11C3-                435
11C3-                436      div_uint:
0090-                437      .Counter        .eq     UR0H
11C3-EC 00           438 ( 5)         ldd     0,x             ; ゼロ除算チェック
11C5-27 41           439 ( 3)         beq     :err08          ; 除数がゼロならエラー
11C7-5F              440 ( 1)         clrb
11C8-D7 85           441 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
11CA-D7 86           442 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
11CC-C6 10           443 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
11CE-D7 90           444 ( 3)         stab    <:Counter
11D0-                445              ; // 剰余の符号フラグの設定
11D0-EC 00           446 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
11D2-2A 03           447 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
11D4-7C 00 86        448 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
11D7-                449              ; // 商の符号フラグの設定
11D7-A8 02           450 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
11D9-2A 03           451 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
11DB-7C 00 85        452 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
11DE-                453              ; // 除数を絶対値にする
11DE-EC 00           454 ( 5) .2      ldd     0,x             ; D <- 除数
11E0-2A 05           455 ( 3)         bpl     :3
11E2-43              456 ( 1)         coma                    ; 除数が負なら絶対値にする
11E3-53              457 ( 1)         comb
11E4-C3 00 01        458 ( 3)         addd    #1
11E7-DD 87           459 ( 4) .3      std     <Divisor        ; 除数を保存
11E9-                460              ; // 非除数を絶対値にする
11E9-EC 02           461 ( 5)         ldd     2,x             ; D <- 被除数
11EB-2A 05           462 ( 3)         bpl     :4
11ED-43              463 ( 1)         coma                    ; 被除数が負なら絶対値にする
11EE-53              464 ( 1)         comb
11EF-C3 00 01        465 ( 3)         addd    #1
11F2-                466              ; // 除算実行
11F2-18              467 ( 2) .4      xgdx                    ; X <- 被除数
11F3-4F              468 ( 1)         clra                    ; D（WORK）をクリア
11F4-5F              469 ( 1)         clrb
11F5-18              470 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
11F6-05              471 ( 1)         asld
11F7-18              472 ( 2)         xgdx
11F8-59              473 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
11F9-49              474 ( 1)         rola
11FA-93 87           475 ( 4)         subd    <Divisor        ; WORK - 除数
11FC-08              476 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
11FD-24 03           477 ( 3)         bcc     :5              ; WORKから除数を引けた？
11FF-D3 87           478 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1201-09              479 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1202-7A 00 90        480 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1205-26 EE           481 ( 3)         bne     :loop
1207-39              482 ( 5)         rts
1208-86 08           483 ( 2) .err08  ldaa    #8              ; "Zero Divide"
120A-7E 14 70        484 ( 3)         jmp     write_err_msg
120D-                485
120D-3C              486 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
120E-DE 82           487 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1210-EC 02           488 ( 5)         ldd     2,x
1212-A3 00           489 ( 5)         subd    0,x
1214-27 39           490 ( 3)         beq     CS_true
1216-20 3D           491 ( 3)         bra     CS_false
1218-                492
1218-3C              493 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1219-DE 82           494 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
121B-EC 02           495 ( 5)         ldd     2,x
121D-A3 00           496 ( 5)         subd    0,x
121F-2D 2E           497 ( 3)         blt     CS_true
1221-20 32           498 ( 3)         bra     CS_false
1223-                499
1223-3C              500 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1224-DE 82           501 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1226-EC 02           502 ( 5)         ldd     2,x
1228-A3 00           503 ( 5)         subd    0,x
122A-2F 23           504 ( 3)         ble     CS_true
122C-20 27           505 ( 3)         bra     CS_false
122E-                506
122E-3C              507 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
122F-DE 82           508 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1231-EC 02           509 ( 5)         ldd     2,x
1233-A3 00           510 ( 5)         subd    0,x
1235-26 18           511 ( 3)         bne     CS_true
1237-20 1C           512 ( 3)         bra     CS_false
1239-                513
1239-3C              514 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
123A-DE 82           515 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
123C-EC 02           516 ( 5)         ldd     2,x
123E-A3 00           517 ( 5)         subd    0,x
1240-2E 0D           518 ( 3)         bgt     CS_true
1242-20 11           519 ( 3)         bra     CS_false
1244-                520
1244-3C              521 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
1245-DE 82           522 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1247-EC 02           523 ( 5)         ldd     2,x
1249-A3 00           524 ( 5)         subd    0,x
124B-2C 02           525 ( 3)         bge     CS_true
124D-20 06           526 ( 3)         bra     CS_false
124F-                527
124F-                528      CS_true:
124F-CC 00 01        529 ( 3)         ldd     #1
1252-7E 11 50        530 ( 3)         jmp     CS_store
1255-                531
1255-                532      CS_false:
1255-4F              533 ( 1)         clra
1256-5F              534 ( 1)         clrb
1257-7E 11 50        535 ( 3)         jmp     CS_store
125A-                536
125A-                537      ; -----------------------------------------------------------------------
125A-                538      ; テキストバッファの10進文字列から数値を取得する
125A-                539      ; Get a integer from a decimal string in a text buffer
125A-                540      ;【引数】X:バッファアドレス
125A-                541      ;【使用】A, B, X, UR0, UR1
125A-                542      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
125A-                543      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
125A-                544      ; -----------------------------------------------------------------------
125A-                545      get_int_from_decimal:
0090-                546      .RetValue       .eq     UR0     ; Return Value
0092-                547      .TempValue      .eq     UR1     ; Temporary Value
125A-4F              548 ( 1)         clra
125B-5F              549 ( 1)         clrb
125C-DD 90           550 ( 4)         std     <:RetValue
125E-97 92           551 ( 3)         staa    <:TempValue
1260-97 84           552 ( 3)         staa    <SignFlag
1262-E6 00           553 ( 4)         ldab    0,x             ; 1文字取得
1264-C1 2D           554 ( 2)         cmpb    #'-'            ; マイナス記号か？
1266-26 05           555 ( 3)         bne     :1
1268-7C 00 84        556 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
126B-20 0B           557 ( 3)         bra     :next
126D-C1 2B           558 ( 2) .1      cmpb    #'+'            ; プラス記号か？
126F-27 07           559 ( 3)         beq     :next
1271-BD FF C1        560 ( 6)         jsr     is_decimal_char ; 数字か？
1274-24 36           561 ( 3)         bcc     :false          ; No. C=1で終了
1276-20 13           562 ( 3)         bra     :first
1278-08              563 ( 1) .next   inx                     ; 符号の次の1文字を取得
1279-E6 00           564 ( 4)         ldab    0,x
127B-BD FF C1        565 ( 6)         jsr     is_decimal_char ; 数字か？
127E-24 40           566 ( 3)         bcc     :err04          ; No. エラー処理へ
1280-20 09           567 ( 3)         bra     :first          ; Yes. これが最初の数字
1282-DD 90           568 ( 4) .loop   std     <:RetValue      ; 結果を退避
1284-E6 00           569 ( 4)         ldab    0,x             ; 1文字取得
1286-BD FF C1        570 ( 6)         jsr     is_decimal_char ; 数字か？
1289-24 14           571 ( 3)         bcc     :end
128B-C0 30           572 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
128D-D7 93           573 ( 3)         stab    <:TempValue+1
128F-                574            ; // RetValue * 10 + TempValue
128F-DC 90           575 ( 4)         ldd     <:RetValue
1291-05              576 ( 1)         asld                    ; * 2
1292-05              577 ( 1)         asld                    ; * 4
1293-D3 90           578 ( 4)         addd    <:RetValue      ; * 5
1295-05              579 ( 1)         asld                    ; * 10
1296-D3 92           580 ( 4)         addd    <:TempValue     ; += TempValue
1298-08              581 ( 1)         inx                     ; ポインタを進める
1299-25 20           582 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
129B-2B 10           583 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
129D-20 E3           584 ( 3)         bra     :loop
129F-DC 90           585 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
12A1-7D 00 84        586 ( 4)         tst     <SignFlag       ; 符号チェック
12A4-27 05           587 ( 3)         beq     :true
12A6-43              588 ( 1)         coma                    ; 負なら2の補数に
12A7-53              589 ( 1)         comb
12A8-C3 00 01        590 ( 3)         addd    #1
12AB-0D              591 ( 1) .true   sec
12AC-39              592 ( 5) .false  rts
12AD-                593
12AD-                594      .overflow
12AD-                595            ; // -32,768かどうかの判定
12AD-18              596 ( 2)         xgdx
12AE-8C 80 00        597 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
12B1-18              598 ( 2)         xgdx
12B2-26 07           599 ( 3)         bne     :err02          ; No. 範囲外
12B4-7D 00 84        600 ( 4)         tst     <SignFlag       ; 符号チェック
12B7-27 02           601 ( 3)         beq     :err02          ; 正ならば範囲外
12B9-20 C7           602 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
12BB-                603
12BB-86 02           604 ( 2) .err02  ldaa    #2              ; "Out of range"
12BD-7E 14 70        605 ( 3)         jmp     write_err_msg
12C0-86 04           606 ( 2) .err04  ldaa    #4              ; "Illegal expression"
12C2-7E 14 70        607 ( 3)         jmp     write_err_msg
12C5-                608
12C5-                609
12C5-                610      ; -----------------------------------------------------------------------
12C5-                611      ; Dレジスタの数値をコンソールに出力する
12C5-                612      ; Write Decimal Character converted from Integer
12C5-                613      ;【引数】D:Integer
12C5-                614      ;【使用】A, B, X
12C5-                615      ;【返値】なし
12C5-                616      ; -----------------------------------------------------------------------
12C5-                617      write_integer:
0090-                618      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
0091-                619      .Counter        .eq     UR0L    ; 桁カウンター
12C5-2A 0C           620 ( 3)         bpl     :plus           ; 符号判定
12C7-37              621 ( 4)         pshb                    ; 負数なら'-'を出力する
12C8-C6 2D           622 ( 2)         ldab    #'-'
12CA-BD FF AC        623 ( 6)         jsr     write_char
12CD-33              624 ( 3)         pulb
12CE-43              625 ( 1)         coma                    ; 絶対値にする（2の補数にする）
12CF-53              626 ( 1)         comb
12D0-C3 00 01        627 ( 3)         addd    #1
12D3-7F 00 90        628 ( 5) .plus   clr     <:ZeroSuppress
12D6-CE 13 06        629 ( 3)         ldx     #:CONST
12D9-7F 00 91        630 ( 5) .loop   clr     <:Counter
12DC-A3 00           631 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
12DE-25 05           632 ( 3)         bcs     :write
12E0-7C 00 91        633 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
12E3-20 F7           634 ( 3)         bra     :digit
12E5-                635
12E5-E3 00           636 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
12E7-37              637 ( 4)         pshb
12E8-D6 91           638 ( 3)         ldab    <:Counter
12EA-27 03           639 ( 3)         beq     :1              ; この桁はゼロか？
12EC-7C 00 90        640 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
12EF-7D 00 90        641 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
12F2-27 05           642 ( 3)         beq     :2              ; No. この桁は表示しない
12F4-CB 30           643 ( 2)         addb    #$30            ; Yes. この桁を表示する
12F6-BD FF AC        644 ( 6)         jsr     write_char
12F9-33              645 ( 3) .2      pulb
12FA-08              646 ( 1)         inx                     ; 次の引く数へ
12FB-08              647 ( 1)         inx
12FC-8C 13 0E        648 ( 3)         cpx     #:CONST+8
12FF-26 D8           649 ( 3)         bne     :loop
1301-CB 30           650 ( 2)         addb    #$30            ; 一の桁の数値を表示
1303-7E FF AC        651 ( 3)         jmp     write_char
1306-                652      ; Dから引いていく数
1306-27 10           653      .CONST  .dw     $2710           ; 10,000
1308-03 E8           654              .dw     $03e8           ; 1,000
130A-00 64           655              .dw     $0064           ; 100
130C-00 0A           656              .dw     $000a           ; 10
130E-                657
130E-                658
130E-                659      ; -----------------------------------------------------------------------
130E-                660      ; テキストバッファの英文字が変数か判定する
130E-                661      ; Is a character retrieved from a text buffer a variable?
130E-                662      ;【引数】X:バッファアドレス
130E-                663      ;【使用】A, B, X
130E-                664      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
130E-                665      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
130E-                666      ; -----------------------------------------------------------------------
130E-                667      is_variable:
130E-E6 00           668 ( 4)         ldab    0,x
1310-BD FF BE        669 ( 6)         jsr     is_alphabetic_char
1313-24 0D           670 ( 3)         bcc     :end
1315-17              671 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1316-E6 01           672 ( 4)         ldab    1,x                     ; 2文字目を取得
1318-BD FF BE        673 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
131B-16              674 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
131C-24 02           675 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
131E-0C              676 ( 1)         clc                             ; Yes. 変数ではない。C=0
131F-39              677 ( 5)         rts
1320-08              678 ( 1) .var    inx                             ; ポインタを進める
1321-0D              679 ( 1)         sec                             ; C=1
1322-39              680 ( 5) .end    rts
1323-                681
1323-                682
1323-                683      ; -----------------------------------------------------------------------
1323-                684      ; 空白を読み飛ばす
1323-                685      ; Skip Space
1323-                686      ;【引数】X:実行位置アドレス
1323-                687      ;【使用】B, X
1323-                688      ;【返値】B:アスキーコード（$00の時Z=1）
1323-                689      ;        X:実行位置アドレス
1323-                690      ; -----------------------------------------------------------------------
1323-                691      skip_space:
1323-E6 00           692 ( 4)         ldab    0,x
1325-27 07           693 ( 3)         beq     :end
1327-C1 20           694 ( 2)         cmpb    #SPACE
1329-22 03           695 ( 3)         bhi     :end
132B-08              696 ( 1)         inx
132C-20 F5           697 ( 3)         bra     skip_space
132E-39              698 ( 5) .end    rts
132F-                699
132F-                700
132F-                701      ; -----------------------------------------------------------------------
132F-                702      ; 引用符付きの文字列を出力する
132F-                703      ; Write Quoted Stirng
132F-                704      ;【引数】B:アスキーコード X:実行位置アドレス
132F-                705      ;【使用】A, B, X
132F-                706      ;【返値】真(C=1) / X:次の実行位置アドレス
132F-                707      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
132F-                708      ; -----------------------------------------------------------------------
132F-                709      write_quoted_str:
132F-C1 22           710 ( 2)         cmpb    #$22            ; 一重引用符か？
1331-27 04           711 ( 3)         beq     :1
1333-C1 27           712 ( 2)         cmpb    #$27            ; 二重引用符か？
1335-26 19           713 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
1337-17              714 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
1338-                715            ; // 終端の引用符をチェック
1338-3C              716 ( 5)         pshx
1339-08              717 ( 1) .check  inx
133A-E6 00           718 ( 4)         ldab    0,x
133C-27 14           719 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
133E-11              720 ( 1)         cba
133F-26 F8           721 ( 3)         bne     :check
1341-38              722 ( 4)         pulx
1342-                723            ; // 文字列の出力
1342-08              724 ( 1) .loop   inx
1343-E6 00           725 ( 4)         ldab    0,x
1345-11              726 ( 1)         cba                     ; 保存した引用符との比較
1346-27 05           727 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
1348-BD FF AC        728 ( 6)         jsr     write_char
134B-20 F5           729 ( 3)         bra     :loop
134D-08              730 ( 1) .true   inx
134E-0D              731 ( 1)         sec
134F-39              732 ( 5)         rts
1350-0C              733 ( 1) .false  clc
1351-39              734 ( 5)         rts
1352-86 0A           735 ( 2) .err10  ldaa    #10             ; "Print statement error"
1354-7E 14 70        736 ( 3)         jmp     write_err_msg
1357-                737
1357-                738
1357-                739      ; -----------------------------------------------------------------------
1357-                740      ; タブを出力する
1357-                741      ; Write tabs
1357-                742      ;【引数】なし
1357-                743      ;【使用】B
1357-                744      ;【返値】なし
1357-                745      ; -----------------------------------------------------------------------
1357-                746      write_tab:
1357-BD FF B5        747 ( 6) .top    jsr     write_space
135A-7B 07 39        748 ( 4)         tim     #7,<TabCount
135D-26 F8           749 ( 3)         bne     :top
135F-39              750 ( 5)         rts
1360-                751
1360-                752
1360-                753      ; -----------------------------------------------------------------------
1360-                754      ; 式を評価して変数に値を代入する
1360-                755      ; Evaluate an expression and assign a value to a variable
1360-                756      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
1360-                757      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
1360-                758      ;【返値】D:Integer X:次の実行位置アドレス
1360-                759      ; -----------------------------------------------------------------------
1360-                760      assign_to_var:
1360-BD 13 23        761 ( 6)         jsr     skip_space
1363-BD 10 5D        762 ( 6)         jsr     eval_expression
1366-24 07           763 ( 3)         bcc     :err04
1368-3C              764 ( 5)         pshx                    ; 実行位置アドレスを退避
1369-DE 8B           765 ( 4)         ldx     <VariableAddr
136B-ED 00           766 ( 5)         std     0,x             ; 変数に結果を保存
136D-38              767 ( 4)         pulx                    ; 実行位置アドレスを復帰
136E-39              768 ( 5)         rts
136F-86 04           769 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1371-7E 14 70        770 ( 3)         jmp     write_err_msg
1374-                771
1374-                772
1374-                773      ; -----------------------------------------------------------------------
1374-                774      ; Print文を実行する
1374-                775      ; Execute 'print' statement
1374-                776      ;【引数】X:実行位置アドレス
1374-                777      ;【使用】B, X（下位ルーチンでA）
1374-                778      ;【返値】なし
1374-                779      ; -----------------------------------------------------------------------
1374-                780      exe_print:
1374-72 01 8F        781 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1377-BD 13 23        782 ( 6) .loop   jsr     skip_space
137A-27 37           783 ( 3)         beq     :finish         ; 終端文字なら改行して終了
137C-BD 13 2F        784 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
137F-25 1B           785 ( 3)         bcs     :nlon
1381-BD 10 5D        786 ( 6)         jsr     eval_expression
1384-25 11           787 ( 3)         bcs     :int
1386-                788            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
1386-                789            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
1386-C1 3B           790 ( 2) .check  cmpb    #';'
1388-27 23           791 ( 3)         beq     :nloff
138A-C1 2C           792 ( 2)         cmpb    #','
138C-27 1C           793 ( 3)         beq     :tab
138E-C1 3A           794 ( 2)         cmpb    #':'
1390-27 21           795 ( 3)         beq     :finish
1392-86 04           796 ( 2)         ldaa    #4              ; "Illegal expression"
1394-7E 14 70        797 ( 3)         jmp     write_err_msg
1397-3C              798 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1398-BD 12 C5        799 ( 6)         jsr     write_integer   ; 評価した式を出力
139B-38              800 ( 4)         pulx                    ; 実行位置アドレスを復帰
139C-72 01 8F        801 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
139F-BD 13 23        802 ( 6)         jsr     skip_space
13A2-C1 3B           803 ( 2)         cmpb    #';'
13A4-27 07           804 ( 3)         beq     :nloff
13A6-C1 2C           805 ( 2)         cmpb    #','
13A8-26 09           806 ( 3)         bne     :finish
13AA-BD 13 57        807 ( 6) .tab    jsr     write_tab       ; タブ出力
13AD-7F 00 8F        808 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
13B0-08              809 ( 1)         inx                     ; 次の文字へ
13B1-20 C4           810 ( 3)         bra     :loop
13B3-7D 00 8F        811 ( 4) .finish tst     <NewLineFlag
13B6-27 03           812 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
13B8-BD FF B2        813 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
13BB-7E 10 11        814 ( 3) .end    jmp     is_multi
13BE-                815
13BE-                816
13BE-                817      ; -----------------------------------------------------------------------
13BE-                818      ; input文を実行する
13BE-                819      ; Execute 'input' statement
13BE-                820      ; -----------------------------------------------------------------------
13BE-                821      exe_input:
13BE-BD 13 23        822 ( 6)         jsr     skip_space
13C1-27 31           823 ( 3)         beq     :end            ; 終端文字なら改行して終了
13C3-BD 13 2F        824 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
13C6-24 0A           825 ( 3)         bcc     :1
13C8-E6 00           826 ( 4)         ldab    0,x
13CA-C1 3B           827 ( 2)         cmpb    #';'
13CC-26 29           828 ( 3)         bne     :err00
13CE-08              829 ( 1)         inx
13CF-BD 13 23        830 ( 6)         jsr     skip_space
13D2-BD 13 0E        831 ( 6) .1      jsr     is_variable
13D5-24 20           832 ( 3)         bcc     :err00
13D7-86 01           833 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
13D9-58              834 ( 1)         aslb                    ; B = 変数領域の下位バイト
13DA-DD 8B           835 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
13DC-                836            ; // 変数の後に余計な文字がないか確認
13DC-                837            ; // 例えば "input a+b" など
13DC-DF 8D           838 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
13DE-BD 13 23        839 ( 6)         jsr     skip_space
13E1-27 06           840 ( 3)         beq     :read           ; 終端文字なら入力へ
13E3-C1 3A           841 ( 2)         cmpb    #':'            ; ":"なら入力へ
13E5-26 10           842 ( 3)         bne     :err00          ; それ以外の文字ならエラー
13E7-DE 8D           843 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
13E9-BD FF A9        844 ( 6) .read   jsr     read_line
13EC-CE 01 00        845 ( 3)         ldx     #Rx_BUFFER
13EF-BD 13 60        846 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
13F2-DE 8D           847 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
13F4-7E 10 11        848 ( 3) .end    jmp     is_multi
13F7-4F              849 ( 1) .err00  clra                    ; "Syntax error"
13F8-7E 14 70        850 ( 3)         jmp     write_err_msg
13FB-                851
13FB-                852
13FB-                853      ; -----------------------------------------------------------------------
13FB-                854      ; if文を実行する
13FB-                855      ; Execute 'if' statement
13FB-                856      ;【引数】X:実行位置アドレス
13FB-                857      ;【使用】B, X
13FB-                858      ;【返値】なし
13FB-                859      ; -----------------------------------------------------------------------
13FB-BD 13 23        860 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
13FE-27 0B           861 ( 3)         beq     :end            ; 終端文字なら終了
1400-BD 10 5D        862 ( 6)         jsr     eval_expression ; 式評価
1403-24 09           863 ( 3)         bcc     :err04
1405-5D              864 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
1406-27 03           865 ( 3)         beq     :end
1408-7E 10 24        866 ( 3)         jmp     exe_line        ; True
140B-7E 10 03        867 ( 3) .end    jmp     tb_main         ; Falseならば全て無視され行末まで進む
140E-86 04           868 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1410-7E 14 70        869 ( 3)         jmp     write_err_msg
1413-                870
1413-                871
1413-                872      ; -----------------------------------------------------------------------
1413-                873      ; テーブル検索
1413-                874      ; Search the keyword table
1413-                875      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
1413-                876      ;【使用】A, B, X
1413-                877      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
1413-                878      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
1413-                879      ; -----------------------------------------------------------------------
1413-                880      search_table:
1413-EC 05           881 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
1415-91 98           882 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1417-26 2F           883 ( 3)         bne     :false
1419-D1 99           884 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
141B-26 2B           885 ( 3)         bne     :false
141D-EC 07           886 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
141F-4D              887 ( 1)         tsta                    ; $00（終端記号）か？
1420-27 1B           888 ( 3)         beq     :true
1422-91 9A           889 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
1424-26 22           890 ( 3)         bne     :false
1426-5D              891 ( 1)         tstb                    ; $00（終端記号）か？
1427-27 14           892 ( 3)         beq     :true
1429-D1 9B           893 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
142B-26 1B           894 ( 3)         bne     :false
142D-EC 09           895 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
142F-4D              896 ( 1)         tsta                    ; $00（終端記号）か？
1430-27 0B           897 ( 3)         beq     :true
1432-91 9C           898 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
1434-26 12           899 ( 3)         bne     :false
1436-5D              900 ( 1)         tstb                    ; $00（終端記号）か？
1437-27 04           901 ( 3)         beq     :true
1439-D1 9D           902 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
143B-26 0B           903 ( 3)         bne     :false
143D-E6 02           904 ( 4) .true   ldab    2,x             ; B = 語長
143F-EE 03           905 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
1441-31              906 ( 1)         ins                     ; 元のリターンアドレスを削除
1442-31              907 ( 1)         ins
1443-3C              908 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1444-DE 8D           909 ( 4)         ldx     <ExePointer
1446-3A              910 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1447-39              911 ( 5)         rts                     ; 命令ルーチンにジャンプ
1448-EE 00           912 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
144A-26 C7           913 ( 3)         bne     :top
144C-DE 8D           914 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
144E-0C              915 ( 1)         clc                     ; false: C=0
144F-39              916 ( 5)         rts
1450-                917
1450-                918
1450-                919      ; ***********************************************************************
1450-                920      ;   キーワードテーブル Keyword table
1450-                921      ; ***********************************************************************
1450-                922      ; レコードの構造 Record structure
1450-                923      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1450-                924      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
1450-                925      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
1450-                926      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1450-                927      ; キーワードは2文字以上6文字以下
1450-                928      SMT_TABLE:      .eq     *
1450-14 5B           929      .print          .dw     :input
1452-05              930                      .db     5
1453-13 74           931                      .dw     exe_print
1455-70 72 69 6E 
     74 00           932                      .az     "print"
145B-14 66           933      .input          .dw     :if
145D-05              934                      .db     5
145E-13 BE           935                      .dw     exe_input
1460-69 6E 70 75 
     74 00           936                      .az     "input"
1466-14 6E           937      .if             .dw     :bottom
1468-02              938                      .db     2
1469-13 FB           939                      .dw     exe_if
146B-69 66 00        940                      .az     "if"
146E-00 00           941      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
1470-                942
1470-                943
1470-                944      ; -----------------------------------------------------------------------
1470-                945      ; エラーメッセージを表示する
1470-                946      ; Write Error Messege
1470-                947      ;【引数】A: エラーコード
1470-                948      ;【使用】A, B, X
1470-                949      ;【返値】なし
1470-                950      ; -----------------------------------------------------------------------
1470-                951      write_err_msg:
1470-7D 00 39        952 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
1473-27 03           953 ( 3)         beq     :1
1475-BD FF B2        954 ( 6)         jsr     write_crlf
1478-CE 14 91        955 ( 3) .1      ldx     #ERRMSG
147B-BD FF AF        956 ( 6)         jsr     write_line
147E-16              957 ( 1)         tab
147F-CE 14 99        958 ( 3)         ldx     #ERRCODE
1482-3A              959 ( 1)         abx
1483-EE 00           960 ( 5)         ldx     0,x
1485-BD FF AF        961 ( 6)         jsr     write_line
1488-BD FF B2        962 ( 6)         jsr     write_crlf
148B-DE 80           963 ( 4)         ldx     <StackPointer
148D-35              964 ( 1)         txs
148E-7E 10 03        965 ( 3)         jmp     tb_main
1491-                966
1491-45 52 52 4F 
     52 3A 20 00     967      ERRMSG  .az     "ERROR: "
1499-14 A5           968      ERRCODE .dw     .err00
149B-14 B2           969              .dw     .err02
149D-14 C5           970              .dw     .err04
149F-14 D8           971              .dw     .err06
14A1-14 F1           972              .dw     .err08
14A3-14 FD           973              .dw     .err10
14A5-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00              974      .err00  .az     "Syntax error"
14B2-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00        975      .err02  .az     "Out of range value"
14C5-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00        976      .err04  .az     "Illegal expression"
14D8-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00              977      .err06  .az     "Calculate stack overflow"
14F1-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00     978      .err08  .az     "Zero Divide"
14FD-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00           979      .err10  .az     "Print statement error"
1513-                980
1513-                981
1513-                982      ; ***********************************************************************
1513-                983      ;   デバック用ルーチン Debugging routines
1513-                984      ; ***********************************************************************
1513-                985      ; -----------------------------------------------------------------------
1513-                986      ; ユーザーレジスタを表示する
1513-                987      ; Display user registers
1513-                988      ; -----------------------------------------------------------------------
1513-36              989 ( 4) PUTUR:  psha
1514-37              990 ( 4)         pshb
1515-3C              991 ( 5)         pshx
1516-CE 15 49        992 ( 3)         ldx     #:MSGUR0
1519-BD FF AF        993 ( 6)         jsr     write_line
151C-DC 90           994 ( 4)         ldd     <UR0
151E-BD FF BB        995 ( 6)         jsr     write_word
1521-CE 15 4E        996 ( 3)         ldx     #:MSGUR1
1524-BD FF AF        997 ( 6)         jsr     write_line
1527-DC 92           998 ( 4)         ldd     <UR1
1529-BD FF BB        999 ( 6)         jsr     write_word
152C-CE 15 54       1000 ( 3)         ldx     #:MSGUR2
152F-BD FF AF       1001 ( 6)         jsr     write_line
1532-DC 94          1002 ( 4)         ldd     <UR2
1534-BD FF BB       1003 ( 6)         jsr     write_word
1537-CE 15 5A       1004 ( 3)         ldx     #:MSGUR3
153A-BD FF AF       1005 ( 6)         jsr     write_line
153D-DC 96          1006 ( 4)         ldd     <UR3
153F-BD FF BB       1007 ( 6)         jsr     write_word
1542-BD FF B2       1008 ( 6)         jsr     write_crlf
1545-38             1009 ( 4)         pulx
1546-33             1010 ( 3)         pulb
1547-32             1011 ( 3)         pula
1548-39             1012 ( 5)         rts
1549-55 52 30 3D 
     00             1013      .MSGUR0          .az     "UR0="
154E-20 55 52 31 
     3D 00          1014      .MSGUR1          .az     " UR1="
1554-20 55 52 32 
     3D 00          1015      .MSGUR2          .az     " UR2="
155A-20 55 52 33 
     3D 00          1016      .MSGUR3          .az     " UR3="
