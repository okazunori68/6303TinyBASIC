0000-                 14
0000-                 15      ; ***********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ***********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ***********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0011-                 46      XON             .eq     $11     ; DC1
0013-                 47      XOFF            .eq     $13     ; DC3
0000-                 48
0020-                 49      RAM_START       .eq     $0020
1FFF-                 50      RAM_END         .eq     $1fff
E000-                 51      ROM_START       .eq     $e000
FFFF-                 52      ROM_END         .eq     $ffff
1000-                 53      PROGRAM_START   .eq     $1000   ; プログラム開始アドレス
0FFF-                 54      STACK           .eq     $0fff
0000-                 55
0400-                 56      USER_AREA_TOP   .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 57      USER_AREA_BTM   .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 58
0000-                 59      ; ***********************************************************************
0000-                 60      ;   システム変数 System variables
0000-                 61      ; ***********************************************************************
0000-                 62              .sm     RAM
0020-                 63              .or     $20
0020-                 64
0020-                 65      ; Interrupt Vector Hooking
0020-                 66      VEC_TRAP        .bs     3
0023-                 67      VEC_SCI         .bs     3
0026-                 68      VEC_TOF         .bs     3
0029-                 69      VEC_OCF         .bs     3
002C-                 70      VEC_ICF         .bs     3
002F-                 71      VEC_IRQ         .bs     3
0032-                 72      VEC_SWI         .bs     3
0035-                 73      VEC_NMI         .bs     3
0038-                 74      BreakPointFlag  .bs     1
0039-                 75      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 76      RxBffrQty       .bs     1       ; 受信バッファデータ数
003B-                 77      RxBffrReadPtr   .bs     2       ; 受信バッファ読み込みポインタ
003D-                 78      RxBffrWritePtr  .bs     2       ; 受信バッファ書き込みポインタ
003F-                 79      ; General-Purpose Registers
003F-                 80      R0              .bs     2
0041-                 81      R1              .bs     2
0043-                 82
0043-                 83      ; ***********************************************************************
0043-                 84      ;   システムワークエリア System work area
0043-                 85      ; ***********************************************************************
0043-                 86              .sm     RAM
0100-                 87              .or     $0100
0100-                 88      ; 各種バッファ
0100-                 89      Rx_BUFFER       .bs     64      ; 受信バッファ（$0100-$013f）
013F-                 90      Rx_BUFFER_END   .eq     *-1
0040-                 91      Rx_BFFR_SIZE    .eq     Rx_BUFFER_END-Rx_BUFFER+1
0140-                 92      TEXT_BFFR       .bs     73      ; テキストバッファ（$0140-$188: 73byte）
0188-                 93      TEXT_BFFR_END   .eq     *-1
0049-                 94      TEXT_BFFR_SIZE  .eq     TEXT_BFFR_END-TEXT_BFFR+1
0189-                 95
0189-                 96      ; ***********************************************************************
0189-                 97      ;   変数 Variables
0189-                 98      ; ***********************************************************************
0189-                 99              .sm     RAM
0080-                100              .or     $80
0080-                101
0080-                102      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                103      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                104      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                105      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                106      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                107      Divisor         .bs     2       ; 除数
0089-                108      Remainder       .bs     2       ; 剰余
008B-                109      VariableAddr    .bs     2       ; 変数のアドレス
008D-                110      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                111      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                112      Source          .bs     2       ; 転送元アドレス
0092-                113      Destination     .bs     2       ; 転送先アドレス
0094-                114      Bytes           .bs     2       ; 転送バイト数
0096-                115      LineNumber      .bs     2       ; 行番号
0098-                116      LineLength      .bs     2       ; 行の長さ
009A-                117      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                118      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                119      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                120      ModuloMode      .bs     1       ; 剰余演算フラグ 0 = tranc, 1以上 = floor
00A0-                121      ToSubFlag       .bs     1       ; 分岐モードフラグ 0 = goto, 1 = gosub
00A1-                122      SStackPtr       .bs     2       ; サブルーチンスタック（Subroutine stack）ポインタ
00A3-                123      ArrayAddr       .bs     2       ; 配列変数の先頭アドレス
00A5-                124      MaxSubscript    .bs     2       ; 配列の最大添字数
00A7-                125      RndNumber       .bs     2       ; 乱数値
00A9-                126
00A9-                127      ; General-Purpose Registers
00A9-                128      UR0             *
00A9-                129      UR0H            .bs     1
00AA-                130      UR0L            .bs     1
00AB-                131      UR1             *
00AB-                132      UR1H            .bs     1
00AC-                133      UR1L            .bs     1
00AD-                134      UR2             *
00AD-                135      UR2H            .bs     1
00AE-                136      UR2L            .bs     1
00AF-                137      UR3             *
00AF-                138      UR3H            .bs     1
00B0-                139      UR3L            .bs     1
00B1-                140      ; Work area
00B1-                141      COMPARE         .bs     6       ; 文字列比較用バッファ
00B7-                142
00B7-                143      ; ***********************************************************************
00B7-                144      ;   ワークエリア work area
00B7-                145      ; ***********************************************************************
00B7-                146              .sm     RAM
0200-                147              .or     $0200
0200-                148      CSTACK          .bs     40      ; 計算スタック (Calculate stack)
0227-                149      CSTACK_BTM      .eq     *-1
0028-                150      CSTACK_SIZE     .eq     CSTACK_BTM-CSTACK+1
0228-                151      SSTACK          .bs     40      ; サブルーチンスタック (Subroutine stack)
024F-                152      SSTACK_BTM      .eq     *-1
0028-                153      SSTACK_SIZE     .eq     SSTACK_BTM-SSTACK+1
02C2-                154              .or     $02c2
02C2-                155      VARIABLE        .bs     52      ; 変数26文字 ($01c2-01f5)
02F5-                156      VARIABLE_END    .eq     *-1
0034-                157      VARIABLE_SIZE   .eq     VARIABLE_END-VARIABLE+1
02F6-                158
02F6-                159      ; ***********************************************************************
02F6-                160      ;   Program Start
02F6-                161      ; ***********************************************************************
0000-                162              .sm     CODE
1000-                163              .or     PROGRAM_START
1000-                164
1000-                165      init_tinybasic:
1000-30              166 ( 1)         tsx
1001-DF 80           167 ( 4)         stx     <StackPointer
1003-                168
1003-                169
1003-                170      cold_start:
1003-                171            ; // プログラムエリアの初期化
1003-CE 04 00        172 ( 3)         ldx     #USER_AREA_TOP
1006-DF 9A           173 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              174 ( 1)         clra
1009-5F              175 ( 1)         clrb
100A-ED 00           176 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           177 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                178            ; // 変数領域の初期化
100E-CE 02 C2        179 ( 3)         ldx     #VARIABLE
1011-ED 00           180 ( 5) .loop   std     0,x
1013-08              181 ( 1)         inx
1014-08              182 ( 1)         inx
1015-8C 02 F6        183 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
1018-26 F7           184 ( 3)         bne     :loop
101A-                185            ; // 配列変数の初期化
101A-CC 04 02        186 ( 3)         ldd     #USER_AREA_TOP+2
101D-DD A3           187 ( 4)         std     <ArrayAddr
101F-CC 09 FF        188 ( 3)         ldd     #USER_AREA_BTM+2-USER_AREA_TOP
1022-04              189 ( 1)         lsrd
1023-DD A5           190 ( 4)         std     <MaxSubscript
1025-                191            ; // 乱数のSeed値の設定
1025-DC 09           192 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
1027-27 FC           193 ( 3)         beq     :seed           ; Seedはゼロ以外
1029-DD A7           194 ( 4)         std     <RndNumber
102B-                195
102B-                196      warm_start:
102B-                197            ; // スタックポインタの初期化
102B-CE 02 50        198 ( 3)         ldx     #SSTACK_BTM+1
102E-DF A1           199 ( 4)         stx     <SStackPtr
1030-                200            ; // 各種フラグの初期化
1030-4F              201 ( 1)         clra
1031-97 9F           202 ( 3)         staa    <ModuloMode     ; 剰余演算をtrunc（0への切捨て除算）にする
1033-97 A0           203 ( 3)         staa    <ToSubFlag      ; 分岐モードを0 = gotoにする
1035-                204
1035-                205
1035-                206      tb_main:
1035-72 01 9C        207 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
1038-C6 3E           208 ( 2)         ldab    #'>'
103A-BD FF AC        209 ( 6)         jsr     write_char
103D-BD FF A9        210 ( 6)         jsr     read_line
1040-CE 01 40        211 ( 3)         ldx     #TEXT_BFFR      ; 実行位置アドレスをセット
1043-                212            ; // 行番号判定
1043-BD 14 AB        213 ( 6)         jsr     get_int_from_decimal
1046-24 0A           214 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
1048-83 00 00        215 ( 3)         subd    #0
104B-2E 08           216 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
104D-86 0C           217 ( 2) .err12  ldaa    #12             ; "Invalid line number"
104F-7E 18 D4        218 ( 3)         jmp     write_err_msg
1052-                219
1052-                220      ; 実行モード（ダイレクトモード）
1052-                221      execute_mode:
1052-7E 11 8B        222 ( 3)         jmp     exe_line
1055-                223
1055-                224      ; 行編集モード
1055-                225      ; 空行か否か、空行でなければ同じ行番号か否かで処理を振り分ける
1055-                226      edit_mode:
1055-DF 8D           227 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1057-DD 96           228 ( 4)         std     <LineNumber     ; 行番号を保存
1059-                229            ; // 空行チェック
1059-BD 15 74        230 ( 6)         jsr     skip_space
105C-26 02           231 ( 3)         bne     :1
105E-20 1B           232 ( 3)         bra     delete_line     ; 空行だったら削除ルーチンへ
1060-                233      .1    ; // 入力行の長さチェック（Aレジスタに文字数）
1060-DE 8D           234 ( 4)         ldx     <ExePointer     ; バッファアドレスを復帰
1062-86 04           235 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1064-E6 00           236 ( 4) .loop   ldab    0,x
1066-27 04           237 ( 3)         beq     :2
1068-4C              238 ( 1)         inca                    ; 行の長さを+1
1069-08              239 ( 1)         inx                     ; バッファアドレスを+1
106A-20 F8           240 ( 3)         bra     :loop
106C-97 99           241 ( 3) .2      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
106E-                242            ; // 同じ行があるかどうか確認
106E-CE 04 00        243 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
1071-BD 15 D8        244 ( 6)         jsr     scan_line_num   ; 行番号検索
1074-DF 9D           245 ( 4)         stx     <ExeLineAddr    ; 検索した行アドレスをExeLineAddrに退避しておく
1076-24 29           246 ( 3)         bcc     not_same_line_num
1078-7E 11 01        247 ( 3)         jmp     same_line_num
107B-                248
107B-                249      ; 一行削除
107B-                250      delete_line:
107B-CE 04 00        251 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
107E-BD 15 D8        252 ( 6)         jsr     scan_line_num   ; 行番号検索
1081-24 1B           253 ( 3)         bcc     :end            ; 同じ行がなければ何もしない
1083-                254            ; // 転送先アドレスの設定（既存の行の先頭アドレス）
1083-DF 92           255 ( 4)         stx     <Destination
1085-                256            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1085-E6 02           257 ( 4)         ldab    2,x
1087-D7 99           258 ( 3)         stab    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存しておく
1089-3A              259 ( 1)         abx
108A-DF 90           260 ( 4)         stx     <Source
108C-                261            ; // 転送バイト数の設定（プログラム終端アドレス - 次の行の先頭アドレス + 2）
108C-DC 9A           262 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
108E-93 90           263 ( 4)         subd    <Source         ; - 次の行の先頭アドレス
1090-C3 00 02        264 ( 3)         addd    #2              ; + 2
1093-DD 94           265 ( 4)         std     <Bytes
1095-                266            ; // ブロック転送
1095-BD 17 9F        267 ( 6)         jsr     mem_move
1098-                268            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス - 行の長さ）
1098-DC 9A           269 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
109A-93 98           270 ( 4)         subd    <LineLength     ; - 行の長さ
109C-DD 9A           271 ( 4)         std     <PrgmEndAddr
109E-7E 11 59        272 ( 3) .end    jmp     array_index
10A1-                273
10A1-                274      ; 同じ行番号がなかった場合の処理
10A1-                275      not_same_line_num:
10A1-                276            ; // D:次に大きな行番号 X:次に大きな行の先頭アドレス
10A1-83 00 00        277 ( 3)         subd    #0              ; tstd
10A4-27 22           278 ( 3)         beq     :add            ; 最終行より後ろ（D=$0000）だったら入力行挿入
10A6-                279            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10A6-DC 9A           280 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10A8-D3 98           281 ( 4)         addd    <LineLength     ; + 行の長さ
10AA-8D 48           282 ( 5)         bsr     check_pgrm_end
10AC-DD 9A           283 ( 4)         std     <PrgmEndAddr
10AE-                284            ; // 転送元アドレスの設定（次に大きな行の先頭アドレス）
10AE-DF 90           285 ( 4)         stx     <Source
10B0-                286            ; // 転送先アドレスの設定（次に大きな行の先頭アドレス + 行の長さ）
10B0-D6 99           287 ( 3)         ldab    <LineLength+1   ; 行の長さ
10B2-3A              288 ( 1)         abx                     ; + 次に大きな行の先頭アドレス
10B3-DF 92           289 ( 4)         stx     <Destination
10B5-                290            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
10B5-DC 9A           291 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10B7-93 90           292 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
10B9-C3 00 02        293 ( 3)         addd    #2              ; + 2
10BC-DD 94           294 ( 4)         std     <Bytes
10BE-                295            ; // ブロック転送
10BE-BD 17 9F        296 ( 6)         jsr     mem_move
10C1-                297            ; // 入力行の挿入
10C1-DE 9D           298 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
10C3-8D 16           299 ( 5)         bsr     insert_new_line
10C5-7E 11 59        300 ( 3)         jmp     array_index
10C8-                301      .add
10C8-                302            ; // D:$0000 X:プログラム終端アドレス
10C8-                303            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10C8-DC 9A           304 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10CA-D3 98           305 ( 4)         addd    <LineLength     ; + 行の長さ
10CC-8D 26           306 ( 5)         bsr     check_pgrm_end
10CE-DD 9A           307 ( 4)         std     <PrgmEndAddr
10D0-                308            ; // 入力行の挿入
10D0-8D 09           309 ( 5)         bsr     insert_new_line
10D2-                310            ; // 終端行の挿入
10D2-DE 9A           311 ( 4)         ldx     <PrgmEndAddr
10D4-4F              312 ( 1)         clra
10D5-5F              313 ( 1)         clrb
10D6-ED 00           314 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
10D8-7E 11 59        315 ( 3)         jmp     array_index
10DB-                316
10DB-                317      ; 入力行の転送
10DB-                318      insert_new_line:
10DB-DC 96           319 ( 4)         ldd     <LineNumber     ; 行番号を転送
10DD-ED 00           320 ( 5)         std     0,x
10DF-08              321 ( 1)         inx
10E0-08              322 ( 1)         inx
10E1-D6 99           323 ( 3)         ldab    <LineLength+1   ; 行の長さを転送
10E3-E7 00           324 ( 4)         stab    0,x
10E5-08              325 ( 1)         inx
10E6-                326            ; // 転送先アドレスの設定（現在の位置）
10E6-DF 92           327 ( 4)         stx     <Destination
10E8-                328            ; // 転送バイト数の設定（行の長さ - 3（行番号 - 長さ））
10E8-4F              329 ( 1)         clra                    ; 行の長さ（A=0,B=下位8bit）
10E9-C0 03           330 ( 2)         subb    #3              ; - 3
10EB-DD 94           331 ( 4)         std     <Bytes
10ED-                332            ; // 転送元アドレスの設定（入力された行）
10ED-DC 8D           333 ( 4)         ldd     <ExePointer     ; バッファアドレスを復帰（行番号の直後を指している）
10EF-DD 90           334 ( 4)         std     <Source
10F1-                335            ; // ブロック転送
10F1-7E 17 9F        336 ( 3)         jmp     mem_move        ; 飛び先でrts
10F4-                337
10F4-                338      ; プログラムエリアを超えていないか確認
10F4-                339      check_pgrm_end:
10F4-18              340 ( 2)         xgdx
10F5-8C 0D FD        341 ( 3)         cpx     #USER_AREA_BTM
10F8-18              342 ( 2)         xgdx
10F9-24 01           343 ( 3)         bcc     :err14
10FB-39              344 ( 5)         rts
10FC-86 0E           345 ( 2) .err14  ldaa    #14              ; "Memory size over"
10FE-7E 18 D4        346 ( 3)         jmp     write_err_msg
1101-                347
1101-                348      ; 同じ行番号があった場合、既存の行との長さの差で処理を振り分ける
1101-                349      same_line_num:
1101-                350            ; // D:行番号 X:既存の行の開始アドレス
1101-96 99           351 ( 3)         ldaa    <LineLength+1   ; 入力行の長さを取得
1103-A0 02           352 ( 4)         suba    2,x             ; **Aレジスタ** = 入力行の長さ - 既存行の長さ
1105-2B 2D           353 ( 3)         bmi     short_length    ; 入力行の長さ < 既存行の長さ
1107-27 26           354 ( 3)         beq     same_length     ; 入力行の長さ = 既存行の長さ
1109-                355
1109-                356      ; 入力行が既存の行より長い場合
1109-                357      long_length:                    ; 入力行の長さ > 既存行の長さ
1109-                358            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1109-E6 02           359 ( 4)         ldab    2,x
110B-3A              360 ( 1)         abx
110C-DF 90           361 ( 4)         stx     <Source
110E-                362            ; // 転送先アドレスの設定（次の行の先頭アドレス + 入力行の長さ - 既存行の長さ）
110E-16              363 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
110F-4F              364 ( 1)         clra
1110-DD AB           365 ( 4)         std     <UR1            ; 入力行の長さ - 既存行の長さを後で使うためにUR1に保存
1112-3A              366 ( 1)         abx                     ; 次の行の先頭アドレス + （入力行の長さ - 既存行の長さ）
1113-DF 92           367 ( 4)         stx     <Destination
1115-                368            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1115-DC 9A           369 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1117-93 90           370 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1119-C3 00 02        371 ( 3)         addd    #2              ; + 2
111C-DD 94           372 ( 4)         std     <Bytes
111E-                373            ; // 新しいプログラム終端アドレスの設定
111E-                374            ; // （プログラム終端アドレス + 入力行の長さ - 既存行の長さ）
111E-DC 9A           375 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1120-D3 AB           376 ( 4)         addd    <UR1            ; + 入力行の長さ - 既存行の長さ
1122-8D D0           377 ( 5)         bsr     check_pgrm_end
1124-DD 9A           378 ( 4)         std     <PrgmEndAddr
1126-                379            ; // ブロック転送
1126-BD 17 9F        380 ( 6)         jsr     mem_move
1129-                381            ; // 入力行の挿入
1129-DE 9D           382 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
112B-8D AE           383 ( 5)         bsr     insert_new_line
112D-20 2A           384 ( 3)         bra     array_index
112F-                385
112F-                386      ; 入力行と既存の行が同じ長さの場合
112F-                387      same_length:
112F-8D AA           388 ( 5)         bsr     insert_new_line
1131-7E 10 35        389 ( 3)         jmp     tb_main
1134-                390
1134-                391      ; 入力行が既存の行より短い場合
1134-                392      short_Length:
1134-                393            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1134-E6 02           394 ( 4)         ldab    2,x
1136-3A              395 ( 1)         abx
1137-DF 90           396 ( 4)         stx     <Source
1139-                397            ; // 転送先アドレスの設定（次の行の先頭アドレス - 既存行の長さ + 入力行の長さ）
1139-16              398 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
113A-50              399 ( 1)         negb                    ; 絶対値にする
113B-4F              400 ( 1)         clra
113C-DD AB           401 ( 4)         std     <UR1            ; 既存行の長さ - 入力行の長さ
113E-18              402 ( 2)         xgdx
113F-93 AB           403 ( 4)         subd    <UR1            ; 次の行の先頭アドレス - （既存行の長さ - 入力行の長さ）
1141-DD 92           404 ( 4)         std     <Destination
1143-                405            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
1143-DC 9A           406 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1145-93 90           407 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1147-C3 00 02        408 ( 3)         addd    #2              ; + 2
114A-DD 94           409 ( 4)         std     <Bytes
114C-                410            ; // ブロック転送
114C-BD 17 9F        411 ( 6)         jsr     mem_move
114F-                412            ; // 新しいプログラム終端アドレスの設定
114F-                413            ; // （プログラム終端アドレス - 既存行の長さ + 入力行の長さ）
114F-DC 9A           414 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1151-93 AB           415 ( 4)         subd    <UR1            ; - （既存行の長さ - 入力行の長さ）
1153-DD 9A           416 ( 4)         std     <PrgmEndAddr
1155-                417            ; // 入力行の挿入
1155-DE 9D           418 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1157-8D 82           419 ( 5)         bsr     insert_new_line
1159-                420
1159-                421      array_index:
1159-DC 9A           422 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
115B-C3 00 02        423 ( 3)         addd    #2              ; + 2
115E-DD A3           424 ( 4)         std     <ArrayAddr      ; 配列変数の先頭アドレス
1160-CC 0D FF        425 ( 3)         ldd     #USER_AREA_BTM+2
1163-93 A3           426 ( 4)         subd    <ArrayAddr
1165-04              427 ( 1)         lsrd
1166-DD A5           428 ( 4)         std     <MaxSubscript
1168-7E 10 35        429 ( 3)         jmp     tb_main
116B-                430
116B-                431
116B-                432      ; -----------------------------------------------------------------------
116B-                433      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
116B-                434      ; Is a multi statement mark?
116B-                435      ;【引数】X:実行位置アドレス
116B-                436      ;【使用】B, X
116B-                437      ;【返値】なし
116B-                438      ; -----------------------------------------------------------------------
116B-                439      is_multi:
116B-BD 15 74        440 ( 6)         jsr     skip_space
116E-27 0B           441 ( 3)         beq     eol_process
1170-C1 3A           442 ( 2)         cmpb    #':'
1172-26 03           443 ( 3)         bne     :err00
1174-08              444 ( 1)         inx
1175-20 14           445 ( 3)         bra     exe_line
1177-4F              446 ( 1) .err00  clra                    ; "Syntax error"
1178-7E 18 D4        447 ( 3)         jmp     write_err_msg
117B-                448
117B-                449
117B-                450      ; -----------------------------------------------------------------------
117B-                451      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
117B-                452      ;  - directモードであればそのまま終了
117B-                453      ;  - runモードであれば次の行のポインタを設定してrts
117B-                454      ; End-of-line processing
117B-                455      ;  - If in direct mode, terminate execution
117B-                456      ;  - If run mode, set the pointer to the next line and rts
117B-                457      ;【引数】なし
117B-                458      ;【使用】A, B, X
117B-                459      ;【返値】なし
117B-                460      ; -----------------------------------------------------------------------
117B-                461      eol_process:
117B-                462            ; // runモードであれば次の行のポインタを設定してrts
117B-7D 00 9C        463 ( 4)         tst     <ExeStateFlag
117E-26 08           464 ( 3)         bne     :end
1180-DE 9D           465 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
1182-E6 02           466 ( 4)         ldab    2,x             ; 行の長さを取得
1184-3A              467 ( 1)         abx                     ; 次の行の先頭アドレスを取得
1185-DF 9D           468 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
1187-39              469 ( 5)         rts
1188-7E 10 2B        470 ( 3) .end    jmp     warm_start      ; directモードであればそのまま終了
118B-                471
118B-                472
118B-                473      ; -----------------------------------------------------------------------
118B-                474      ; 一行実行
118B-                475      ; Execute one line
118B-                476      ;【引数】X:実行位置アドレス
118B-                477      ;【使用】A, B, X
118B-                478      ;【返値】なし
118B-                479      ; -----------------------------------------------------------------------
118B-                480      exe_line:
118B-BD 15 74        481 ( 6)         jsr     skip_space
118E-27 EB           482 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
1190-                483            ; // 配列変数のチェック
1190-C1 40           484 ( 2)         cmpb    #'@'
1192-26 1B           485 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
1194-E6 01           486 ( 4)         ldab    1,x
1196-C1 28           487 ( 2)         cmpb    #'('            ; 直後の文字は'('？
1198-26 4A           488 ( 3)         bne     :err00          ; No. "Syntax error"
119A-08              489 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
119B-08              490 ( 1)         inx
119C-BD 11 ED        491 ( 6)         jsr     eval_expression ; 添字を取得する
119F-24 47           492 ( 3)         bcc     :err04
11A1-                493            ; // ')'の確認
11A1-37              494 ( 4)         pshb                    ; 添字の下位8bitを退避
11A2-E6 00           495 ( 4)         ldab    0,x
11A4-C1 29           496 ( 2)         cmpb    #')'
11A6-26 3C           497 ( 3)         bne     :err00
11A8-33              498 ( 3)         pulb                    ; 添字の下位8bitを復帰
11A9-08              499 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
11AA-BD 15 B1        500 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
11AD-20 08           501 ( 3)         bra     :let
11AF-BD 15 5F        502 ( 6) .var    jsr     is_variable     ; 変数か？
11B2-24 12           503 ( 3)         bcc     :cmd            ; No. テーブル検索へ
11B4-86 02           504 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
11B6-58              505 ( 1)         aslb                    ; B = 変数領域の下位バイト
11B7-DD 8B           506 ( 4) .let    std     <VariableAddr   ; 変数アドレスを保存
11B9-                507            ; // 代入文のチェック
11B9-BD 15 74        508 ( 6)         jsr     skip_space      ; Yes. 代入文か？
11BC-C1 3D           509 ( 2)         cmpb    #'='
11BE-26 24           510 ( 3)         bne     :err00          ; No. エラー処理へ
11C0-08              511 ( 1)         inx                     ; Yes. 代入実行
11C1-BD 15 C4        512 ( 6)         jsr     assign_to_var
11C4-20 A5           513 ( 3)         bra     is_multi
11C6-                514            ; // コマンド・ステートメントのチェック
11C6-EC 00           515 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
11C8-DD B1           516 ( 4)         std     <COMPARE
11CA-EC 02           517 ( 5)         ldd     2,x
11CC-DD B3           518 ( 4)         std     <COMPARE+2
11CE-EC 04           519 ( 5)         ldd     4,x
11D0-DD B5           520 ( 4)         std     <COMPARE+4
11D2-DF 8D           521 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
11D4-7D 00 9C        522 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
11D7-27 05           523 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
11D9-CE 18 4D        524 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
11DC-20 03           525 ( 3)         bra     :2
11DE-CE 18 69        526 ( 3) .1      ldx     #SMT_TABLE
11E1-BD 18 10        527 ( 6) .2      jsr     search_table    ; テーブル検索実行
11E4-4F              528 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
11E5-7E 18 D4        529 ( 3)         jmp     write_err_msg
11E8-86 04           530 ( 2) .err04  ldaa    #4              ; "Illegal expression"
11EA-7E 18 D4        531 ( 3)         jmp     write_err_msg
11ED-                532
11ED-                533
11ED-                534      ; -----------------------------------------------------------------------
11ED-                535      ; 式を評価する
11ED-                536      ; Evaluate the expression
11ED-                537      ;【引数】B:アスキーコード X:実行位置アドレス
11ED-                538      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
11ED-                539      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
11ED-                540      ;        偽(C=0) / X:現在の実行位置アドレス
11ED-                541      ; -----------------------------------------------------------------------
11ED-                542      eval_expression:
00AD-                543      .SP     .eq     UR2
00AF-                544      .X      .eq     UR3
11ED-                545            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
11ED-DF AF           546 ( 4)         stx     <:X
11EF-30              547 ( 1)         tsx
11F0-DF AD           548 ( 4)         stx     <:SP
11F2-DE AF           549 ( 4)         ldx     <:X
11F4-                550            ; // 計算スタックの初期化
11F4-CC 02 28        551 ( 3)         ldd     #CSTACK_BTM+1
11F7-DD 82           552 ( 4)         std     <CStackPtr
11F9-                553            ; // 式評価開始
11F9-8D 08           554 ( 5)         bsr     expr_4th
11FB-                555            ; // 計算結果をスタックトップから取り出す
11FB-3C              556 ( 5)         pshx
11FC-DE 82           557 ( 4)         ldx     <CStackPtr
11FE-EC 00           558 ( 5)         ldd     0,x
1200-38              559 ( 4)         pulx
1201-0D              560 ( 1)         sec                     ; true:C=1
1202-39              561 ( 5)         rts
1203-                562
1203-                563      expr_4th:
1203-8D 50           564 ( 5)         bsr     expr_3rd
1205-BD 15 74        565 ( 6) .loop   jsr     skip_space
1208-C1 3D           566 ( 2)         cmpb    #'='            ; '='?
120A-26 08           567 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
120C-08              568 ( 1)         inx
120D-8D 46           569 ( 5)         bsr     expr_3rd
120F-BD 14 5E        570 ( 6)         jsr     CS_eq           ; EQual to
1212-20 F1           571 ( 3)         bra     :loop
1214-C1 3C           572 ( 2) .ltsign cmpb    #'<'            ; '<'?
1216-26 22           573 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1218-08              574 ( 1)         inx
1219-E6 00           575 ( 4)         ldab    0,x
121B-C1 3E           576 ( 2)         cmpb    #'>'            ; '<>'?
121D-26 08           577 ( 3)         bne     :lte
121F-08              578 ( 1)         inx
1220-8D 33           579 ( 5)         bsr     expr_3rd
1222-BD 14 7F        580 ( 6)         jsr     CS_ne           ; Not Equal to
1225-20 DE           581 ( 3)         bra     :loop
1227-C1 3D           582 ( 2) .lte    cmpb    #'='            ; '<='?
1229-26 08           583 ( 3)         bne     :lt
122B-08              584 ( 1)         inx
122C-8D 27           585 ( 5)         bsr     expr_3rd
122E-BD 14 74        586 ( 6)         jsr     CS_lte          ; Less Than or Equal to
1231-20 D2           587 ( 3)         bra     :loop
1233-8D 20           588 ( 5) .lt     bsr     expr_3rd
1235-BD 14 69        589 ( 6)         jsr     CS_lt           ; Less Than
1238-20 CB           590 ( 3)         bra     :loop
123A-C1 3E           591 ( 2) .gtsign cmpb    #'>'            ; '>'?
123C-26 16           592 ( 3)         bne     :end
123E-08              593 ( 1)         inx
123F-E6 00           594 ( 4)         ldab    0,x
1241-C1 3D           595 ( 2)         cmpb    #'='            ; '>='?
1243-26 08           596 ( 3)         bne     :gt
1245-08              597 ( 1)         inx
1246-8D 0D           598 ( 5)         bsr     expr_3rd
1248-BD 14 95        599 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
124B-20 B8           600 ( 3)         bra     :loop
124D-8D 06           601 ( 5) .gt     bsr     expr_3rd
124F-BD 14 8A        602 ( 6)         jsr     CS_gt           ; Greater Than
1252-20 B1           603 ( 3)         bra     :loop
1254-39              604 ( 5) .end    rts
1255-                605
1255-                606      expr_3rd:
1255-8D 1C           607 ( 5)         bsr     expr_2nd
1257-BD 15 74        608 ( 6) .loop   jsr     skip_space
125A-C1 2B           609 ( 2)         cmpb    #'+'
125C-26 08           610 ( 3)         bne     :minus
125E-08              611 ( 1)         inx
125F-8D 12           612 ( 5)         bsr     expr_2nd
1261-BD 13 28        613 ( 6)         jsr     CS_add
1264-20 F1           614 ( 3)         bra     :loop
1266-C1 2D           615 ( 2) .minus  cmpb    #'-'
1268-26 08           616 ( 3)         bne     :end
126A-08              617 ( 1)         inx
126B-8D 06           618 ( 5)         bsr     expr_2nd
126D-BD 13 31        619 ( 6)         jsr     CS_sub
1270-20 E5           620 ( 3)         bra     :loop
1272-39              621 ( 5) .end    rts
1273-                622
1273-                623      expr_2nd:
1273-8D 28           624 ( 5)         bsr     expr_1st
1275-BD 15 74        625 ( 6) .loop   jsr     skip_space
1278-C1 2A           626 ( 2)         cmpb    #'*'
127A-26 08           627 ( 3)         bne     :div
127C-08              628 ( 1)         inx
127D-8D 1E           629 ( 5)         bsr     expr_1st
127F-BD 13 3A        630 ( 6)         jsr     CS_mul
1282-20 F1           631 ( 3)         bra     :loop
1284-C1 2F           632 ( 2) .div    cmpb    #'/'
1286-26 08           633 ( 3)         bne     :mod
1288-08              634 ( 1)         inx
1289-8D 12           635 ( 5)         bsr     expr_1st
128B-BD 13 57        636 ( 6)         jsr     CS_div
128E-20 E5           637 ( 3)         bra     :loop
1290-C1 25           638 ( 2) .mod    cmpb    #'%'
1292-26 08           639 ( 3)         bne     :end
1294-08              640 ( 1)         inx
1295-8D 06           641 ( 5)         bsr     expr_1st
1297-BD 13 70        642 ( 6)         jsr     CS_mod
129A-20 D9           643 ( 3)         bra     :loop
129C-39              644 ( 5) .end    rts
129D-                645
129D-                646      expr_1st:
00AD-                647      .SP     .eq     UR2
00AF-                648      .X      .eq     UR3
129D-BD 15 74        649 ( 6)         jsr     skip_space
12A0-BD 14 AB        650 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
12A3-24 02           651 ( 3)         bcc     :array          ; 数字でなければ配列変数のチェックへ
12A5-20 59           652 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
12A7-C1 40           653 ( 2) .array  cmpb    #'@'
12A9-26 22           654 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
12AB-E6 01           655 ( 4)         ldab    1,x
12AD-C1 28           656 ( 2)         cmpb    #'('            ; 直後の文字は'('？
12AF-26 66           657 ( 3)         bne     :err00          ; No. "Syntax error"
12B1-08              658 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
12B2-08              659 ( 1)         inx
12B3-BD 12 03        660 ( 6)         jsr     expr_4th        ; 添字を取得する
12B6-                661            ; // ')'の確認
12B6-C1 29           662 ( 2)         cmpb    #')'
12B8-26 5D           663 ( 3)         bne     :err00
12BA-3C              664 ( 5)         pshx                    ; 実行位置アドレスを退避
12BB-DE 82           665 ( 4)         ldx     <CStackPtr
12BD-EC 00           666 ( 5)         ldd     0,x             ; 添字の取得
12BF-08              667 ( 1)         inx
12C0-08              668 ( 1)         inx
12C1-DF 82           669 ( 4)         stx     <CStackPtr
12C3-BD 15 B1        670 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
12C6-18              671 ( 2)         xgdx                    ; X = 配列変数のアドレス
12C7-EC 00           672 ( 5)         ldd     0,x             ; 配列変数値を取得
12C9-38              673 ( 4)         pulx                    ; 実行位置アドレスを復帰
12CA-08              674 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
12CB-20 33           675 ( 3)         bra     :push
12CD-BD 15 5F        676 ( 6) .var    jsr     is_variable     ; 変数か？
12D0-24 0A           677 ( 3)         bcc     :func           ; 変数でなければカッコのチェックへ
12D2-                678            ; // 変数値の取得
12D2-3C              679 ( 5)         pshx                    ; 実行位置アドレスを退避
12D3-86 02           680 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
12D5-58              681 ( 1)         aslb                    ; B = 変数領域の下位バイト
12D6-18              682 ( 2)         xgdx                    ; X = 変数のアドレス
12D7-EC 00           683 ( 5)         ldd     0,x             ; D <- 変数の値
12D9-38              684 ( 4)         pulx                    ; 実行位置アドレスを復帰
12DA-20 24           685 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
12DC-EC 00           686 ( 5) .func   ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
12DE-DD B1           687 ( 4)         std     <COMPARE
12E0-EC 02           688 ( 5)         ldd     2,x
12E2-DD B3           689 ( 4)         std     <COMPARE+2
12E4-EC 04           690 ( 5)         ldd     4,x
12E6-DD B5           691 ( 4)         std     <COMPARE+4
12E8-DF 8D           692 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
12EA-CE 18 C8        693 ( 3)         ldx     #FUNC_TABLE
12ED-BD 18 10        694 ( 6)         jsr     search_table    ; テーブル検索実行。飛び先でrts
12F0-E6 00           695 ( 4)         ldab    0,x             ; 該当関数がなかった場合はもう一度文字を読み込む
12F2-C1 28           696 ( 2) .paren  cmpb    #'('
12F4-26 1A           697 ( 3)         bne     :err
12F6-08              698 ( 1)         inx
12F7-BD 12 03        699 ( 6)         jsr     expr_4th
12FA-C1 29           700 ( 2)         cmpb    #')'
12FC-26 12           701 ( 3)         bne     :err
12FE-08              702 ( 1)         inx
12FF-39              703 ( 5)         rts
1300-3C              704 ( 5) .push   pshx                    ; 実行位置アドレスを退避
1301-DE 82           705 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1303-09              706 ( 1)         dex
1304-09              707 ( 1)         dex
1305-8C 01 FE        708 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
1308-25 11           709 ( 3)         bcs     :err06
130A-ED 00           710 ( 5)         std     0,x
130C-DF 82           711 ( 4)         stx     <CStackPtr
130E-38              712 ( 4)         pulx                    ; 実行位置アドレスを復帰
130F-39              713 ( 5)         rts
1310-                714            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
1310-DE AD           715 ( 4) .err    ldx     <:SP
1312-35              716 ( 1)         txs
1313-DE AF           717 ( 4)         ldx     <:X
1315-0C              718 ( 1)         clc                     ; false:C=0
1316-39              719 ( 5)         rts
1317-4F              720 ( 1) .err00  clra                    ; "Syntax error"
1318-7E 18 D4        721 ( 3)         jmp     write_err_msg
131B-86 06           722 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
131D-7E 18 D4        723 ( 3)         jmp     write_err_msg
1320-                724
1320-                725      ;
1320-                726      ; Arithmetic operator
1320-                727      ;
1320-                728      CS_store:
1320-08              729 ( 1)         inx
1321-08              730 ( 1)         inx
1322-ED 00           731 ( 5)         std     0,x
1324-DF 82           732 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
1326-38              733 ( 4)         pulx                    ; 実行位置アドレスを復帰
1327-39              734 ( 5)         rts
1328-                735
1328-3C              736 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
1329-DE 82           737 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
132B-EC 02           738 ( 5)         ldd     2,x
132D-E3 00           739 ( 5)         addd    0,x
132F-20 EF           740 ( 3)         bra     CS_store
1331-                741
1331-3C              742 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
1332-DE 82           743 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1334-EC 02           744 ( 5)         ldd     2,x
1336-A3 00           745 ( 5)         subd    0,x
1338-20 E6           746 ( 3)         bra     CS_store
133A-                747
133A-                748      CS_mul:
00A9-                749      .Result         .eq     UR0
133A-3C              750 ( 5)         pshx                    ; 実行位置アドレスを退避
133B-DE 82           751 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
133D-                752              ; B * D
133D-A6 03           753 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
133F-E6 01           754 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
1341-3D              755 ( 7)         mul                     ; B * D
1342-DD A9           756 ( 4)         std     <:Result        ;「B*D」を保存
1344-                757              ; A * D
1344-EC 01           758 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
1346-3D              759 ( 7)         mul                     ; A * D
1347-DB A9           760 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
1349-D7 A9           761 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
134B-                762              ; C * B
134B-A6 00           763 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
134D-E6 03           764 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
134F-3D              765 ( 7)         mul                     ; C * B
1350-DB A9           766 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1352-17              767 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1353-D6 AA           768 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
1355-20 C9           769 ( 3)         bra     CS_store
1357-                770
1357-                771      ;
1357-                772      ; trunc : 符号付き割り算の考え方
1357-                773      ; ・剰余は被除数の符号と同一
1357-                774      ;   ・ 7 / 3  = 商  2、剰余  1
1357-                775      ;   ・-7 / 3  = 商 -2、剰余 -1
1357-                776      ;   ・ 7 / -3 = 商 -2、剰余  1
1357-                777      ;   ・-7 / -3 = 商  2、剰余 -1
1357-                778      ;
1357-7D 00 9F        779 ( 4) CS_div: tst     <ModuloMode
135A-26 7A           780 ( 3)         bne     CS_div2
135C-3C              781 ( 5)         pshx                    ; 実行位置アドレスを退避
135D-DE 82           782 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
135F-8D 2B           783 ( 5)         bsr     div_uint        ; 除算実行
1361-18              784 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1362-7D 00 85        785 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1365-27 05           786 ( 3)         beq     :end            ; '+'なら終了
1367-43              787 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1368-53              788 ( 1)         comb
1369-C3 00 01        789 ( 3)         addd    #1
136C-DE 82           790 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
136E-20 B0           791 ( 3)         bra     CS_store
1370-                792
1370-7D 00 9F        793 ( 4) CS_mod: tst     <ModuloMode
1373-26 7E           794 ( 3)         bne     CS_mod2
1375-3C              795 ( 5)         pshx                    ; 実行位置アドレスを退避
1376-DE 82           796 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1378-8D 12           797 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
137A-DD 89           798 ( 4)         std     <Remainder      ; 剰余はゼロか？
137C-27 0A           799 ( 3)         beq     :end            ; ゼロであれば終了
137E-7D 00 86        800 ( 4)         tst     <RemSignFlag    ; 剰余の符号チェック
1381-27 05           801 ( 3)         beq     :end            ; '+'なら終了
1383-43              802 ( 1) .sign   coma                    ; '-'なら2の補数にする
1384-53              803 ( 1)         comb
1385-C3 00 01        804 ( 3)         addd    #1
1388-DE 82           805 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
138A-20 94           806 ( 3)         bra     CS_store
138C-                807
138C-                808      div_uint:
00A9-                809      .Counter        .eq     UR0H
138C-EC 00           810 ( 5)         ldd     0,x             ; ゼロ除算チェック
138E-27 41           811 ( 3)         beq     :err08          ; 除数がゼロならエラー
1390-5F              812 ( 1)         clrb
1391-D7 85           813 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1393-D7 86           814 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1395-C6 10           815 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1397-D7 A9           816 ( 3)         stab    <:Counter
1399-                817              ; // 剰余の符号フラグの設定
1399-EC 02           818 ( 5)         ldd     2,x             ; Dレジスタに被除数を代入
139B-2A 03           819 ( 3)         bpl     :1              ; 被除数が正であれば剰余の符号は正（0）
139D-7C 00 86        820 ( 6)         inc     <RemSignFlag    ; 被除数が負であれば剰余の符号は負（1）
13A0-                821              ; // 商の符号フラグの設定
13A0-A8 00           822 ( 4) .1      eora    0,x             ; 被除数の符号と除数の符号のXORを取る
13A2-2A 03           823 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
13A4-7C 00 85        824 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
13A7-                825              ; // 除数を絶対値にする
13A7-EC 00           826 ( 5) .2      ldd     0,x             ; D <- 除数
13A9-2A 05           827 ( 3)         bpl     :3
13AB-43              828 ( 1)         coma                    ; 除数が負なら絶対値にする
13AC-53              829 ( 1)         comb
13AD-C3 00 01        830 ( 3)         addd    #1
13B0-DD 87           831 ( 4) .3      std     <Divisor        ; 除数を保存
13B2-                832              ; // 被除数を絶対値にする
13B2-EC 02           833 ( 5)         ldd     2,x             ; D <- 被除数
13B4-2A 05           834 ( 3)         bpl     :4
13B6-43              835 ( 1)         coma                    ; 被除数が負なら絶対値にする
13B7-53              836 ( 1)         comb
13B8-C3 00 01        837 ( 3)         addd    #1
13BB-                838              ; // 除算実行
13BB-18              839 ( 2) .4      xgdx                    ; X <- 被除数
13BC-4F              840 ( 1)         clra                    ; D（WORK）をクリア
13BD-5F              841 ( 1)         clrb
13BE-18              842 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
13BF-05              843 ( 1)         asld
13C0-18              844 ( 2)         xgdx
13C1-59              845 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
13C2-49              846 ( 1)         rola
13C3-93 87           847 ( 4)         subd    <Divisor        ; WORK - 除数
13C5-08              848 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
13C6-24 03           849 ( 3)         bcc     :5              ; WORKから除数を引けた？
13C8-D3 87           850 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
13CA-09              851 ( 1)         dex                     ; XレジスタのLSBを0に戻す
13CB-7A 00 A9        852 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
13CE-26 EE           853 ( 3)         bne     :loop
13D0-39              854 ( 5)         rts
13D1-86 08           855 ( 2) .err08  ldaa    #8              ; "Zero Divide"
13D3-7E 18 D4        856 ( 3)         jmp     write_err_msg
13D6-                857
13D6-                858      ;
13D6-                859      ; floor : 符号付き割り算の考え方
13D6-                860      ; ・剰余は除数の符号と同一
13D6-                861      ;   ・ 7 / 3  = 商  2、剰余  1
13D6-                862      ;   ・-7 / 3  = 商 -3、剰余  2
13D6-                863      ;   ・ 7 / -3 = 商 -3、剰余 -2
13D6-                864      ;   ・-7 / -3 = 商  2、剰余 -1
13D6-                865      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
13D6-                866      ;       2.ただし、除数がゼロの場合は1は足さない
13D6-                867      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
13D6-                868      ;         除数の絶対値から剰余の絶対値を引く
13D6-                869      ;       2.その結果を除数と同じ符号にする
13D6-                870      ;       3.ただし、除数がゼロの場合は剰余もゼロ
13D6-                871      ;
13D6-                872      CS_div2:
13D6-3C              873 ( 5)         pshx                    ; 実行位置アドレスを退避
13D7-DE 82           874 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13D9-8D 39           875 ( 5)         bsr     div_uint2       ; 除算実行
13DB-18              876 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
13DC-7D 00 85        877 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
13DF-27 0D           878 ( 3)         beq     :end            ; '+'なら終了
13E1-8C 00 00        879 ( 3)         cpx     #0              ; 剰余はゼロか？
13E4-27 03           880 ( 3)         beq     :sign
13E6-C3 00 01        881 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
13E9-43              882 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
13EA-53              883 ( 1)         comb
13EB-C3 00 01        884 ( 3)         addd    #1
13EE-DE 82           885 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
13F0-7E 13 20        886 ( 3)         jmp     CS_store
13F3-                887
13F3-                888      CS_mod2:
13F3-3C              889 ( 5)         pshx                    ; 実行位置アドレスを退避
13F4-DE 82           890 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13F6-8D 1C           891 ( 5)         bsr     div_uint2        ; 除算実行。D = 剰余
13F8-DD 89           892 ( 4)         std     <Remainder      ; 剰余はゼロか？
13FA-27 13           893 ( 3)         beq     :end            ; ゼロであれば終了
13FC-7D 00 85        894 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
13FF-27 04           895 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
1401-DC 87           896 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1403-93 89           897 ( 4)         subd    <Remainder
1405-7D 00 86        898 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1408-27 05           899 ( 3)         beq     :end            ; '+'なら終了
140A-43              900 ( 1)         coma                    ; '-'なら2の補数にする
140B-53              901 ( 1)         comb
140C-C3 00 01        902 ( 3)         addd    #1
140F-DE 82           903 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1411-7E 13 20        904 ( 3)         jmp     CS_store
1414-                905
1414-                906      div_uint2:
00A9-                907      .Counter        .eq     UR0H
1414-EC 00           908 ( 5)         ldd     0,x             ; ゼロ除算チェック
1416-27 41           909 ( 3)         beq     :err08          ; 除数がゼロならエラー
1418-5F              910 ( 1)         clrb
1419-D7 85           911 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
141B-D7 86           912 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
141D-C6 10           913 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
141F-D7 A9           914 ( 3)         stab    <:Counter
1421-                915              ; // 剰余の符号フラグの設定
1421-EC 00           916 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1423-2A 03           917 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1425-7C 00 86        918 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1428-                919              ; // 商の符号フラグの設定
1428-A8 02           920 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
142A-2A 03           921 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
142C-7C 00 85        922 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
142F-                923              ; // 除数を絶対値にする
142F-EC 00           924 ( 5) .2      ldd     0,x             ; D <- 除数
1431-2A 05           925 ( 3)         bpl     :3
1433-43              926 ( 1)         coma                    ; 除数が負なら絶対値にする
1434-53              927 ( 1)         comb
1435-C3 00 01        928 ( 3)         addd    #1
1438-DD 87           929 ( 4) .3      std     <Divisor        ; 除数を保存
143A-                930              ; // 被除数を絶対値にする
143A-EC 02           931 ( 5)         ldd     2,x             ; D <- 被除数
143C-2A 05           932 ( 3)         bpl     :4
143E-43              933 ( 1)         coma                    ; 被除数が負なら絶対値にする
143F-53              934 ( 1)         comb
1440-C3 00 01        935 ( 3)         addd    #1
1443-                936              ; // 除算実行
1443-18              937 ( 2) .4      xgdx                    ; X <- 被除数
1444-4F              938 ( 1)         clra                    ; D（WORK）をクリア
1445-5F              939 ( 1)         clrb
1446-18              940 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
1447-05              941 ( 1)         asld
1448-18              942 ( 2)         xgdx
1449-59              943 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
144A-49              944 ( 1)         rola
144B-93 87           945 ( 4)         subd    <Divisor        ; WORK - 除数
144D-08              946 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
144E-24 03           947 ( 3)         bcc     :5              ; WORKから除数を引けた？
1450-D3 87           948 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1452-09              949 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1453-7A 00 A9        950 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1456-26 EE           951 ( 3)         bne     :loop
1458-39              952 ( 5)         rts
1459-86 08           953 ( 2) .err08  ldaa    #8              ; "Zero Divide"
145B-7E 18 D4        954 ( 3)         jmp     write_err_msg
145E-                955
145E-3C              956 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
145F-DE 82           957 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1461-EC 02           958 ( 5)         ldd     2,x
1463-A3 00           959 ( 5)         subd    0,x
1465-27 39           960 ( 3)         beq     CS_true
1467-20 3D           961 ( 3)         bra     CS_false
1469-                962
1469-3C              963 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
146A-DE 82           964 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
146C-EC 02           965 ( 5)         ldd     2,x
146E-A3 00           966 ( 5)         subd    0,x
1470-2D 2E           967 ( 3)         blt     CS_true
1472-20 32           968 ( 3)         bra     CS_false
1474-                969
1474-3C              970 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1475-DE 82           971 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1477-EC 02           972 ( 5)         ldd     2,x
1479-A3 00           973 ( 5)         subd    0,x
147B-2F 23           974 ( 3)         ble     CS_true
147D-20 27           975 ( 3)         bra     CS_false
147F-                976
147F-3C              977 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
1480-DE 82           978 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1482-EC 02           979 ( 5)         ldd     2,x
1484-A3 00           980 ( 5)         subd    0,x
1486-26 18           981 ( 3)         bne     CS_true
1488-20 1C           982 ( 3)         bra     CS_false
148A-                983
148A-3C              984 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
148B-DE 82           985 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
148D-EC 02           986 ( 5)         ldd     2,x
148F-A3 00           987 ( 5)         subd    0,x
1491-2E 0D           988 ( 3)         bgt     CS_true
1493-20 11           989 ( 3)         bra     CS_false
1495-                990
1495-3C              991 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
1496-DE 82           992 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1498-EC 02           993 ( 5)         ldd     2,x
149A-A3 00           994 ( 5)         subd    0,x
149C-2C 02           995 ( 3)         bge     CS_true
149E-20 06           996 ( 3)         bra     CS_false
14A0-                997
14A0-                998      CS_true:
14A0-CC 00 01        999 ( 3)         ldd     #1
14A3-7E 13 20       1000 ( 3)         jmp     CS_store
14A6-               1001
14A6-               1002      CS_false:
14A6-4F             1003 ( 1)         clra
14A7-5F             1004 ( 1)         clrb
14A8-7E 13 20       1005 ( 3)         jmp     CS_store
14AB-               1006
14AB-               1007      ; -----------------------------------------------------------------------
14AB-               1008      ; テキストバッファの10進文字列から数値を取得する
14AB-               1009      ; Get a integer from a decimal string in a text buffer
14AB-               1010      ;【引数】X:バッファアドレス
14AB-               1011      ;【使用】A, B, X, UR0, UR1
14AB-               1012      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
14AB-               1013      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
14AB-               1014      ; -----------------------------------------------------------------------
14AB-               1015      get_int_from_decimal:
00A9-               1016      .RetValue       .eq     UR0     ; Return Value
00AB-               1017      .TempValue      .eq     UR1     ; Temporary Value
14AB-4F             1018 ( 1)         clra
14AC-5F             1019 ( 1)         clrb
14AD-DD A9          1020 ( 4)         std     <:RetValue
14AF-97 AB          1021 ( 3)         staa    <:TempValue
14B1-97 84          1022 ( 3)         staa    <SignFlag
14B3-E6 00          1023 ( 4)         ldab    0,x             ; 1文字取得
14B5-C1 2D          1024 ( 2)         cmpb    #'-'            ; マイナス記号か？
14B7-26 05          1025 ( 3)         bne     :1
14B9-7C 00 84       1026 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
14BC-20 0B          1027 ( 3)         bra     :next
14BE-C1 2B          1028 ( 2) .1      cmpb    #'+'            ; プラス記号か？
14C0-27 07          1029 ( 3)         beq     :next
14C2-BD FF C1       1030 ( 6)         jsr     is_decimal_char ; 数字か？
14C5-24 36          1031 ( 3)         bcc     :false          ; No. C=1で終了
14C7-20 13          1032 ( 3)         bra     :first
14C9-08             1033 ( 1) .next   inx                     ; 符号の次の1文字を取得
14CA-E6 00          1034 ( 4)         ldab    0,x
14CC-BD FF C1       1035 ( 6)         jsr     is_decimal_char ; 数字か？
14CF-24 40          1036 ( 3)         bcc     :err04          ; No. エラー処理へ
14D1-20 09          1037 ( 3)         bra     :first          ; Yes. これが最初の数字
14D3-DD A9          1038 ( 4) .loop   std     <:RetValue      ; 結果を退避
14D5-E6 00          1039 ( 4)         ldab    0,x             ; 1文字取得
14D7-BD FF C1       1040 ( 6)         jsr     is_decimal_char ; 数字か？
14DA-24 14          1041 ( 3)         bcc     :end
14DC-C0 30          1042 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
14DE-D7 AC          1043 ( 3)         stab    <:TempValue+1
14E0-               1044            ; // RetValue * 10 + TempValue
14E0-DC A9          1045 ( 4)         ldd     <:RetValue
14E2-05             1046 ( 1)         asld                    ; * 2
14E3-05             1047 ( 1)         asld                    ; * 4
14E4-D3 A9          1048 ( 4)         addd    <:RetValue      ; * 5
14E6-05             1049 ( 1)         asld                    ; * 10
14E7-D3 AB          1050 ( 4)         addd    <:TempValue     ; += TempValue
14E9-08             1051 ( 1)         inx                     ; ポインタを進める
14EA-25 20          1052 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
14EC-2B 10          1053 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
14EE-20 E3          1054 ( 3)         bra     :loop
14F0-DC A9          1055 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
14F2-7D 00 84       1056 ( 4)         tst     <SignFlag       ; 符号チェック
14F5-27 05          1057 ( 3)         beq     :true
14F7-43             1058 ( 1)         coma                    ; 負なら2の補数に
14F8-53             1059 ( 1)         comb
14F9-C3 00 01       1060 ( 3)         addd    #1
14FC-0D             1061 ( 1) .true   sec
14FD-39             1062 ( 5) .false  rts
14FE-               1063
14FE-               1064      .overflow
14FE-               1065            ; // -32,768かどうかの判定
14FE-18             1066 ( 2)         xgdx
14FF-8C 80 00       1067 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
1502-18             1068 ( 2)         xgdx
1503-26 07          1069 ( 3)         bne     :err02          ; No. 範囲外
1505-7D 00 84       1070 ( 4)         tst     <SignFlag       ; 符号チェック
1508-27 02          1071 ( 3)         beq     :err02          ; 正ならば範囲外
150A-20 C7          1072 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
150C-               1073
150C-86 02          1074 ( 2) .err02  ldaa    #2              ; "Out of range"
150E-7E 18 D4       1075 ( 3)         jmp     write_err_msg
1511-86 04          1076 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1513-7E 18 D4       1077 ( 3)         jmp     write_err_msg
1516-               1078
1516-               1079
1516-               1080      ; -----------------------------------------------------------------------
1516-               1081      ; Dレジスタの数値をコンソールに出力する
1516-               1082      ; Write Decimal Character converted from Integer
1516-               1083      ;【引数】D:Integer
1516-               1084      ;【使用】A, B, X
1516-               1085      ;【返値】なし
1516-               1086      ; -----------------------------------------------------------------------
1516-               1087      write_integer:
00A9-               1088      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00AA-               1089      .Counter        .eq     UR0L    ; 桁カウンター
1516-2A 0C          1090 ( 3)         bpl     :plus           ; 符号判定
1518-37             1091 ( 4)         pshb                    ; 負数なら'-'を出力する
1519-C6 2D          1092 ( 2)         ldab    #'-'
151B-BD FF AC       1093 ( 6)         jsr     write_char
151E-33             1094 ( 3)         pulb
151F-43             1095 ( 1)         coma                    ; 絶対値にする（2の補数にする）
1520-53             1096 ( 1)         comb
1521-C3 00 01       1097 ( 3)         addd    #1
1524-7F 00 A9       1098 ( 5) .plus   clr     <:ZeroSuppress
1527-CE 15 57       1099 ( 3)         ldx     #:CONST
152A-7F 00 AA       1100 ( 5) .loop   clr     <:Counter
152D-A3 00          1101 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
152F-25 05          1102 ( 3)         bcs     :write
1531-7C 00 AA       1103 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1534-20 F7          1104 ( 3)         bra     :digit
1536-               1105
1536-E3 00          1106 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1538-37             1107 ( 4)         pshb
1539-D6 AA          1108 ( 3)         ldab    <:Counter
153B-27 03          1109 ( 3)         beq     :1              ; この桁はゼロか？
153D-7C 00 A9       1110 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
1540-7D 00 A9       1111 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1543-27 05          1112 ( 3)         beq     :2              ; No. この桁は表示しない
1545-CB 30          1113 ( 2)         addb    #$30            ; Yes. この桁を表示する
1547-BD FF AC       1114 ( 6)         jsr     write_char
154A-33             1115 ( 3) .2      pulb
154B-08             1116 ( 1)         inx                     ; 次の引く数へ
154C-08             1117 ( 1)         inx
154D-8C 15 5F       1118 ( 3)         cpx     #:CONST+8
1550-26 D8          1119 ( 3)         bne     :loop
1552-CB 30          1120 ( 2)         addb    #$30            ; 一の桁の数値を表示
1554-7E FF AC       1121 ( 3)         jmp     write_char
1557-               1122      ; Dから引いていく数
1557-27 10          1123      .CONST  .dw     $2710           ; 10,000
1559-03 E8          1124              .dw     $03e8           ; 1,000
155B-00 64          1125              .dw     $0064           ; 100
155D-00 0A          1126              .dw     $000a           ; 10
155F-               1127
155F-               1128
155F-               1129      ; -----------------------------------------------------------------------
155F-               1130      ; テキストバッファの英文字が変数か判定する
155F-               1131      ; Is a character retrieved from a text buffer a variable?
155F-               1132      ;【引数】X:バッファアドレス
155F-               1133      ;【使用】A, B, X
155F-               1134      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
155F-               1135      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
155F-               1136      ; -----------------------------------------------------------------------
155F-               1137      is_variable:
155F-E6 00          1138 ( 4)         ldab    0,x
1561-BD FF BE       1139 ( 6)         jsr     is_alphabetic_char
1564-24 0D          1140 ( 3)         bcc     :end
1566-17             1141 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1567-E6 01          1142 ( 4)         ldab    1,x                     ; 2文字目を取得
1569-BD FF BE       1143 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
156C-16             1144 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
156D-24 02          1145 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
156F-0C             1146 ( 1)         clc                             ; Yes. 変数ではない。C=0
1570-39             1147 ( 5)         rts
1571-08             1148 ( 1) .var    inx                             ; ポインタを進める
1572-0D             1149 ( 1)         sec                             ; C=1
1573-39             1150 ( 5) .end    rts
1574-               1151
1574-               1152
1574-               1153      ; -----------------------------------------------------------------------
1574-               1154      ; 空白を読み飛ばす
1574-               1155      ; Skip Space
1574-               1156      ;【引数】X:実行位置アドレス
1574-               1157      ;【使用】B, X
1574-               1158      ;【返値】B:アスキーコード（$00の時Z=1）
1574-               1159      ;        X:実行位置アドレス
1574-               1160      ; -----------------------------------------------------------------------
1574-               1161      skip_space:
1574-E6 00          1162 ( 4)         ldab    0,x
1576-27 07          1163 ( 3)         beq     :end
1578-C1 20          1164 ( 2)         cmpb    #SPACE
157A-22 03          1165 ( 3)         bhi     :end
157C-08             1166 ( 1)         inx
157D-20 F5          1167 ( 3)         bra     skip_space
157F-39             1168 ( 5) .end    rts
1580-               1169
1580-               1170
1580-               1171      ; -----------------------------------------------------------------------
1580-               1172      ; 引用符付きの文字列を出力する
1580-               1173      ; Write Quoted Stirng
1580-               1174      ;【引数】B:アスキーコード X:実行位置アドレス
1580-               1175      ;【使用】A, B, X
1580-               1176      ;【返値】真(C=1) / X:次の実行位置アドレス
1580-               1177      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
1580-               1178      ; -----------------------------------------------------------------------
1580-               1179      write_quoted_str:
1580-C1 22          1180 ( 2)         cmpb    #$22            ; 一重引用符か？
1582-27 04          1181 ( 3)         beq     :1
1584-C1 27          1182 ( 2)         cmpb    #$27            ; 二重引用符か？
1586-26 19          1183 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
1588-17             1184 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
1589-               1185            ; // 終端の引用符をチェック
1589-3C             1186 ( 5)         pshx
158A-08             1187 ( 1) .check  inx
158B-E6 00          1188 ( 4)         ldab    0,x
158D-27 14          1189 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
158F-11             1190 ( 1)         cba
1590-26 F8          1191 ( 3)         bne     :check
1592-38             1192 ( 4)         pulx
1593-               1193            ; // 文字列の出力
1593-08             1194 ( 1) .loop   inx
1594-E6 00          1195 ( 4)         ldab    0,x
1596-11             1196 ( 1)         cba                     ; 保存した引用符との比較
1597-27 05          1197 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
1599-BD FF AC       1198 ( 6)         jsr     write_char
159C-20 F5          1199 ( 3)         bra     :loop
159E-08             1200 ( 1) .true   inx
159F-0D             1201 ( 1)         sec
15A0-39             1202 ( 5)         rts
15A1-0C             1203 ( 1) .false  clc
15A2-39             1204 ( 5)         rts
15A3-86 0A          1205 ( 2) .err10  ldaa    #10             ; "Print statement error"
15A5-7E 18 D4       1206 ( 3)         jmp     write_err_msg
15A8-               1207
15A8-               1208
15A8-               1209      ; -----------------------------------------------------------------------
15A8-               1210      ; タブを出力する
15A8-               1211      ; Write tabs
15A8-               1212      ;【引数】なし
15A8-               1213      ;【使用】B
15A8-               1214      ;【返値】なし
15A8-               1215      ; -----------------------------------------------------------------------
15A8-               1216      write_tab:
15A8-BD FF B5       1217 ( 6) .top    jsr     write_space
15AB-7B 07 39       1218 ( 4)         tim     #7,<TabCount
15AE-26 F8          1219 ( 3)         bne     :top
15B0-39             1220 ( 5)         rts
15B1-               1221
15B1-               1222
15B1-               1223      ; -----------------------------------------------------------------------
15B1-               1224      ; 配列変数のアドレスを取得する
15B1-               1225      ; Set the address of the array variable
15B1-               1226      ;【引数】D:添字
15B1-               1227      ;【使用】A, B
15B1-               1228      ;【返値】D:配列変数のアドレス
15B1-               1229      ; -----------------------------------------------------------------------
15B1-               1230      set_array_addr:
15B1-18             1231 ( 2)         xgdx
15B2-9C A5          1232 ( 4)         cpx     <MaxSubscript   ; 取得した添字 > 添字の最大値？
15B4-22 09          1233 ( 3)         bhi     :err22          ; Yes. エラー処理
15B6-18             1234 ( 2)         xgdx
15B7-05             1235 ( 1)         asld                    ; 添字を2倍にする
15B8-D3 A3          1236 ( 4)         addd    <ArrayAddr
15BA-39             1237 ( 5)         rts
15BB-4F             1238 ( 1) .err00  clra                    ; "Syntax error"
15BC-7E 18 D4       1239 ( 3)         jmp     write_err_msg
15BF-86 16          1240 ( 2) .err22  ldaa    #22             ; "Subscript is out of range"
15C1-7E 18 D4       1241 ( 3)         jmp     write_err_msg
15C4-               1242
15C4-               1243
15C4-               1244      ; -----------------------------------------------------------------------
15C4-               1245      ; 式を評価して変数に値を代入する
15C4-               1246      ; Evaluate an expression and assign a value to a variable
15C4-               1247      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
15C4-               1248      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
15C4-               1249      ;【返値】D:Integer X:次の実行位置アドレス
15C4-               1250      ; -----------------------------------------------------------------------
15C4-               1251      assign_to_var:
15C4-BD 15 74       1252 ( 6)         jsr     skip_space
15C7-BD 11 ED       1253 ( 6)         jsr     eval_expression
15CA-24 07          1254 ( 3)         bcc     :err04
15CC-3C             1255 ( 5)         pshx                    ; 実行位置アドレスを退避
15CD-DE 8B          1256 ( 4)         ldx     <VariableAddr
15CF-ED 00          1257 ( 5)         std     0,x             ; 変数に結果を保存
15D1-38             1258 ( 4)         pulx                    ; 実行位置アドレスを復帰
15D2-39             1259 ( 5)         rts
15D3-86 04          1260 ( 2) .err04  ldaa    #4              ; "Illegal expression"
15D5-7E 18 D4       1261 ( 3)         jmp     write_err_msg
15D8-               1262
15D8-               1263
15D8-               1264      ; -----------------------------------------------------------------------
15D8-               1265      ; 同じ行番号を検索する
15D8-               1266      ; Scan equal line number
15D8-               1267      ;【引数】LineNumber:検索対象の行番号 X:検索を開始する行頭アドレス
15D8-               1268      ;【使用】A, B, X
15D8-               1269      ;【返値】真(C=1) / D:行番号 X:その行の開始アドレス
15D8-               1270      ;        偽(C=0) / D:次に大きな行番号 X:次に大きな行の開始アドレス
15D8-               1271      ;                  またはD:$0000 X:プログラム終了アドレス
15D8-               1272      ; -----------------------------------------------------------------------
15D8-               1273      scan_line_num:
15D8-EC 00          1274 ( 5) .loop   ldd     0,x             ; D:行番号
15DA-27 0F          1275 ( 3)         beq     :false          ; プログラム終端まで来たので偽
15DC-18             1276 ( 2)         xgdx
15DD-9C 96          1277 ( 4)         cpx     <LineNumber
15DF-18             1278 ( 2)         xgdx
15E0-27 07          1279 ( 3)         beq     :true           ; 同一の行番号が見つかったので真
15E2-2E 07          1280 ( 3)         bgt     :false          ; 対象の行番号より大きくなったので偽
15E4-E6 02          1281 ( 4)         ldab    2,x
15E6-3A             1282 ( 1)         abx
15E7-20 EF          1283 ( 3)         bra     :loop
15E9-0D             1284 ( 1) .true   sec
15EA-39             1285 ( 5)         rts
15EB-0C             1286 ( 1) .false  clc
15EC-39             1287 ( 5)         rts
15ED-               1288
15ED-               1289
15ED-               1290      ; -----------------------------------------------------------------------
15ED-               1291      ; runコマンドを実行する
15ED-               1292      ; Execute 'run' command
15ED-               1293      ;【引数】なし
15ED-               1294      ;【使用】A, B, X
15ED-               1295      ;【返値】なし
15ED-               1296      ; -----------------------------------------------------------------------
15ED-               1297      exe_run:
15ED-               1298            ; // 乱数のSeed値の設定
15ED-DC 09          1299 ( 4) .seed   ldd     <FRC            ; Free run timer 読み出し
15EF-27 FC          1300 ( 3)         beq     :seed           ; Seedはゼロ以外
15F1-DD A7          1301 ( 4)         std     <RndNumber
15F3-               1302            ; // 変数領域の初期化
15F3-CE 02 C2       1303 ( 3)         ldx     #VARIABLE
15F6-4F             1304 ( 1)         clra
15F7-5F             1305 ( 1)         clrb
15F8-ED 00          1306 ( 5) .1      std     0,x
15FA-08             1307 ( 1)         inx
15FB-08             1308 ( 1)         inx
15FC-8C 02 F6       1309 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
15FF-26 F7          1310 ( 3)         bne     :1
1601-7F 00 9C       1311 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
1604-CE 04 00       1312 ( 3)         ldx     #USER_AREA_TOP
1607-DF 9D          1313 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
1609-EC 00          1314 ( 5)         ldd     0,x
160B-27 08          1315 ( 3)         beq     :end            ; 行番号が$0000なら終了
160D-08             1316 ( 1)         inx
160E-08             1317 ( 1)         inx
160F-08             1318 ( 1)         inx
1610-BD 11 8B       1319 ( 6)         jsr     exe_line        ; 一行実行
1613-20 F2          1320 ( 3)         bra     :loop
1615-7E 10 2B       1321 ( 3) .end    jmp     warm_start
1618-               1322
1618-               1323
1618-               1324      ; -----------------------------------------------------------------------
1618-               1325      ; listコマンドを実行する
1618-               1326      ; Execute 'list' command
1618-               1327      ;【引数】なし
1618-               1328      ;【使用】A, B, X
1618-               1329      ;【返値】なし
1618-               1330      ; -----------------------------------------------------------------------
1618-               1331      exe_list:
1618-CE 04 00       1332 ( 3)         ldx     #USER_AREA_TOP
161B-               1333            ; // 行番号出力
161B-EC 00          1334 ( 5) .loop   ldd     0,x
161D-27 11          1335 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
161F-3C             1336 ( 5)         pshx
1620-BD 15 16       1337 ( 6)         jsr     write_integer
1623-38             1338 ( 4)         pulx
1624-               1339            ; // 本文出力
1624-08             1340 ( 1)         inx                     ; 本文までスキップ
1625-08             1341 ( 1)         inx
1626-08             1342 ( 1)         inx
1627-BD FF AF       1343 ( 6)         jsr     write_line
162A-BD FF B2       1344 ( 6)         jsr     write_crlf
162D-08             1345 ( 1)         inx                     ; 次の行番号へ
162E-20 EB          1346 ( 3)         bra     :loop
1630-7E 10 35       1347 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1633-               1348
1633-               1349
1633-               1350      ; -----------------------------------------------------------------------
1633-               1351      ; Print文を実行する
1633-               1352      ; Execute 'print' statement
1633-               1353      ;【引数】X:実行位置アドレス
1633-               1354      ;【使用】B, X（下位ルーチンでA）
1633-               1355      ;【返値】なし
1633-               1356      ; -----------------------------------------------------------------------
1633-               1357      exe_print:
1633-72 01 8F       1358 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1636-BD 15 74       1359 ( 6) .loop   jsr     skip_space
1639-27 37          1360 ( 3)         beq     :finish         ; 終端文字なら改行して終了
163B-BD 15 80       1361 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
163E-25 1B          1362 ( 3)         bcs     :nlon
1640-BD 11 ED       1363 ( 6)         jsr     eval_expression
1643-25 11          1364 ( 3)         bcs     :int
1645-               1365            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
1645-               1366            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
1645-C1 3B          1367 ( 2) .check  cmpb    #';'
1647-27 23          1368 ( 3)         beq     :nloff
1649-C1 2C          1369 ( 2)         cmpb    #','
164B-27 1C          1370 ( 3)         beq     :tab
164D-C1 3A          1371 ( 2)         cmpb    #':'
164F-27 21          1372 ( 3)         beq     :finish
1651-86 04          1373 ( 2)         ldaa    #4              ; "Illegal expression"
1653-7E 18 D4       1374 ( 3)         jmp     write_err_msg
1656-3C             1375 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1657-BD 15 16       1376 ( 6)         jsr     write_integer   ; 評価した式を出力
165A-38             1377 ( 4)         pulx                    ; 実行位置アドレスを復帰
165B-72 01 8F       1378 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
165E-BD 15 74       1379 ( 6)         jsr     skip_space
1661-C1 3B          1380 ( 2)         cmpb    #';'
1663-27 07          1381 ( 3)         beq     :nloff
1665-C1 2C          1382 ( 2)         cmpb    #','
1667-26 09          1383 ( 3)         bne     :finish
1669-BD 15 A8       1384 ( 6) .tab    jsr     write_tab       ; タブ出力
166C-7F 00 8F       1385 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
166F-08             1386 ( 1)         inx                     ; 次の文字へ
1670-20 C4          1387 ( 3)         bra     :loop
1672-7D 00 8F       1388 ( 4) .finish tst     <NewLineFlag
1675-27 03          1389 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1677-BD FF B2       1390 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
167A-7E 11 6B       1391 ( 3) .end    jmp     is_multi
167D-               1392
167D-               1393
167D-               1394      ; -----------------------------------------------------------------------
167D-               1395      ; input文を実行する
167D-               1396      ; Execute 'input' statement
167D-               1397      ; -----------------------------------------------------------------------
167D-               1398      exe_input:
167D-BD 15 74       1399 ( 6)         jsr     skip_space
1680-27 31          1400 ( 3)         beq     :end            ; 終端文字なら改行して終了
1682-BD 15 80       1401 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1685-24 0A          1402 ( 3)         bcc     :1
1687-E6 00          1403 ( 4)         ldab    0,x
1689-C1 3B          1404 ( 2)         cmpb    #';'
168B-26 29          1405 ( 3)         bne     :err00
168D-08             1406 ( 1)         inx
168E-BD 15 74       1407 ( 6)         jsr     skip_space
1691-BD 15 5F       1408 ( 6) .1      jsr     is_variable
1694-24 20          1409 ( 3)         bcc     :err00
1696-86 02          1410 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1698-58             1411 ( 1)         aslb                    ; B = 変数領域の下位バイト
1699-DD 8B          1412 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
169B-               1413            ; // 変数の後に余計な文字がないか確認
169B-               1414            ; // 例えば "input a+b" など
169B-DF 8D          1415 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
169D-BD 15 74       1416 ( 6)         jsr     skip_space
16A0-27 06          1417 ( 3)         beq     :read           ; 終端文字なら入力へ
16A2-C1 3A          1418 ( 2)         cmpb    #':'            ; ":"なら入力へ
16A4-26 10          1419 ( 3)         bne     :err00          ; それ以外の文字ならエラー
16A6-DE 8D          1420 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16A8-BD FF A9       1421 ( 6) .read   jsr     read_line
16AB-CE 01 40       1422 ( 3)         ldx     #TEXT_BFFR
16AE-BD 15 C4       1423 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
16B1-DE 8D          1424 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
16B3-7E 11 6B       1425 ( 3) .end    jmp     is_multi
16B6-4F             1426 ( 1) .err00  clra                    ; "Syntax error"
16B7-7E 18 D4       1427 ( 3)         jmp     write_err_msg
16BA-               1428
16BA-               1429
16BA-               1430      ; -----------------------------------------------------------------------
16BA-               1431      ; if文を実行する
16BA-               1432      ; Execute 'if' statement
16BA-               1433      ;【引数】X:実行位置アドレス
16BA-               1434      ;【使用】B, X
16BA-               1435      ;【返値】なし
16BA-               1436      ; -----------------------------------------------------------------------
16BA-BD 15 74       1437 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
16BD-27 0B          1438 ( 3)         beq     :end            ; 終端文字なら終了
16BF-BD 11 ED       1439 ( 6)         jsr     eval_expression ; 式評価
16C2-24 09          1440 ( 3)         bcc     :err04
16C4-5D             1441 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
16C5-27 03          1442 ( 3)         beq     :end
16C7-7E 11 8B       1443 ( 3)         jmp     exe_line        ; True
16CA-7E 11 7B       1444 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
16CD-86 04          1445 ( 2) .err04  ldaa    #4              ; "Illegal expression"
16CF-7E 18 D4       1446 ( 3)         jmp     write_err_msg
16D2-               1447
16D2-               1448
16D2-               1449      ; -----------------------------------------------------------------------
16D2-               1450      ; gosub文を実行する
16D2-               1451      ; Execute 'gosub' statement
16D2-               1452      ;【引数】X:実行位置アドレス
16D2-               1453      ;【使用】A, B, X
16D2-               1454      ;【返値】なし
16D2-               1455      ; -----------------------------------------------------------------------
16D2-               1456      exe_gosub:
16D2-72 01 A0       1457 ( 6)         oim     #1,<ToSubFlag   ; 分岐モードを1 = gosubにする
16D5-               1458              ; そのままexe_gotoに続く
16D5-               1459
16D5-               1460
16D5-               1461      ; -----------------------------------------------------------------------
16D5-               1462      ; goto文を実行する
16D5-               1463      ; Execute 'goto' statement
16D5-               1464      ;【引数】X:実行位置アドレス
16D5-               1465      ;【使用】A, B, X
16D5-               1466      ;【返値】なし
16D5-               1467      ; -----------------------------------------------------------------------
16D5-               1468      exe_goto:
16D5-BD 15 74       1469 ( 6)         jsr     skip_space      ; 空白を読み飛ばし
16D8-27 3F          1470 ( 3)         beq     :err00          ; 終端文字"Syntax error"
16DA-BD 11 ED       1471 ( 6)         jsr     eval_expression ; 式評価
16DD-24 3E          1472 ( 3)         bcc     :err04          ; "Illegal expression"
16DF-2B 41          1473 ( 3)         bmi     :err12          ; "Invalid line number"
16E1-DD 96          1474 ( 4)         std     <LineNumber     ; 飛び先になる行番号を一時保存
16E3-7D 00 A0       1475 ( 4)         tst     ToSubFlag
16E6-27 17          1476 ( 3)         beq     :to             ; 分岐モードが0=gotoなら:toへ
16E8-18             1477 ( 2)         xgdx                    ; D = ExePointer
16E9-DE A1          1478 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
16EB-8C 02 28       1479 ( 3)         cpx     #SSTACK         ; 既にスタック最上位か？
16EE-27 3C          1480 ( 3)         beq     :err18          ; Yes. "Subroutine stack overflow"
16F0-09             1481 ( 1)         dex
16F1-09             1482 ( 1)         dex
16F2-ED 00          1483 ( 5)         std     0,x             ; ExePointerをスタックに積む
16F4-DC 9D          1484 ( 4)         ldd     <ExeLineAddr
16F6-09             1485 ( 1)         dex
16F7-09             1486 ( 1)         dex
16F8-ED 00          1487 ( 5)         std     0,x             ; ExeLineAddrをスタックに積む
16FA-DF A1          1488 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
16FC-7F 00 A0       1489 ( 5)         clr     ToSubFlag       ; 分岐モードを0 = gotoに戻す
16FF-DE 9D          1490 ( 4) .to     ldx     <ExeLineAddr    ; X <- 実行中の行の先頭アドレス
1701-EC 00          1491 ( 5)         ldd     0,x             ; 今実行している行の行番号を取得
1703-18             1492 ( 2)         xgdx
1704-9C 96          1493 ( 4)         cpx     <LineNumber     ; 現在の行番号と飛び先の行番号を比較
1706-18             1494 ( 2)         xgdx
1707-25 03          1495 ( 3)         bcs     :1              ; 現在の行番号 > 飛び先の行番号 = ここから検索
1709-CE 04 00       1496 ( 3)         ldx     #USER_AREA_TOP  ; 現在の行番号 < 飛び先の行番号 = 先頭から検索
170C-BD 15 D8       1497 ( 6) .1      jsr     scan_line_num   ; 同じ行番号を探す
170F-24 16          1498 ( 3)         bcc     :err16          ; "Undefined line number"
1711-DF 9D          1499 ( 4)         stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
1713-08             1500 ( 1)         inx
1714-08             1501 ( 1)         inx
1715-08             1502 ( 1)         inx
1716-7E 11 8B       1503 ( 3)         jmp     exe_line
1719-               1504
1719-4F             1505 ( 1) .err00  clra                    ; "Syntax error"
171A-7E 18 D4       1506 ( 3)         jmp     write_err_msg
171D-86 04          1507 ( 2) .err04  ldaa    #4              ; "Illegal expression"
171F-7E 18 D4       1508 ( 3)         jmp     write_err_msg
1722-86 0C          1509 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1724-7E 18 D4       1510 ( 3)         jmp     write_err_msg
1727-86 10          1511 ( 2) .err16  ldaa    #16             ; "Undefined line number"
1729-7E 18 D4       1512 ( 3)         jmp     write_err_msg
172C-86 12          1513 ( 2) .err18  ldaa    #18             ; "Subroutine stack overflow"
172E-7E 18 D4       1514 ( 3)         jmp     write_err_msg
1731-               1515
1731-               1516
1731-               1517      ; -----------------------------------------------------------------------
1731-               1518      ; return文を実行する
1731-               1519      ; Execute 'return' statement
1731-               1520      ;【引数】X:実行位置アドレス
1731-               1521      ;【使用】A, B, X
1731-               1522      ;【返値】なし
1731-               1523      ; -----------------------------------------------------------------------
1731-               1524      exe_return:
1731-DE A1          1525 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
1733-8C 02 50       1526 ( 3)         cpx     #SSTACK_BTM+1   ; 既にスタックの底か？
1736-27 10          1527 ( 3)         beq     :err20          ; Yes. "Return without gosub"
1738-EC 00          1528 ( 5)         ldd     0,x
173A-DD 9D          1529 ( 4)         std     <ExeLineAddr    ; ExeLineAddrをスタックから復帰
173C-08             1530 ( 1)         inx
173D-08             1531 ( 1)         inx
173E-EC 00          1532 ( 5)         ldd     0,x             ; D = ExePointer
1740-08             1533 ( 1)         inx
1741-08             1534 ( 1)         inx
1742-DF A1          1535 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
1744-18             1536 ( 2)         xgdx                    ; X = ExePointer
1745-7E 11 6B       1537 ( 3)         jmp     is_multi
1748-               1538
1748-86 14          1539 ( 2) .err20  ldaa    #20             ; "Return without gosub"
174A-7E 18 D4       1540 ( 3)         jmp     write_err_msg
174D-               1541
174D-               1542
174D-               1543      ; -----------------------------------------------------------------------
174D-               1544      ; trunc文を実行する
174D-               1545      ; Execute 'trunc' statement
174D-               1546      ;【引数】X:実行位置アドレス
174D-               1547      ;【使用】B, X
174D-               1548      ;【返値】なし
174D-               1549      ; -----------------------------------------------------------------------
174D-               1550      exe_trunc:
174D-7F 00 9F       1551 ( 5)         clr     <ModuloMode     ; tranc = 0 にする
1750-7E 11 6B       1552 ( 3)         jmp     is_multi
1753-               1553
1753-               1554
1753-               1555      ; -----------------------------------------------------------------------
1753-               1556      ; floor文を実行する
1753-               1557      ; Execute 'trunc' statement
1753-               1558      ;【引数】X:実行位置アドレス
1753-               1559      ;【使用】B, X
1753-               1560      ;【返値】なし
1753-               1561      ; -----------------------------------------------------------------------
1753-               1562      exe_floor:
1753-72 01 9F       1563 ( 6)         oim     #1,<ModuloMode  ; floor = 1以上 にする
1756-7E 11 6B       1564 ( 3)         jmp     is_multi
1759-               1565
1759-               1566
1759-               1567      ; -----------------------------------------------------------------------
1759-               1568      ; rnd関数を実行する
1759-               1569      ; Execute 'rnd' function
1759-               1570      ;【引数】X:実行位置アドレス
1759-               1571      ;【使用】A, B, X
1759-               1572      ;【返値】D:乱数値 X:次の実行位置アドレス
1759-               1573      ; -----------------------------------------------------------------------
1759-               1574      exe_rnd:
1759-               1575            ; // xorshiftで乱数生成
1759-D6 A7          1576 ( 3)         ldab    <RndNumber
175B-54             1577 ( 1)         lsrb
175C-D6 A8          1578 ( 3)         ldab    <RndNumber+1
175E-56             1579 ( 1)         rorb
175F-D8 A7          1580 ( 3)         eorb    <RndNumber
1761-D7 A7          1581 ( 3)         stab    <RndNumber
1763-56             1582 ( 1)         rorb
1764-D8 A8          1583 ( 3)         eorb    <RndNumber+1
1766-D7 A8          1584 ( 3)         stab    <RndNumber+1
1768-17             1585 ( 1)         tba
1769-98 A7          1586 ( 3)         eora    <RndNumber
176B-97 A7          1587 ( 3)         staa    <RndNumber
176D-84 7F          1588 ( 2)         anda    #$7f            ; 生成される乱数は0〜32,767となる
176F-BD 13 00       1589 ( 6)         jsr     expr_1st:push   ; 乱数を計算スタックにプッシュ
1772-BD 12 03       1590 ( 6)         jsr     expr_4th        ; 引数を取得する
1775-               1591            ; // ')'の確認
1775-C1 29          1592 ( 2)         cmpb    #')'
1777-26 1D          1593 ( 3)         bne     :err00
1779-3C             1594 ( 5)         pshx                    ; 実行位置アドレスを退避
177A-               1595            ; // 計算スタックの引数を+1する
177A-DE 82          1596 ( 4)         ldx     <CStackPtr
177C-EC 00          1597 ( 5)         ldd     0,x
177E-2F 1A          1598 ( 3)         ble     :err02          ; 引数が正の実数でなければ"Out of range"
1780-C3 00 01       1599 ( 3)         addd    #1
1783-ED 00          1600 ( 5)         std     0,x
1785-DF 82          1601 ( 4)         stx     <CStackPtr
1787-               1602            ; // rnd(32768)の場合、生成された乱数を32768+1つまり-32768で割らないといけない
1787-               1603            ; // 結果を正の数とするために一時的にtruncモードにする
1787-D6 9F          1604 ( 3)         ldab    <ModuloMode     ; 剰余演算フラグを保存
1789-37             1605 ( 4)         pshb
178A-7F 00 9F       1606 ( 5)         clr     ModuloMode      ; 剰余演算フラグをtrancにする
178D-BD 13 70       1607 ( 6)         jsr     CS_mod          ; 乱数 / (引数 + 1)
1790-33             1608 ( 3)         pulb                    ; 剰余演算フラグを復帰
1791-D7 9F          1609 ( 3)         stab    <ModuloMode
1793-38             1610 ( 4)         pulx                    ; 実行位置アドレスを復帰
1794-08             1611 ( 1)         inx                     ; 次の実行位置アドレスに
1795-39             1612 ( 5)         rts                     ; expr_2ndの2行目に戻る
1796-4F             1613 ( 1) .err00  clra                    ; "Syntax error"
1797-7E 18 D4       1614 ( 3)         jmp     write_err_msg
179A-86 02          1615 ( 2) .err02  ldaa    #2              ; "Out of range"
179C-7E 18 D4       1616 ( 3)         jmp     write_err_msg
179F-               1617
179F-               1618
179F-               1619      ; ------------------------------------------------
179F-               1620      ; ブロック転送
179F-               1621      ; Move memory
179F-               1622      ;【引数】Source:転送元アドレス
179F-               1623      ;        Destination:転送先アドレス
179F-               1624      ;        Bytes:転送バイト数
179F-               1625      ;【使用】A, B, X, UR0
179F-               1626      ;【返値】なし
179F-               1627      ; ------------------------------------------------
179F-               1628      mem_move:
179F-DC 94          1629 ( 4)         ldd     <Bytes
17A1-27 0A          1630 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
17A3-DC 90          1631 ( 4)         ldd     <Source
17A5-93 92          1632 ( 4)         subd    <Destination    ; Source - Destination
17A7-27 04          1633 ( 3)         beq     :end            ; 転送元と転送先が同じなら即終了
17A9-24 03          1634 ( 3)         bcc     LDIR            ; Source > Destination
17AB-20 31          1635 ( 3)         bra     LDDR            ; Source < Destination
17AD-39             1636 ( 5) .end    rts
17AE-               1637
17AE-               1638      ; ------------------------------------------------
17AE-               1639      ; 前方から転送（LDIR）
17AE-               1640      ; Load, Increment and Repeat
17AE-               1641      ;【引数】Source:転送元アドレス
17AE-               1642      ;        Destination:転送先アドレス
17AE-               1643      ;        Bytes:転送バイト数
17AE-               1644      ;【使用】A, B, X, UR0
17AE-               1645      ;【返値】なし
17AE-               1646      ; ------------------------------------------------
17AE-               1647      LDIR:
00A9-               1648      .Offset .eq     UR0
17AE-               1649             ; // オフセットの計算。既にDレジスタに入っている
17AE-DD A9          1650 ( 4)        std     <:Offset        ; Offset = Source - Destination
17B0-               1651            ; // 終了判定用のアドレスを計算
17B0-DC 90          1652 ( 4)         ldd     <Source         ; 転送終了アドレス = Source - Bytes
17B2-D3 94          1653 ( 4)         addd    <Bytes
17B4-DD 92          1654 ( 4)         std     <Destination    ; 転送終了アドレスをDestinationに代入
17B6-               1655            ; // 転送開始
17B6-DE 90          1656 ( 4)         ldx     <Source         ; 転送開始アドレスをXに代入
17B8-               1657            ; // 転送するバイト数が奇数か偶数か判断。
17B8-               1658            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
17B8-DC 94          1659 ( 4)         ldd     <Bytes
17BA-04             1660 ( 1)         lsrd                    ; 転送バイト数 / 2, 奇数ならC=1
17BB-24 0E          1661 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
17BD-               1662            ; // Byte転送
17BD-A6 00          1663 ( 4)         ldaa    0,x             ; A <- [Source]
17BF-18             1664 ( 2)         xgdx                    ; D = address, X = data
17C0-93 A9          1665 ( 4)         subd    <:Offset        ; Source - Offset = Destination
17C2-18             1666 ( 2)         xgdx                    ; D = data, X = address
17C3-A7 00          1667 ( 4)         staa    0,x             ; [Destination] <- A
17C5-18             1668 ( 2)         xgdx                    ; D = address, X = data
17C6-D3 A9          1669 ( 4)         addd    <:Offset        ; Destination + Offset = Source
17C8-18             1670 ( 2)         xgdx                    ; D = data, X = address
17C9-20 0D          1671 ( 3)         bra     :odd            ; 飛び先でinx
17CB-               1672            ; // Word転送
17CB-EC 00          1673 ( 5) .loop   ldd     0,x
17CD-18             1674 ( 2)         xgdx
17CE-93 A9          1675 ( 4)         subd    <:Offset
17D0-18             1676 ( 2)         xgdx
17D1-ED 00          1677 ( 5)         std     0,x
17D3-18             1678 ( 2)         xgdx
17D4-D3 A9          1679 ( 4)         addd    <:Offset
17D6-18             1680 ( 2)         xgdx
17D7-08             1681 ( 1)         inx
17D8-08             1682 ( 1) .odd    inx
17D9-9C 92          1683 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
17DB-26 EE          1684 ( 3)         bne     :loop
17DD-39             1685 ( 5)         rts
17DE-               1686
17DE-               1687      ; ------------------------------------------------
17DE-               1688      ; 後方から転送（LDDR）
17DE-               1689      ; Load, Decrement and Repeat
17DE-               1690      ;【引数】Source:転送元アドレス
17DE-               1691      ;        Destination:転送先アドレス
17DE-               1692      ;        Bytes:転送バイト数
17DE-               1693      ;【使用】A, B, X, UR0
17DE-               1694      ;【返値】なし
17DE-               1695      ; ------------------------------------------------
17DE-               1696      LDDR:
00A9-               1697      .Offset .eq     UR0
17DE-               1698            ; // オフセットの計算
17DE-DC 92          1699 ( 4)         ldd     <Destination
17E0-93 90          1700 ( 4)         subd    <Source
17E2-DD A9          1701 ( 4)         std     <:Offset         ; Offset = Destination - Source
17E4-               1702            ; // 転送終了アドレスは既にDestinationに代入済み
17E4-               1703            ; // 転送開始アドレスの計算。一番後ろから
17E4-DC 90          1704 ( 4)         ldd     <Source         ; 転送開始アドレス = Source + Bytes
17E6-D3 94          1705 ( 4)         addd    <Bytes
17E8-18             1706 ( 2)         xgdx                    ; X = 転送開始アドレス
17E9-               1707            ; // 転送するバイト数が奇数か偶数か判断。
17E9-               1708            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
17E9-DC 94          1709 ( 4)         ldd     <Bytes
17EB-04             1710 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
17EC-24 0F          1711 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
17EE-               1712            ; // Byte転送
17EE-09             1713 ( 1)         dex
17EF-A6 00          1714 ( 4)         ldaa    0,x             ; A <- [Source]
17F1-18             1715 ( 2)         xgdx                    ; D = address, X = data
17F2-D3 A9          1716 ( 4)         addd    <:Offset        ; Source + Offset = Destination
17F4-18             1717 ( 2)         xgdx                    ; D = data, X = address
17F5-A7 00          1718 ( 4)         staa    0,x             ; [Destination] <- A
17F7-18             1719 ( 2)         xgdx                    ; D = address, X = data
17F8-93 A9          1720 ( 4)         subd    <:Offset        ; Destination - Offset = Source
17FA-18             1721 ( 2)         xgdx                    ; D = data, X = address
17FB-20 0E          1722 ( 3)         bra     :odd
17FD-               1723            ; // Word転送
17FD-09             1724 ( 1) .loop   dex
17FE-09             1725 ( 1)         dex
17FF-EC 00          1726 ( 5)         ldd     0,x
1801-18             1727 ( 2)         xgdx
1802-D3 A9          1728 ( 4)         addd    <:Offset
1804-18             1729 ( 2)         xgdx
1805-ED 00          1730 ( 5)         std     0,x
1807-18             1731 ( 2)         xgdx
1808-93 A9          1732 ( 4)         subd    <:Offset
180A-18             1733 ( 2)         xgdx
180B-9C 90          1734 ( 4) .odd    cpx     <Source         ; 転送終了アドレスと現在のアドレスを比較
180D-26 EE          1735 ( 3)         bne     :loop
180F-39             1736 ( 5)         rts
1810-               1737
1810-               1738
1810-               1739      ; -----------------------------------------------------------------------
1810-               1740      ; テーブル検索
1810-               1741      ; Search the keyword table
1810-               1742      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
1810-               1743      ;【使用】A, B, X
1810-               1744      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
1810-               1745      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
1810-               1746      ; -----------------------------------------------------------------------
1810-               1747      search_table:
1810-EC 05          1748 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
1812-91 B1          1749 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
1814-26 2F          1750 ( 3)         bne     :false
1816-D1 B2          1751 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
1818-26 2B          1752 ( 3)         bne     :false
181A-EC 07          1753 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
181C-4D             1754 ( 1)         tsta                    ; $00（終端記号）か？
181D-27 1B          1755 ( 3)         beq     :true
181F-91 B3          1756 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
1821-26 22          1757 ( 3)         bne     :false
1823-5D             1758 ( 1)         tstb                    ; $00（終端記号）か？
1824-27 14          1759 ( 3)         beq     :true
1826-D1 B4          1760 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
1828-26 1B          1761 ( 3)         bne     :false
182A-EC 09          1762 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
182C-4D             1763 ( 1)         tsta                    ; $00（終端記号）か？
182D-27 0B          1764 ( 3)         beq     :true
182F-91 B5          1765 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
1831-26 12          1766 ( 3)         bne     :false
1833-5D             1767 ( 1)         tstb                    ; $00（終端記号）か？
1834-27 04          1768 ( 3)         beq     :true
1836-D1 B6          1769 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
1838-26 0B          1770 ( 3)         bne     :false
183A-E6 02          1771 ( 4) .true   ldab    2,x             ; B = 語長
183C-EE 03          1772 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
183E-31             1773 ( 1)         ins                     ; 元のリターンアドレスを削除
183F-31             1774 ( 1)         ins
1840-3C             1775 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1841-DE 8D          1776 ( 4)         ldx     <ExePointer
1843-3A             1777 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1844-39             1778 ( 5)         rts                     ; 命令ルーチンにジャンプ
1845-EE 00          1779 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
1847-26 C7          1780 ( 3)         bne     :top
1849-DE 8D          1781 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
184B-0C             1782 ( 1)         clc                     ; false: C=0
184C-39             1783 ( 5)         rts
184D-               1784
184D-               1785
184D-               1786      ; ***********************************************************************
184D-               1787      ;   キーワードテーブル Keyword table
184D-               1788      ; ***********************************************************************
184D-               1789      ; レコードの構造 Record structure
184D-               1790      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
184D-               1791      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
184D-               1792      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
184D-               1793      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
184D-               1794      ; キーワードは2文字以上6文字以下
184D-               1795      CMD_TABLE
184D-18 56          1796      .run            .dw     :new
184F-03             1797                      .db     3
1850-15 ED          1798                      .dw     exe_run
1852-72 75 6E 00    1799                      .az     "run"
1856-18 5F          1800      .new            .dw     :list
1858-03             1801                      .db     3
1859-10 03          1802                      .dw     cold_start
185B-6E 65 77 00    1803                      .az     "new"
185F-18 69          1804      .list           .dw     SMT_TABLE:print
1861-04             1805                      .db     4
1862-16 18          1806                      .dw     exe_list
1864-6C 69 73 74 
     00             1807                      .az     "list"
1869-               1808      SMT_TABLE
1869-18 74          1809      .print          .dw     :input
186B-05             1810                      .db     5
186C-16 33          1811                      .dw     exe_print
186E-70 72 69 6E 
     74 00          1812                      .az     "print"
1874-18 7F          1813      .input          .dw     :if
1876-05             1814                      .db     5
1877-16 7D          1815                      .dw     exe_input
1879-69 6E 70 75 
     74 00          1816                      .az     "input"
187F-18 87          1817      .if             .dw     :goto
1881-02             1818                      .db     2
1882-16 BA          1819                      .dw     exe_if
1884-69 66 00       1820                      .az     "if"
1887-18 91          1821      .goto           .dw     :gosub
1889-04             1822                      .db     4
188A-16 D5          1823                      .dw     exe_goto
188C-67 6F 74 6F 
     00             1824                      .az     "goto"
1891-18 9C          1825      .gosub          .dw     :return
1893-05             1826                      .db     5
1894-16 D2          1827                      .dw     exe_gosub
1896-67 6F 73 75 
     62 00          1828                      .az     "gosub"
189C-18 A7          1829      .return         .dw     :end
189E-06             1830                      .db     6
189F-17 31          1831                      .dw     exe_return
18A1-72 65 74 75 
     72 6E          1832                      .as     "return"        ; 6文字なので終端不要。'.as'を使用する
18A7-18 B0          1833      .end            .dw     :trunc
18A9-03             1834                      .db     3
18AA-10 2B          1835                      .dw     warm_start
18AC-65 6E 64 00    1836                      .az     "end"
18B0-18 BB          1837      .trunc          .dw     :floor
18B2-05             1838                      .db     5
18B3-17 4D          1839                      .dw     exe_trunc
18B5-74 72 75 6E 
     63 00          1840                      .az     "trunc"
18BB-18 C6          1841      .floor          .dw     :bottom
18BD-05             1842                      .db     5
18BE-17 53          1843                      .dw     exe_floor
18C0-66 6C 6F 6F 
     72 00          1844                      .az     "floor"
18C6-00 00          1845      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18C8-               1846
18C8-               1847      FUNC_TABLE
18C8-18 D2          1848      .rnd            .dw     :bottom
18CA-04             1849                      .db     4
18CB-17 59          1850                      .dw     exe_rnd
18CD-72 6E 64 28 
     00             1851                      .az     "rnd("
18D2-00 00          1852      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
18D4-               1853
18D4-               1854
18D4-               1855      ; -----------------------------------------------------------------------
18D4-               1856      ; エラーメッセージを表示する
18D4-               1857      ; Write Error Messege
18D4-               1858      ;【引数】A: エラーコード
18D4-               1859      ;【使用】A, B, X
18D4-               1860      ;【返値】なし
18D4-               1861      ; -----------------------------------------------------------------------
18D4-               1862      write_err_msg:
18D4-7D 00 39       1863 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
18D7-27 03          1864 ( 3)         beq     :1
18D9-BD FF B2       1865 ( 6)         jsr     write_crlf
18DC-CE 19 07       1866 ( 3) .1      ldx     #ERRMSG1
18DF-BD FF AF       1867 ( 6)         jsr     write_line
18E2-16             1868 ( 1)         tab
18E3-CE 19 13       1869 ( 3)         ldx     #ERRCODE
18E6-3A             1870 ( 1)         abx
18E7-EE 00          1871 ( 5)         ldx     0,x
18E9-BD FF AF       1872 ( 6)         jsr     write_line
18EC-7D 00 9C       1873 ( 4)         tst     ExeStateFlag    ; 実行モードか？
18EF-26 0D          1874 ( 3)         bne     :2              ; No. 行番号を表示せずにスキップ
18F1-CE 19 0E       1875 ( 3)         ldx     #ERRMSG2        ; Yes. 行番号を表示する
18F4-BD FF AF       1876 ( 6)         jsr     write_line
18F7-DE 9D          1877 ( 4)         ldx     <ExeLineAddr
18F9-EC 00          1878 ( 5)         ldd     0,x
18FB-BD 15 16       1879 ( 6)         jsr     write_integer
18FE-BD FF B2       1880 ( 6) .2      jsr     write_crlf
1901-DE 80          1881 ( 4)         ldx     <StackPointer
1903-35             1882 ( 1)         txs
1904-7E 10 2B       1883 ( 3)         jmp     warm_start
1907-               1884
1907-4F 6F 70 73 
     21 20 00       1885      ERRMSG1 .az     "Oops! "
190E-20 69 6E 20 
     00             1886      ERRMSG2 .az     " in "
1913-19 2B          1887      ERRCODE .dw     .err00
1915-19 38          1888              .dw     .err02
1917-19 4B          1889              .dw     .err04
1919-19 5E          1890              .dw     .err06
191B-19 77          1891              .dw     .err08
191D-19 83          1892              .dw     .err10
191F-19 99          1893              .dw     .err12
1921-19 AD          1894              .dw     .err14
1923-19 BE          1895              .dw     .err16
1925-19 D4          1896              .dw     .err18
1927-19 EE          1897              .dw     .err20
1929-1A 03          1898              .dw     .err22
192B-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1899      .err00  .az     "Syntax error"
1938-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1900      .err02  .az     "Out of range value"
194B-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1901      .err04  .az     "Illegal expression"
195E-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1902      .err06  .az     "Calculate stack overflow"
1977-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1903      .err08  .az     "Zero Divide"
1983-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1904      .err10  .az     "Print statement error"
1999-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1905      .err12  .az     "Invalid line number"
19AD-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1906      .err14  .az     "Memory size over"
19BE-55 6E 64 65 
     66 69 6E 65 
     64 20 6C 69 
     6E 65 20 6E 
     75 6D 62 65 
     72 00          1907      .err16  .az     "Undefined line number"
19D4-53 75 62 72 
     6F 75 74 69 
     6E 65 20 73 
     74 61 63 6B 
     20 6F 76 65 
     72 66 6C 6F 
     77 00          1908      .err18  .az     "Subroutine stack overflow"
19EE-52 65 74 75 
     72 6E 20 77 
     69 74 68 6F 
     75 74 20 67 
     6F 73 75 62 
     00             1909      .err20  .az     "Return without gosub"
1A03-53 75 62 73 
     63 72 69 70 
     74 20 69 73 
     20 6F 75 74 
     20 6F 66 20 
     72 61 6E 67 
     65 00          1910      .err22  .az     "Subscript is out of range"
1A1D-               1911
1A1D-               1912
1A1D-               1913      ; ***********************************************************************
1A1D-               1914      ;   デバック用ルーチン Debugging routines
1A1D-               1915      ; ***********************************************************************
1A1D-               1916      ; -----------------------------------------------------------------------
1A1D-               1917      ; ユーザーレジスタを表示する
1A1D-               1918      ; Display user registers
1A1D-               1919      ; -----------------------------------------------------------------------
1A1D-36             1920 ( 4) PUTUR:  psha
1A1E-37             1921 ( 4)         pshb
1A1F-3C             1922 ( 5)         pshx
1A20-CE 1A 53       1923 ( 3)         ldx     #:MSGUR0
1A23-BD FF AF       1924 ( 6)         jsr     write_line
1A26-DC A9          1925 ( 4)         ldd     <UR0
1A28-BD FF BB       1926 ( 6)         jsr     write_word
1A2B-CE 1A 58       1927 ( 3)         ldx     #:MSGUR1
1A2E-BD FF AF       1928 ( 6)         jsr     write_line
1A31-DC AB          1929 ( 4)         ldd     <UR1
1A33-BD FF BB       1930 ( 6)         jsr     write_word
1A36-CE 1A 5E       1931 ( 3)         ldx     #:MSGUR2
1A39-BD FF AF       1932 ( 6)         jsr     write_line
1A3C-DC AD          1933 ( 4)         ldd     <UR2
1A3E-BD FF BB       1934 ( 6)         jsr     write_word
1A41-CE 1A 64       1935 ( 3)         ldx     #:MSGUR3
1A44-BD FF AF       1936 ( 6)         jsr     write_line
1A47-DC AF          1937 ( 4)         ldd     <UR3
1A49-BD FF BB       1938 ( 6)         jsr     write_word
1A4C-BD FF B2       1939 ( 6)         jsr     write_crlf
1A4F-38             1940 ( 4)         pulx
1A50-33             1941 ( 3)         pulb
1A51-32             1942 ( 3)         pula
1A52-39             1943 ( 5)         rts
1A53-55 52 30 3D 
     00             1944      .MSGUR0          .az     "UR0="
1A58-20 55 52 31 
     3D 00          1945      .MSGUR1          .az     " UR1="
1A5E-20 55 52 32 
     3D 00          1946      .MSGUR2          .az     " UR2="
1A64-20 55 52 33 
     3D 00          1947      .MSGUR3          .az     " UR3="
