0000-                 14
0000-                 15      ; ********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0000-                 46
0020-                 47      RAM_START       .eq     $0020
1FFF-                 48      RAM_END         .eq     $1fff
E000-                 49      ROM_START       .eq     $e000
FFFF-                 50      ROM_END         .eq     $ffff
0FFF-                 51      STACK           .eq     $0fff
0000-                 52
1000-                 53      PROGRAM_START   .eq     $1000
0100-                 54      Rx_BUFFER       .eq     $0100   ; SCI Rx Buffer ($0100-0148,73byte)
0148-                 55      Rx_BUFFER_END   .eq     $0148   ; 73byte（72character）
0149-                 56      CSTACK          .eq     $0149   ; 計算スタック (Calculate stack, 40byte)
01C2-                 57      VARIABLE        .eq     $01c2   ; 変数26文字 ($01c2-01f5, 52byte)
0400-                 58      USERAREATOP     .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 59      USERAREABTM     .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 60
0000-                 61      ; ***********************************************************************
0000-                 62      ;   システム変数 System variables
0000-                 63      ; ***********************************************************************
0000-                 64              .sm     RAM
0020-                 65              .or     $20
0020-                 66
0020-                 67      ; Interrupt Vector Hooking
0020-                 68      VEC_TRAP        .bs     3
0023-                 69      VEC_SCI         .bs     3
0026-                 70      VEC_TOF         .bs     3
0029-                 71      VEC_OCF         .bs     3
002C-                 72      VEC_ICF         .bs     3
002F-                 73      VEC_IRQ         .bs     3
0032-                 74      VEC_SWI         .bs     3
0035-                 75      VEC_NMI         .bs     3
0038-                 76      BreakPointFlag  .bs     1
0039-                 77      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 78      ; General-Purpose Registers
003A-                 79      R0              .bs     2
003C-                 80      R1              .bs     2
003E-                 81
003E-                 82      ; ***********************************************************************
003E-                 83      ;   変数 Variables
003E-                 84      ; ***********************************************************************
003E-                 85              .sm     RAM
0080-                 86              .or     $80
0080-                 87
0080-                 88      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                 89      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                 90      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                 91      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                 92      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                 93      Divisor         .bs     2       ; 除数
0089-                 94      Remainder       .bs     2       ; 剰余
008B-                 95      VariableAddr    .bs     2       ; 変数のアドレス
008D-                 96      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                 97      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                 98      Source          .bs     2       ; 転送元アドレス
0092-                 99      Destination     .bs     2       ; 転送先アドレス
0094-                100      Bytes           .bs     2       ; 転送バイト数
0096-                101      LineNumber      .bs     2       ; 行番号
0098-                102      LineLength      .bs     2       ; 行の長さ
009A-                103      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                104      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                105
009D-                106      ; General-Purpose Registers
009D-                107      UR0             *
009D-                108      UR0H            .bs     1
009E-                109      UR0L            .bs     1
009F-                110      UR1             *
009F-                111      UR1H            .bs     1
00A0-                112      UR1L            .bs     1
00A1-                113      UR2             *
00A1-                114      UR2H            .bs     1
00A2-                115      UR2L            .bs     1
00A3-                116      UR3             *
00A3-                117      UR3H            .bs     1
00A4-                118      UR3L            .bs     1
00A5-                119      ; Work area
00A5-                120      COMPARE         .bs     6       ; 文字列比較用バッファ
00AB-                121
00AB-                122      ; ***********************************************************************
00AB-                123      ;   Program Start
00AB-                124      ; ***********************************************************************
0000-                125              .sm     CODE
1000-                126              .or     PROGRAM_START
1000-                127
1000-                128      init_tinybasic:
1000-30              129 ( 1)         tsx
1001-DF 80           130 ( 4)         stx     <StackPointer
1003-                131
1003-                132
1003-                133      cold_start:
1003-CE 04 00        134 ( 3)         ldx     #USERAREATOP
1006-DF 9A           135 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              136 ( 1)         clra
1009-5F              137 ( 1)         clrb
100A-ED 00           138 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           139 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                140
100E-                141
100E-                142      tb_main:
100E-72 01 9C        143 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
1011-C6 3E           144 ( 2)         ldab    #'>'
1013-BD FF AC        145 ( 6)         jsr     write_char
1016-BD FF A9        146 ( 6)         jsr     read_line
1019-CE 01 00        147 ( 3)         ldx     #Rx_BUFFER      ; 実行位置アドレスをセット
101C-                148            ; // 行番号判定
101C-BD 12 C7        149 ( 6)         jsr     get_int_from_decimal
101F-24 0A           150 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
1021-83 00 00        151 ( 3)         subd    #0
1024-2E 08           152 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
1026-86 0C           153 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1028-7E 15 3A        154 ( 3)         jmp     write_err_msg
102B-                155
102B-                156      execute_mode:
102B-7E 10 87        157 ( 3)         jmp     exe_line
102E-                158
102E-                159      edit_mode:
102E-DF 8D           160 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1030-DD 96           161 ( 4)         std     <LineNumber     ; 行番号を保存
1032-                162            ; // 行の長さを取得
1032-86 04           163 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
1034-E6 00           164 ( 4) .loop   ldab    0,x
1036-27 04           165 ( 3)         beq     :1
1038-4C              166 ( 1)         inca                    ; 行の長さを+1
1039-08              167 ( 1)         inx                     ; バッファアドレスを+1
103A-20 F8           168 ( 3)         bra     :loop
103C-97 99           169 ( 3) .1      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
103E-                170            ; // 転送の準備
103E-DE 9A           171 ( 4)         ldx     <PrgmEndAddr    ; X <- プログラムの最終アドレス
1040-DC 9A           172 ( 4)         ldd     <PrgmEndAddr
1042-D3 98           173 ( 4)         addd    <LineLength     ; D <- 行の長さを足した最終アドレス
1044-18              174 ( 2)         xgdx
1045-8C 0D FD        175 ( 3)         cpx     #USERAREABTM    ; ユーザーエリアを超えていないかチェック
1048-18              176 ( 2)         xgdx
1049-24 24           177 ( 3)         bcc     :err14          ; "Memory size over"
104B-DD 9A           178 ( 4)         std     <PrgmEndAddr    ; 新しい最終アドレスを設定
104D-                179            ; // 行番号と行の長さを転送
104D-DC 96           180 ( 4)         ldd     <LineNumber     ; 行番号を取得
104F-ED 00           181 ( 5)         std     0,x
1051-08              182 ( 1)         inx
1052-08              183 ( 1)         inx
1053-D6 99           184 ( 3)         ldab    <LineLength+1   ; 行の長さを取得
1055-E7 00           185 ( 4)         stab    0,x
1057-                186            ; // mem_copyの引数を設定
1057-08              187 ( 1)         inx
1058-DF 92           188 ( 4)         stx     <Destination    ; 転送先アドレス（行の長さの直後）を設定
105A-4F              189 ( 1)         clra                    ; LineLengthの上位バイトをゼロにする
105B-C0 03           190 ( 2)         subb    #3              ; LineLengthから行番号・行の長さの3バイト分を引く
105D-DD 94           191 ( 4)         std     <Bytes          ; 転送バイト数を設定
105F-DC 8D           192 ( 4)         ldd     <ExePointer     ; 行番号の直後を指しているバッファアドレスを復帰
1061-DD 90           193 ( 4)         std     <Source         ; 転送元アドレスを設定
1063-BD 14 9B        194 ( 6)         jsr     mem_copy
1066-                195            ; // 終端行の挿入
1066-DE 9A           196 ( 4)         ldx     <PrgmEndAddr
1068-4F              197 ( 1)         clra
1069-5F              198 ( 1)         clrb
106A-ED 00           199 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
106C-7E 10 0E        200 ( 3)         jmp     tb_main
106F-86 0E           201 ( 2) .err14  ldaa    #14              ; "Memory size over"
1071-7E 15 3A        202 ( 3)         jmp     write_err_msg
1074-                203
1074-                204
1074-                205      ; -----------------------------------------------------------------------
1074-                206      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1074-                207      ; Is a multi statement mark?
1074-                208      ;【引数】X:実行位置アドレス
1074-                209      ;【使用】B, X
1074-                210      ;【返値】なし
1074-                211      ; -----------------------------------------------------------------------
1074-                212      is_multi:
1074-BD 13 90        213 ( 6)         jsr     skip_space
1077-27 07           214 ( 3)         beq     :end
1079-C1 3A           215 ( 2)         cmpb    #':'
107B-26 06           216 ( 3)         bne     :err00
107D-08              217 ( 1)         inx
107E-20 07           218 ( 3)         bra     exe_line
1080-7E 10 0E        219 ( 3) .end    jmp     tb_main
1083-4F              220 ( 1) .err00  clra                    ; "Syntax error"
1084-7E 15 3A        221 ( 3)         jmp     write_err_msg
1087-                222
1087-                223
1087-                224      ; -----------------------------------------------------------------------
1087-                225      ; 一行実行
1087-                226      ; Execute one line
1087-                227      ;【引数】X:実行位置アドレス
1087-                228      ;【使用】A, B, X
1087-                229      ;【返値】なし
1087-                230      ; -----------------------------------------------------------------------
1087-                231      exe_line:
1087-BD 13 90        232 ( 6)         jsr     skip_space
108A-27 37           233 ( 3)         beq     :end            ; 終端文字（$00）ならば終了
108C-                234            ; // 代入文のチェック
108C-BD 13 7B        235 ( 6)         jsr     is_variable     ; 変数か？
108F-24 12           236 ( 3)         bcc     :cmd            ; No. テーブル検索へ
1091-86 01           237 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1093-58              238 ( 1)         aslb                    ; B = 変数領域の下位バイト
1094-DD 8B           239 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1096-BD 13 90        240 ( 6)         jsr     skip_space      ; Yes. 代入文か？
1099-C1 3D           241 ( 2)         cmpb    #'='
109B-26 29           242 ( 3)         bne     :err00          ; No. エラー処理へ
109D-08              243 ( 1)         inx                     ; Yes. 代入実行
109E-BD 13 CD        244 ( 6)         jsr     assign_to_var
10A1-20 D1           245 ( 3)         bra     is_multi
10A3-EC 00           246 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
10A5-DD A5           247 ( 4)         std     <COMPARE
10A7-EC 02           248 ( 5)         ldd     2,x
10A9-DD A7           249 ( 4)         std     <COMPARE+2
10AB-EC 04           250 ( 5)         ldd     4,x
10AD-DD A9           251 ( 4)         std     <COMPARE+4
10AF-DF 8D           252 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
10B1-7D 00 9C        253 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
10B4-27 05           254 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
10B6-CE 15 10        255 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
10B9-20 03           256 ( 3)         bra     :2
10BB-CE 15 1A        257 ( 3) .1      ldx     #SMT_TABLE
10BE-BD 14 D3        258 ( 6) .2      jsr     search_table    ; テーブル検索実行
10C1-24 03           259 ( 3)         bcc     :err00
10C3-7E 10 0E        260 ( 3) .end    jmp     tb_main
10C6-                261
10C6-4F              262 ( 1) .err00  clra                    ; Syntax error.
10C7-7E 15 3A        263 ( 3)         jmp     write_err_msg
10CA-                264
10CA-                265
10CA-                266      ; -----------------------------------------------------------------------
10CA-                267      ; 式を評価する
10CA-                268      ; Evaluate the expression
10CA-                269      ;【引数】B:アスキーコード X:実行位置アドレス
10CA-                270      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
10CA-                271      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
10CA-                272      ;        偽(C=0) / X:現在の実行位置アドレス
10CA-                273      ; -----------------------------------------------------------------------
10CA-                274      eval_expression:
00A1-                275      .SP     .eq     UR2
00A3-                276      .X      .eq     UR3
10CA-                277            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
10CA-DF A3           278 ( 4)         stx     <:X
10CC-30              279 ( 1)         tsx
10CD-DF A1           280 ( 4)         stx     <:SP
10CF-DE A3           281 ( 4)         ldx     <:X
10D1-                282            ; // 計算スタックの初期化
10D1-CC 01 72        283 ( 3)         ldd     #CSTACK+40+1    ; 40byte分
10D4-DD 82           284 ( 4)         std     <CStackPtr
10D6-                285            ; // 式評価開始
10D6-8D 08           286 ( 5)         bsr     expr_4th
10D8-                287            ; // 計算結果をスタックトップから取り出す
10D8-3C              288 ( 5)         pshx
10D9-DE 82           289 ( 4)         ldx     <CStackPtr
10DB-EC 00           290 ( 5)         ldd     0,x
10DD-38              291 ( 4)         pulx
10DE-0D              292 ( 1)         sec                     ; true:C=1
10DF-39              293 ( 5)         rts
10E0-                294
10E0-                295      expr_4th:
10E0-8D 50           296 ( 5)         bsr     expr_3rd
10E2-BD 13 90        297 ( 6) .loop   jsr     skip_space
10E5-C1 3D           298 ( 2)         cmpb    #'='            ; '='?
10E7-26 08           299 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
10E9-08              300 ( 1)         inx
10EA-8D 46           301 ( 5)         bsr     expr_3rd
10EC-BD 12 7A        302 ( 6)         jsr     CS_eq           ; EQual to
10EF-20 F1           303 ( 3)         bra     :loop
10F1-C1 3C           304 ( 2) .ltsign cmpb    #'<'            ; '<'?
10F3-26 22           305 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
10F5-08              306 ( 1)         inx
10F6-E6 00           307 ( 4)         ldab    0,x
10F8-C1 3E           308 ( 2)         cmpb    #'>'            ; '<>'?
10FA-26 08           309 ( 3)         bne     :lte
10FC-08              310 ( 1)         inx
10FD-8D 33           311 ( 5)         bsr     expr_3rd
10FF-BD 12 9B        312 ( 6)         jsr     CS_ne           ; Not Equal to
1102-20 DE           313 ( 3)         bra     :loop
1104-C1 3D           314 ( 2) .lte    cmpb    #'='            ; '<='?
1106-26 08           315 ( 3)         bne     :lt
1108-08              316 ( 1)         inx
1109-8D 27           317 ( 5)         bsr     expr_3rd
110B-BD 12 90        318 ( 6)         jsr     CS_lte          ; Less Than or Equal to
110E-20 D2           319 ( 3)         bra     :loop
1110-8D 20           320 ( 5) .lt     bsr     expr_3rd
1112-BD 12 85        321 ( 6)         jsr     CS_lt           ; Less Than
1115-20 CB           322 ( 3)         bra     :loop
1117-C1 3E           323 ( 2) .gtsign cmpb    #'>'            ; '>'?
1119-26 16           324 ( 3)         bne     :end
111B-08              325 ( 1)         inx
111C-E6 00           326 ( 4)         ldab    0,x
111E-C1 3D           327 ( 2)         cmpb    #'='            ; '>='?
1120-26 08           328 ( 3)         bne     :gt
1122-08              329 ( 1)         inx
1123-8D 0D           330 ( 5)         bsr     expr_3rd
1125-BD 12 B1        331 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
1128-20 B8           332 ( 3)         bra     :loop
112A-8D 06           333 ( 5) .gt     bsr     expr_3rd
112C-BD 12 A6        334 ( 6)         jsr     CS_gt           ; Greater Than
112F-20 B1           335 ( 3)         bra     :loop
1131-39              336 ( 5) .end    rts
1132-                337
1132-                338      expr_3rd:
1132-8D 1C           339 ( 5)         bsr     expr_2nd
1134-BD 13 90        340 ( 6) .loop   jsr     skip_space
1137-C1 2B           341 ( 2)         cmpb    #'+'
1139-26 08           342 ( 3)         bne     :minus
113B-08              343 ( 1)         inx
113C-8D 12           344 ( 5)         bsr     expr_2nd
113E-BD 11 C5        345 ( 6)         jsr     CS_add
1141-20 F1           346 ( 3)         bra     :loop
1143-C1 2D           347 ( 2) .minus  cmpb    #'-'
1145-26 08           348 ( 3)         bne     :end
1147-08              349 ( 1)         inx
1148-8D 06           350 ( 5)         bsr     expr_2nd
114A-BD 11 CE        351 ( 6)         jsr     CS_sub
114D-20 E5           352 ( 3)         bra     :loop
114F-39              353 ( 5) .end    rts
1150-                354
1150-                355      expr_2nd:
1150-8D 28           356 ( 5)         bsr     expr_1st
1152-BD 13 90        357 ( 6) .loop   jsr     skip_space
1155-C1 2A           358 ( 2)         cmpb    #'*'
1157-26 08           359 ( 3)         bne     :div
1159-08              360 ( 1)         inx
115A-8D 1E           361 ( 5)         bsr     expr_1st
115C-BD 11 D7        362 ( 6)         jsr     CS_mul
115F-20 F1           363 ( 3)         bra     :loop
1161-C1 2F           364 ( 2) .div    cmpb    #'/'
1163-26 08           365 ( 3)         bne     :mod
1165-08              366 ( 1)         inx
1166-8D 12           367 ( 5)         bsr     expr_1st
1168-BD 11 F4        368 ( 6)         jsr     CS_div
116B-20 E5           369 ( 3)         bra     :loop
116D-C1 25           370 ( 2) .mod    cmpb    #'%'
116F-26 08           371 ( 3)         bne     :end
1171-08              372 ( 1)         inx
1172-8D 06           373 ( 5)         bsr     expr_1st
1174-BD 12 10        374 ( 6)         jsr     CS_mod
1177-20 D9           375 ( 3)         bra     :loop
1179-39              376 ( 5) .end    rts
117A-                377
117A-                378      expr_1st:
00A1-                379      .SP     .eq     UR2
00A3-                380      .X      .eq     UR3
117A-BD 13 90        381 ( 6)         jsr     skip_space
117D-BD 12 C7        382 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
1180-24 02           383 ( 3)         bcc     :var            ; 数字でなければ変数のチェックへ
1182-20 1D           384 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
1184-BD 13 7B        385 ( 6) .var    jsr     is_variable     ; 変数か？
1187-24 0A           386 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
1189-                387            ; // 変数値の取得
1189-3C              388 ( 5)         pshx                    ; 実行位置アドレスを退避
118A-86 01           389 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
118C-58              390 ( 1)         aslb                    ; B = 変数領域の下位バイト
118D-18              391 ( 2)         xgdx                    ; X = 変数のアドレス
118E-EC 00           392 ( 5)         ldd     0,x             ; D <- 変数の値
1190-38              393 ( 4)         pulx                    ; 実行位置アドレスを復帰
1191-20 0E           394 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
1193-C1 28           395 ( 2) .paren  cmpb    #'('
1195-26 1A           396 ( 3)         bne     :err
1197-08              397 ( 1)         inx
1198-BD 10 E0        398 ( 6)         jsr     expr_4th
119B-C1 29           399 ( 2)         cmpb    #')'
119D-26 12           400 ( 3)         bne     :err
119F-08              401 ( 1)         inx
11A0-39              402 ( 5)         rts
11A1-3C              403 ( 5) .push   pshx                    ; 実行位置アドレスを退避
11A2-DE 82           404 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11A4-09              405 ( 1)         dex
11A5-09              406 ( 1)         dex
11A6-8C 01 47        407 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
11A9-25 0D           408 ( 3)         bcs     :err06
11AB-ED 00           409 ( 5)         std     0,x
11AD-DF 82           410 ( 4)         stx     <CStackPtr
11AF-38              411 ( 4)         pulx                    ; 実行位置アドレスを復帰
11B0-39              412 ( 5)         rts
11B1-                413            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
11B1-DE A1           414 ( 4) .err    ldx     <:SP
11B3-35              415 ( 1)         txs
11B4-DE A3           416 ( 4)         ldx     <:X
11B6-0C              417 ( 1)         clc                     ; false:C=0
11B7-39              418 ( 5)         rts
11B8-86 06           419 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
11BA-7E 15 3A        420 ( 3)         jmp     write_err_msg
11BD-                421
11BD-                422      ;
11BD-                423      ; Arithmetic operator
11BD-                424      ;
11BD-                425      CS_store:
11BD-08              426 ( 1)         inx
11BE-08              427 ( 1)         inx
11BF-ED 00           428 ( 5)         std     0,x
11C1-DF 82           429 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
11C3-38              430 ( 4)         pulx                    ; 実行位置アドレスを復帰
11C4-39              431 ( 5)         rts
11C5-                432
11C5-3C              433 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
11C6-DE 82           434 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11C8-EC 02           435 ( 5)         ldd     2,x
11CA-E3 00           436 ( 5)         addd    0,x
11CC-20 EF           437 ( 3)         bra     CS_store
11CE-                438
11CE-3C              439 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
11CF-DE 82           440 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11D1-EC 02           441 ( 5)         ldd     2,x
11D3-A3 00           442 ( 5)         subd    0,x
11D5-20 E6           443 ( 3)         bra     CS_store
11D7-                444
11D7-                445      CS_mul:
009D-                446      .Result         .eq     UR0
11D7-3C              447 ( 5)         pshx                    ; 実行位置アドレスを退避
11D8-DE 82           448 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11DA-                449              ; B * D
11DA-A6 03           450 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
11DC-E6 01           451 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
11DE-3D              452 ( 7)         mul                     ; B * D
11DF-DD 9D           453 ( 4)         std     <:Result        ;「B*D」を保存
11E1-                454              ; A * D
11E1-EC 01           455 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
11E3-3D              456 ( 7)         mul                     ; A * D
11E4-DB 9D           457 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
11E6-D7 9D           458 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
11E8-                459              ; C * B
11E8-A6 00           460 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
11EA-E6 03           461 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
11EC-3D              462 ( 7)         mul                     ; C * B
11ED-DB 9D           463 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
11EF-17              464 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
11F0-D6 9E           465 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
11F2-20 C9           466 ( 3)         bra     CS_store
11F4-                467
11F4-                468      ;
11F4-                469      ; 符号付き割り算の考え方
11F4-                470      ; ・剰余は除数の符号と同一
11F4-                471      ;   ・ 7 / 3  = 商  2、剰余  1
11F4-                472      ;   ・-7 / 3  = 商 -3、剰余  2
11F4-                473      ;   ・ 7 / -3 = 商 -3、剰余 -2
11F4-                474      ;   ・-7 / -3 = 商  2、剰余 -1
11F4-                475      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
11F4-                476      ;       2.ただし、除数がゼロの場合は1は足さない
11F4-                477      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
11F4-                478      ;         除数の絶対値から剰余の絶対値を引く
11F4-                479      ;       2.その結果を除数と同じ符号にする
11F4-                480      ;       3.ただし、除数がゼロの場合は剰余もゼロ
11F4-                481      ;
11F4-3C              482 ( 5) CS_div: pshx                    ; 実行位置アドレスを退避
11F5-DE 82           483 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
11F7-8D 37           484 ( 5)         bsr     div_uint        ; 除算実行
11F9-18              485 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
11FA-7D 00 85        486 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
11FD-27 0D           487 ( 3)         beq     :end            ; '+'なら終了
11FF-8C 00 00        488 ( 3)         cpx     #0              ; 剰余はゼロか？
1202-27 03           489 ( 3)         beq     :sign
1204-C3 00 01        490 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
1207-43              491 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
1208-53              492 ( 1)         comb
1209-C3 00 01        493 ( 3)         addd    #1
120C-DE 82           494 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
120E-20 AD           495 ( 3)         bra     CS_store
1210-                496
1210-3C              497 ( 5) CS_mod: pshx                    ; 実行位置アドレスを退避
1211-DE 82           498 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1213-8D 1B           499 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
1215-DD 89           500 ( 4)         std     <Remainder      ; 剰余はゼロか？
1217-27 13           501 ( 3)         beq     :end            ; ゼロであれば終了
1219-7D 00 85        502 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
121C-27 04           503 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
121E-DC 87           504 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
1220-93 89           505 ( 4)         subd    <Remainder
1222-7D 00 86        506 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
1225-27 05           507 ( 3)         beq     :end            ; '+'なら終了
1227-43              508 ( 1)         coma                    ; '-'なら2の補数にする
1228-53              509 ( 1)         comb
1229-C3 00 01        510 ( 3)         addd    #1
122C-DE 82           511 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
122E-20 8D           512 ( 3)         bra     CS_store
1230-                513
1230-                514      div_uint:
009D-                515      .Counter        .eq     UR0H
1230-EC 00           516 ( 5)         ldd     0,x             ; ゼロ除算チェック
1232-27 41           517 ( 3)         beq     :err08          ; 除数がゼロならエラー
1234-5F              518 ( 1)         clrb
1235-D7 85           519 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1237-D7 86           520 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1239-C6 10           521 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
123B-D7 9D           522 ( 3)         stab    <:Counter
123D-                523              ; // 剰余の符号フラグの設定
123D-EC 00           524 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
123F-2A 03           525 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1241-7C 00 86        526 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
1244-                527              ; // 商の符号フラグの設定
1244-A8 02           528 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
1246-2A 03           529 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
1248-7C 00 85        530 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
124B-                531              ; // 除数を絶対値にする
124B-EC 00           532 ( 5) .2      ldd     0,x             ; D <- 除数
124D-2A 05           533 ( 3)         bpl     :3
124F-43              534 ( 1)         coma                    ; 除数が負なら絶対値にする
1250-53              535 ( 1)         comb
1251-C3 00 01        536 ( 3)         addd    #1
1254-DD 87           537 ( 4) .3      std     <Divisor        ; 除数を保存
1256-                538              ; // 非除数を絶対値にする
1256-EC 02           539 ( 5)         ldd     2,x             ; D <- 被除数
1258-2A 05           540 ( 3)         bpl     :4
125A-43              541 ( 1)         coma                    ; 被除数が負なら絶対値にする
125B-53              542 ( 1)         comb
125C-C3 00 01        543 ( 3)         addd    #1
125F-                544              ; // 除算実行
125F-18              545 ( 2) .4      xgdx                    ; X <- 被除数
1260-4F              546 ( 1)         clra                    ; D（WORK）をクリア
1261-5F              547 ( 1)         clrb
1262-18              548 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
1263-05              549 ( 1)         asld
1264-18              550 ( 2)         xgdx
1265-59              551 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
1266-49              552 ( 1)         rola
1267-93 87           553 ( 4)         subd    <Divisor        ; WORK - 除数
1269-08              554 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
126A-24 03           555 ( 3)         bcc     :5              ; WORKから除数を引けた？
126C-D3 87           556 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
126E-09              557 ( 1)         dex                     ; XレジスタのLSBを0に戻す
126F-7A 00 9D        558 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1272-26 EE           559 ( 3)         bne     :loop
1274-39              560 ( 5)         rts
1275-86 08           561 ( 2) .err08  ldaa    #8              ; "Zero Divide"
1277-7E 15 3A        562 ( 3)         jmp     write_err_msg
127A-                563
127A-3C              564 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
127B-DE 82           565 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
127D-EC 02           566 ( 5)         ldd     2,x
127F-A3 00           567 ( 5)         subd    0,x
1281-27 39           568 ( 3)         beq     CS_true
1283-20 3D           569 ( 3)         bra     CS_false
1285-                570
1285-3C              571 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
1286-DE 82           572 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1288-EC 02           573 ( 5)         ldd     2,x
128A-A3 00           574 ( 5)         subd    0,x
128C-2D 2E           575 ( 3)         blt     CS_true
128E-20 32           576 ( 3)         bra     CS_false
1290-                577
1290-3C              578 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1291-DE 82           579 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1293-EC 02           580 ( 5)         ldd     2,x
1295-A3 00           581 ( 5)         subd    0,x
1297-2F 23           582 ( 3)         ble     CS_true
1299-20 27           583 ( 3)         bra     CS_false
129B-                584
129B-3C              585 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
129C-DE 82           586 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
129E-EC 02           587 ( 5)         ldd     2,x
12A0-A3 00           588 ( 5)         subd    0,x
12A2-26 18           589 ( 3)         bne     CS_true
12A4-20 1C           590 ( 3)         bra     CS_false
12A6-                591
12A6-3C              592 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
12A7-DE 82           593 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12A9-EC 02           594 ( 5)         ldd     2,x
12AB-A3 00           595 ( 5)         subd    0,x
12AD-2E 0D           596 ( 3)         bgt     CS_true
12AF-20 11           597 ( 3)         bra     CS_false
12B1-                598
12B1-3C              599 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
12B2-DE 82           600 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12B4-EC 02           601 ( 5)         ldd     2,x
12B6-A3 00           602 ( 5)         subd    0,x
12B8-2C 02           603 ( 3)         bge     CS_true
12BA-20 06           604 ( 3)         bra     CS_false
12BC-                605
12BC-                606      CS_true:
12BC-CC 00 01        607 ( 3)         ldd     #1
12BF-7E 11 BD        608 ( 3)         jmp     CS_store
12C2-                609
12C2-                610      CS_false:
12C2-4F              611 ( 1)         clra
12C3-5F              612 ( 1)         clrb
12C4-7E 11 BD        613 ( 3)         jmp     CS_store
12C7-                614
12C7-                615      ; -----------------------------------------------------------------------
12C7-                616      ; テキストバッファの10進文字列から数値を取得する
12C7-                617      ; Get a integer from a decimal string in a text buffer
12C7-                618      ;【引数】X:バッファアドレス
12C7-                619      ;【使用】A, B, X, UR0, UR1
12C7-                620      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
12C7-                621      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
12C7-                622      ; -----------------------------------------------------------------------
12C7-                623      get_int_from_decimal:
009D-                624      .RetValue       .eq     UR0     ; Return Value
009F-                625      .TempValue      .eq     UR1     ; Temporary Value
12C7-4F              626 ( 1)         clra
12C8-5F              627 ( 1)         clrb
12C9-DD 9D           628 ( 4)         std     <:RetValue
12CB-97 9F           629 ( 3)         staa    <:TempValue
12CD-97 84           630 ( 3)         staa    <SignFlag
12CF-E6 00           631 ( 4)         ldab    0,x             ; 1文字取得
12D1-C1 2D           632 ( 2)         cmpb    #'-'            ; マイナス記号か？
12D3-26 05           633 ( 3)         bne     :1
12D5-7C 00 84        634 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
12D8-20 0B           635 ( 3)         bra     :next
12DA-C1 2B           636 ( 2) .1      cmpb    #'+'            ; プラス記号か？
12DC-27 07           637 ( 3)         beq     :next
12DE-BD FF C1        638 ( 6)         jsr     is_decimal_char ; 数字か？
12E1-24 36           639 ( 3)         bcc     :false          ; No. C=1で終了
12E3-20 13           640 ( 3)         bra     :first
12E5-08              641 ( 1) .next   inx                     ; 符号の次の1文字を取得
12E6-E6 00           642 ( 4)         ldab    0,x
12E8-BD FF C1        643 ( 6)         jsr     is_decimal_char ; 数字か？
12EB-24 40           644 ( 3)         bcc     :err04          ; No. エラー処理へ
12ED-20 09           645 ( 3)         bra     :first          ; Yes. これが最初の数字
12EF-DD 9D           646 ( 4) .loop   std     <:RetValue      ; 結果を退避
12F1-E6 00           647 ( 4)         ldab    0,x             ; 1文字取得
12F3-BD FF C1        648 ( 6)         jsr     is_decimal_char ; 数字か？
12F6-24 14           649 ( 3)         bcc     :end
12F8-C0 30           650 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
12FA-D7 A0           651 ( 3)         stab    <:TempValue+1
12FC-                652            ; // RetValue * 10 + TempValue
12FC-DC 9D           653 ( 4)         ldd     <:RetValue
12FE-05              654 ( 1)         asld                    ; * 2
12FF-05              655 ( 1)         asld                    ; * 4
1300-D3 9D           656 ( 4)         addd    <:RetValue      ; * 5
1302-05              657 ( 1)         asld                    ; * 10
1303-D3 9F           658 ( 4)         addd    <:TempValue     ; += TempValue
1305-08              659 ( 1)         inx                     ; ポインタを進める
1306-25 20           660 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
1308-2B 10           661 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
130A-20 E3           662 ( 3)         bra     :loop
130C-DC 9D           663 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
130E-7D 00 84        664 ( 4)         tst     <SignFlag       ; 符号チェック
1311-27 05           665 ( 3)         beq     :true
1313-43              666 ( 1)         coma                    ; 負なら2の補数に
1314-53              667 ( 1)         comb
1315-C3 00 01        668 ( 3)         addd    #1
1318-0D              669 ( 1) .true   sec
1319-39              670 ( 5) .false  rts
131A-                671
131A-                672      .overflow
131A-                673            ; // -32,768かどうかの判定
131A-18              674 ( 2)         xgdx
131B-8C 80 00        675 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
131E-18              676 ( 2)         xgdx
131F-26 07           677 ( 3)         bne     :err02          ; No. 範囲外
1321-7D 00 84        678 ( 4)         tst     <SignFlag       ; 符号チェック
1324-27 02           679 ( 3)         beq     :err02          ; 正ならば範囲外
1326-20 C7           680 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
1328-                681
1328-86 02           682 ( 2) .err02  ldaa    #2              ; "Out of range"
132A-7E 15 3A        683 ( 3)         jmp     write_err_msg
132D-86 04           684 ( 2) .err04  ldaa    #4              ; "Illegal expression"
132F-7E 15 3A        685 ( 3)         jmp     write_err_msg
1332-                686
1332-                687
1332-                688      ; -----------------------------------------------------------------------
1332-                689      ; Dレジスタの数値をコンソールに出力する
1332-                690      ; Write Decimal Character converted from Integer
1332-                691      ;【引数】D:Integer
1332-                692      ;【使用】A, B, X
1332-                693      ;【返値】なし
1332-                694      ; -----------------------------------------------------------------------
1332-                695      write_integer:
009D-                696      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
009E-                697      .Counter        .eq     UR0L    ; 桁カウンター
1332-2A 0C           698 ( 3)         bpl     :plus           ; 符号判定
1334-37              699 ( 4)         pshb                    ; 負数なら'-'を出力する
1335-C6 2D           700 ( 2)         ldab    #'-'
1337-BD FF AC        701 ( 6)         jsr     write_char
133A-33              702 ( 3)         pulb
133B-43              703 ( 1)         coma                    ; 絶対値にする（2の補数にする）
133C-53              704 ( 1)         comb
133D-C3 00 01        705 ( 3)         addd    #1
1340-7F 00 9D        706 ( 5) .plus   clr     <:ZeroSuppress
1343-CE 13 73        707 ( 3)         ldx     #:CONST
1346-7F 00 9E        708 ( 5) .loop   clr     <:Counter
1349-A3 00           709 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
134B-25 05           710 ( 3)         bcs     :write
134D-7C 00 9E        711 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1350-20 F7           712 ( 3)         bra     :digit
1352-                713
1352-E3 00           714 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
1354-37              715 ( 4)         pshb
1355-D6 9E           716 ( 3)         ldab    <:Counter
1357-27 03           717 ( 3)         beq     :1              ; この桁はゼロか？
1359-7C 00 9D        718 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
135C-7D 00 9D        719 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
135F-27 05           720 ( 3)         beq     :2              ; No. この桁は表示しない
1361-CB 30           721 ( 2)         addb    #$30            ; Yes. この桁を表示する
1363-BD FF AC        722 ( 6)         jsr     write_char
1366-33              723 ( 3) .2      pulb
1367-08              724 ( 1)         inx                     ; 次の引く数へ
1368-08              725 ( 1)         inx
1369-8C 13 7B        726 ( 3)         cpx     #:CONST+8
136C-26 D8           727 ( 3)         bne     :loop
136E-CB 30           728 ( 2)         addb    #$30            ; 一の桁の数値を表示
1370-7E FF AC        729 ( 3)         jmp     write_char
1373-                730      ; Dから引いていく数
1373-27 10           731      .CONST  .dw     $2710           ; 10,000
1375-03 E8           732              .dw     $03e8           ; 1,000
1377-00 64           733              .dw     $0064           ; 100
1379-00 0A           734              .dw     $000a           ; 10
137B-                735
137B-                736
137B-                737      ; -----------------------------------------------------------------------
137B-                738      ; テキストバッファの英文字が変数か判定する
137B-                739      ; Is a character retrieved from a text buffer a variable?
137B-                740      ;【引数】X:バッファアドレス
137B-                741      ;【使用】A, B, X
137B-                742      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
137B-                743      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
137B-                744      ; -----------------------------------------------------------------------
137B-                745      is_variable:
137B-E6 00           746 ( 4)         ldab    0,x
137D-BD FF BE        747 ( 6)         jsr     is_alphabetic_char
1380-24 0D           748 ( 3)         bcc     :end
1382-17              749 ( 1)         tba                             ; 1文字目のアスキーコードを退避
1383-E6 01           750 ( 4)         ldab    1,x                     ; 2文字目を取得
1385-BD FF BE        751 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
1388-16              752 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
1389-24 02           753 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
138B-0C              754 ( 1)         clc                             ; Yes. 変数ではない。C=0
138C-39              755 ( 5)         rts
138D-08              756 ( 1) .var    inx                             ; ポインタを進める
138E-0D              757 ( 1)         sec                             ; C=1
138F-39              758 ( 5) .end    rts
1390-                759
1390-                760
1390-                761      ; -----------------------------------------------------------------------
1390-                762      ; 空白を読み飛ばす
1390-                763      ; Skip Space
1390-                764      ;【引数】X:実行位置アドレス
1390-                765      ;【使用】B, X
1390-                766      ;【返値】B:アスキーコード（$00の時Z=1）
1390-                767      ;        X:実行位置アドレス
1390-                768      ; -----------------------------------------------------------------------
1390-                769      skip_space:
1390-E6 00           770 ( 4)         ldab    0,x
1392-27 07           771 ( 3)         beq     :end
1394-C1 20           772 ( 2)         cmpb    #SPACE
1396-22 03           773 ( 3)         bhi     :end
1398-08              774 ( 1)         inx
1399-20 F5           775 ( 3)         bra     skip_space
139B-39              776 ( 5) .end    rts
139C-                777
139C-                778
139C-                779      ; -----------------------------------------------------------------------
139C-                780      ; 引用符付きの文字列を出力する
139C-                781      ; Write Quoted Stirng
139C-                782      ;【引数】B:アスキーコード X:実行位置アドレス
139C-                783      ;【使用】A, B, X
139C-                784      ;【返値】真(C=1) / X:次の実行位置アドレス
139C-                785      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
139C-                786      ; -----------------------------------------------------------------------
139C-                787      write_quoted_str:
139C-C1 22           788 ( 2)         cmpb    #$22            ; 一重引用符か？
139E-27 04           789 ( 3)         beq     :1
13A0-C1 27           790 ( 2)         cmpb    #$27            ; 二重引用符か？
13A2-26 19           791 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
13A4-17              792 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
13A5-                793            ; // 終端の引用符をチェック
13A5-3C              794 ( 5)         pshx
13A6-08              795 ( 1) .check  inx
13A7-E6 00           796 ( 4)         ldab    0,x
13A9-27 14           797 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
13AB-11              798 ( 1)         cba
13AC-26 F8           799 ( 3)         bne     :check
13AE-38              800 ( 4)         pulx
13AF-                801            ; // 文字列の出力
13AF-08              802 ( 1) .loop   inx
13B0-E6 00           803 ( 4)         ldab    0,x
13B2-11              804 ( 1)         cba                     ; 保存した引用符との比較
13B3-27 05           805 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
13B5-BD FF AC        806 ( 6)         jsr     write_char
13B8-20 F5           807 ( 3)         bra     :loop
13BA-08              808 ( 1) .true   inx
13BB-0D              809 ( 1)         sec
13BC-39              810 ( 5)         rts
13BD-0C              811 ( 1) .false  clc
13BE-39              812 ( 5)         rts
13BF-86 0A           813 ( 2) .err10  ldaa    #10             ; "Print statement error"
13C1-7E 15 3A        814 ( 3)         jmp     write_err_msg
13C4-                815
13C4-                816
13C4-                817      ; -----------------------------------------------------------------------
13C4-                818      ; タブを出力する
13C4-                819      ; Write tabs
13C4-                820      ;【引数】なし
13C4-                821      ;【使用】B
13C4-                822      ;【返値】なし
13C4-                823      ; -----------------------------------------------------------------------
13C4-                824      write_tab:
13C4-BD FF B5        825 ( 6) .top    jsr     write_space
13C7-7B 07 39        826 ( 4)         tim     #7,<TabCount
13CA-26 F8           827 ( 3)         bne     :top
13CC-39              828 ( 5)         rts
13CD-                829
13CD-                830
13CD-                831      ; -----------------------------------------------------------------------
13CD-                832      ; 式を評価して変数に値を代入する
13CD-                833      ; Evaluate an expression and assign a value to a variable
13CD-                834      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
13CD-                835      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
13CD-                836      ;【返値】D:Integer X:次の実行位置アドレス
13CD-                837      ; -----------------------------------------------------------------------
13CD-                838      assign_to_var:
13CD-BD 13 90        839 ( 6)         jsr     skip_space
13D0-BD 10 CA        840 ( 6)         jsr     eval_expression
13D3-24 07           841 ( 3)         bcc     :err04
13D5-3C              842 ( 5)         pshx                    ; 実行位置アドレスを退避
13D6-DE 8B           843 ( 4)         ldx     <VariableAddr
13D8-ED 00           844 ( 5)         std     0,x             ; 変数に結果を保存
13DA-38              845 ( 4)         pulx                    ; 実行位置アドレスを復帰
13DB-39              846 ( 5)         rts
13DC-86 04           847 ( 2) .err04  ldaa    #4              ; "Illegal expression"
13DE-7E 15 3A        848 ( 3)         jmp     write_err_msg
13E1-                849
13E1-                850
13E1-                851      ; -----------------------------------------------------------------------
13E1-                852      ; listコマンドを実行する
13E1-                853      ; Execute 'list' command
13E1-                854      ;【引数】なし
13E1-                855      ;【使用】A, B, X
13E1-                856      ;【返値】なし
13E1-                857      ; -----------------------------------------------------------------------
13E1-                858      exe_list:
13E1-CE 04 00        859 ( 3)         ldx     #USERAREATOP
13E4-                860            ; // 行番号出力
13E4-EC 00           861 ( 5) .loop   ldd     0,x
13E6-27 11           862 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
13E8-3C              863 ( 5)         pshx
13E9-BD 13 32        864 ( 6)         jsr     write_integer
13EC-38              865 ( 4)         pulx
13ED-                866            ; // 本文出力
13ED-08              867 ( 1)         inx                     ; 本文までスキップ
13EE-08              868 ( 1)         inx
13EF-08              869 ( 1)         inx
13F0-BD FF AF        870 ( 6)         jsr     write_line
13F3-BD FF B2        871 ( 6)         jsr     write_crlf
13F6-08              872 ( 1)         inx                     ; 次の行番号へ
13F7-20 EB           873 ( 3)         bra     :loop
13F9-7E 10 0E        874 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
13FC-                875
13FC-                876
13FC-                877      ; -----------------------------------------------------------------------
13FC-                878      ; Print文を実行する
13FC-                879      ; Execute 'print' statement
13FC-                880      ;【引数】X:実行位置アドレス
13FC-                881      ;【使用】B, X（下位ルーチンでA）
13FC-                882      ;【返値】なし
13FC-                883      ; -----------------------------------------------------------------------
13FC-                884      exe_print:
13FC-72 01 8F        885 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
13FF-BD 13 90        886 ( 6) .loop   jsr     skip_space
1402-27 37           887 ( 3)         beq     :finish         ; 終端文字なら改行して終了
1404-BD 13 9C        888 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1407-25 1B           889 ( 3)         bcs     :nlon
1409-BD 10 CA        890 ( 6)         jsr     eval_expression
140C-25 11           891 ( 3)         bcs     :int
140E-                892            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
140E-                893            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
140E-C1 3B           894 ( 2) .check  cmpb    #';'
1410-27 23           895 ( 3)         beq     :nloff
1412-C1 2C           896 ( 2)         cmpb    #','
1414-27 1C           897 ( 3)         beq     :tab
1416-C1 3A           898 ( 2)         cmpb    #':'
1418-27 21           899 ( 3)         beq     :finish
141A-86 04           900 ( 2)         ldaa    #4              ; "Illegal expression"
141C-7E 15 3A        901 ( 3)         jmp     write_err_msg
141F-3C              902 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1420-BD 13 32        903 ( 6)         jsr     write_integer   ; 評価した式を出力
1423-38              904 ( 4)         pulx                    ; 実行位置アドレスを復帰
1424-72 01 8F        905 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1427-BD 13 90        906 ( 6)         jsr     skip_space
142A-C1 3B           907 ( 2)         cmpb    #';'
142C-27 07           908 ( 3)         beq     :nloff
142E-C1 2C           909 ( 2)         cmpb    #','
1430-26 09           910 ( 3)         bne     :finish
1432-BD 13 C4        911 ( 6) .tab    jsr     write_tab       ; タブ出力
1435-7F 00 8F        912 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
1438-08              913 ( 1)         inx                     ; 次の文字へ
1439-20 C4           914 ( 3)         bra     :loop
143B-7D 00 8F        915 ( 4) .finish tst     <NewLineFlag
143E-27 03           916 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1440-BD FF B2        917 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
1443-7E 10 74        918 ( 3) .end    jmp     is_multi
1446-                919
1446-                920
1446-                921      ; -----------------------------------------------------------------------
1446-                922      ; input文を実行する
1446-                923      ; Execute 'input' statement
1446-                924      ; -----------------------------------------------------------------------
1446-                925      exe_input:
1446-BD 13 90        926 ( 6)         jsr     skip_space
1449-27 31           927 ( 3)         beq     :end            ; 終端文字なら改行して終了
144B-BD 13 9C        928 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
144E-24 0A           929 ( 3)         bcc     :1
1450-E6 00           930 ( 4)         ldab    0,x
1452-C1 3B           931 ( 2)         cmpb    #';'
1454-26 29           932 ( 3)         bne     :err00
1456-08              933 ( 1)         inx
1457-BD 13 90        934 ( 6)         jsr     skip_space
145A-BD 13 7B        935 ( 6) .1      jsr     is_variable
145D-24 20           936 ( 3)         bcc     :err00
145F-86 01           937 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1461-58              938 ( 1)         aslb                    ; B = 変数領域の下位バイト
1462-DD 8B           939 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1464-                940            ; // 変数の後に余計な文字がないか確認
1464-                941            ; // 例えば "input a+b" など
1464-DF 8D           942 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
1466-BD 13 90        943 ( 6)         jsr     skip_space
1469-27 06           944 ( 3)         beq     :read           ; 終端文字なら入力へ
146B-C1 3A           945 ( 2)         cmpb    #':'            ; ":"なら入力へ
146D-26 10           946 ( 3)         bne     :err00          ; それ以外の文字ならエラー
146F-DE 8D           947 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1471-BD FF A9        948 ( 6) .read   jsr     read_line
1474-CE 01 00        949 ( 3)         ldx     #Rx_BUFFER
1477-BD 13 CD        950 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
147A-DE 8D           951 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
147C-7E 10 74        952 ( 3) .end    jmp     is_multi
147F-4F              953 ( 1) .err00  clra                    ; "Syntax error"
1480-7E 15 3A        954 ( 3)         jmp     write_err_msg
1483-                955
1483-                956
1483-                957      ; -----------------------------------------------------------------------
1483-                958      ; if文を実行する
1483-                959      ; Execute 'if' statement
1483-                960      ;【引数】X:実行位置アドレス
1483-                961      ;【使用】B, X
1483-                962      ;【返値】なし
1483-                963      ; -----------------------------------------------------------------------
1483-BD 13 90        964 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
1486-27 0B           965 ( 3)         beq     :end            ; 終端文字なら終了
1488-BD 10 CA        966 ( 6)         jsr     eval_expression ; 式評価
148B-24 09           967 ( 3)         bcc     :err04
148D-5D              968 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
148E-27 03           969 ( 3)         beq     :end
1490-7E 10 87        970 ( 3)         jmp     exe_line        ; True
1493-7E 10 0E        971 ( 3) .end    jmp     tb_main         ; Falseならば全て無視され行末まで進む
1496-86 04           972 ( 2) .err04  ldaa    #4              ; "Illegal expression"
1498-7E 15 3A        973 ( 3)         jmp     write_err_msg
149B-                974
149B-                975
149B-                976      ; ------------------------------------------------
149B-                977      ; ブロック転送
149B-                978      ; Copy memory
149B-                979      ;【引数】Source:転送元アドレス
149B-                980      ;        Destination:転送先アドレス
149B-                981      ;        Bytes:転送バイト数
149B-                982      ;【使用】A, B, X, R0
149B-                983      ;【返値】なし
149B-                984      ; ------------------------------------------------
149B-                985      mem_copy:
009D-                986      .Offset .eq     UR0
149B-DC 94           987 ( 4)         ldd     <Bytes
149D-27 33           988 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
149F-                989            ; // オフセットの計算
149F-DC 92           990 ( 4)         ldd     <Destination    ; dst - src
14A1-93 90           991 ( 4)         subd    <Source
14A3-DD 9D           992 ( 4)         std     <:Offset        ; offset = dst - src
14A5-                993            ; // 終了判定用のアドレスを計算
14A5-DC 90           994 ( 4)         ldd     <Source
14A7-D3 94           995 ( 4)         addd    <Bytes          ; src + bytes = 転元終了アドレス
14A9-DD 92           996 ( 4)         std     <Destination    ; 転送終了アドレスを代入
14AB-                997            ; // 転送開始
14AB-DE 90           998 ( 4)         ldx     <Source         ; 転送開始アドレスを代入
14AD-                999            ; // 転送するバイト数が奇数か偶数か判断。
14AD-               1000            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
14AD-DC 94          1001 ( 4)         ldd     <Bytes
14AF-04             1002 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
14B0-24 0E          1003 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
14B2-               1004            ; // Byte転送
14B2-A6 00          1005 ( 4)         ldaa    0,x             ; A <- [source]
14B4-18             1006 ( 2)         xgdx                    ; D = address, X = data
14B5-D3 9D          1007 ( 4)         addd    <:Offset        ; src - offset = dst
14B7-18             1008 ( 2)         xgdx                    ; D = data, X = address
14B8-A7 00          1009 ( 4)         staa    0,x             ; [dst] <- A
14BA-18             1010 ( 2)         xgdx                    ; D = address, X = data
14BB-93 9D          1011 ( 4)         subd    <:Offset        ; dst + offset = src
14BD-18             1012 ( 2)         xgdx                    ; D = data, X = address
14BE-20 0D          1013 ( 3)         bra     :odd
14C0-               1014            ; // Word転送
14C0-EC 00          1015 ( 5) .loop   ldd     0,x
14C2-18             1016 ( 2)         xgdx
14C3-D3 9D          1017 ( 4)         addd    <:Offset
14C5-18             1018 ( 2)         xgdx
14C6-ED 00          1019 ( 5)         std     0,x
14C8-18             1020 ( 2)         xgdx
14C9-93 9D          1021 ( 4)         subd    <:Offset
14CB-18             1022 ( 2)         xgdx
14CC-08             1023 ( 1)         inx
14CD-08             1024 ( 1) .odd    inx
14CE-9C 92          1025 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
14D0-26 EE          1026 ( 3)         bne     :loop
14D2-39             1027 ( 5) .end    rts
14D3-               1028
14D3-               1029
14D3-               1030      ; -----------------------------------------------------------------------
14D3-               1031      ; テーブル検索
14D3-               1032      ; Search the keyword table
14D3-               1033      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
14D3-               1034      ;【使用】A, B, X
14D3-               1035      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
14D3-               1036      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
14D3-               1037      ; -----------------------------------------------------------------------
14D3-               1038      search_table:
14D3-EC 05          1039 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
14D5-91 A5          1040 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
14D7-26 2F          1041 ( 3)         bne     :false
14D9-D1 A6          1042 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
14DB-26 2B          1043 ( 3)         bne     :false
14DD-EC 07          1044 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
14DF-4D             1045 ( 1)         tsta                    ; $00（終端記号）か？
14E0-27 1B          1046 ( 3)         beq     :true
14E2-91 A7          1047 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
14E4-26 22          1048 ( 3)         bne     :false
14E6-5D             1049 ( 1)         tstb                    ; $00（終端記号）か？
14E7-27 14          1050 ( 3)         beq     :true
14E9-D1 A8          1051 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
14EB-26 1B          1052 ( 3)         bne     :false
14ED-EC 09          1053 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
14EF-4D             1054 ( 1)         tsta                    ; $00（終端記号）か？
14F0-27 0B          1055 ( 3)         beq     :true
14F2-91 A9          1056 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
14F4-26 12          1057 ( 3)         bne     :false
14F6-5D             1058 ( 1)         tstb                    ; $00（終端記号）か？
14F7-27 04          1059 ( 3)         beq     :true
14F9-D1 AA          1060 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
14FB-26 0B          1061 ( 3)         bne     :false
14FD-E6 02          1062 ( 4) .true   ldab    2,x             ; B = 語長
14FF-EE 03          1063 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
1501-31             1064 ( 1)         ins                     ; 元のリターンアドレスを削除
1502-31             1065 ( 1)         ins
1503-3C             1066 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
1504-DE 8D          1067 ( 4)         ldx     <ExePointer
1506-3A             1068 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
1507-39             1069 ( 5)         rts                     ; 命令ルーチンにジャンプ
1508-EE 00          1070 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
150A-26 C7          1071 ( 3)         bne     :top
150C-DE 8D          1072 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
150E-0C             1073 ( 1)         clc                     ; false: C=0
150F-39             1074 ( 5)         rts
1510-               1075
1510-               1076
1510-               1077      ; ***********************************************************************
1510-               1078      ;   キーワードテーブル Keyword table
1510-               1079      ; ***********************************************************************
1510-               1080      ; レコードの構造 Record structure
1510-               1081      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1510-               1082      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
1510-               1083      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
1510-               1084      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
1510-               1085      ; キーワードは2文字以上6文字以下
1510-               1086      CMD_TABLE
1510-15 1A          1087      .list           .dw     SMT_TABLE:print
1512-04             1088                      .db     4
1513-13 E1          1089                      .dw     exe_list
1515-6C 69 73 74 
     00             1090                      .az     "list"
151A-               1091      SMT_TABLE
151A-15 25          1092      .print          .dw     :input
151C-05             1093                      .db     5
151D-13 FC          1094                      .dw     exe_print
151F-70 72 69 6E 
     74 00          1095                      .az     "print"
1525-15 30          1096      .input          .dw     :if
1527-05             1097                      .db     5
1528-14 46          1098                      .dw     exe_input
152A-69 6E 70 75 
     74 00          1099                      .az     "input"
1530-15 38          1100      .if             .dw     :bottom
1532-02             1101                      .db     2
1533-14 83          1102                      .dw     exe_if
1535-69 66 00       1103                      .az     "if"
1538-00 00          1104      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
153A-               1105
153A-               1106
153A-               1107      ; -----------------------------------------------------------------------
153A-               1108      ; エラーメッセージを表示する
153A-               1109      ; Write Error Messege
153A-               1110      ;【引数】A: エラーコード
153A-               1111      ;【使用】A, B, X
153A-               1112      ;【返値】なし
153A-               1113      ; -----------------------------------------------------------------------
153A-               1114      write_err_msg:
153A-7D 00 39       1115 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
153D-27 03          1116 ( 3)         beq     :1
153F-BD FF B2       1117 ( 6)         jsr     write_crlf
1542-CE 15 5B       1118 ( 3) .1      ldx     #ERRMSG
1545-BD FF AF       1119 ( 6)         jsr     write_line
1548-16             1120 ( 1)         tab
1549-CE 15 63       1121 ( 3)         ldx     #ERRCODE
154C-3A             1122 ( 1)         abx
154D-EE 00          1123 ( 5)         ldx     0,x
154F-BD FF AF       1124 ( 6)         jsr     write_line
1552-BD FF B2       1125 ( 6)         jsr     write_crlf
1555-DE 80          1126 ( 4)         ldx     <StackPointer
1557-35             1127 ( 1)         txs
1558-7E 10 0E       1128 ( 3)         jmp     tb_main
155B-               1129
155B-45 52 52 4F 
     52 3A 20 00    1130      ERRMSG  .az     "ERROR: "
1563-15 73          1131      ERRCODE .dw     .err00
1565-15 80          1132              .dw     .err02
1567-15 93          1133              .dw     .err04
1569-15 A6          1134              .dw     .err06
156B-15 BF          1135              .dw     .err08
156D-15 CB          1136              .dw     .err10
156F-15 E1          1137              .dw     .err12
1571-15 F5          1138              .dw     .err14
1573-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1139      .err00  .az     "Syntax error"
1580-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1140      .err02  .az     "Out of range value"
1593-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1141      .err04  .az     "Illegal expression"
15A6-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1142      .err06  .az     "Calculate stack overflow"
15BF-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1143      .err08  .az     "Zero Divide"
15CB-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1144      .err10  .az     "Print statement error"
15E1-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1145      .err12  .az     "Invalid line number"
15F5-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1146      .err14  .az     "Memory size over"
1606-               1147
1606-               1148
1606-               1149      ; ***********************************************************************
1606-               1150      ;   デバック用ルーチン Debugging routines
1606-               1151      ; ***********************************************************************
1606-               1152      ; -----------------------------------------------------------------------
1606-               1153      ; ユーザーレジスタを表示する
1606-               1154      ; Display user registers
1606-               1155      ; -----------------------------------------------------------------------
1606-36             1156 ( 4) PUTUR:  psha
1607-37             1157 ( 4)         pshb
1608-3C             1158 ( 5)         pshx
1609-CE 16 3C       1159 ( 3)         ldx     #:MSGUR0
160C-BD FF AF       1160 ( 6)         jsr     write_line
160F-DC 9D          1161 ( 4)         ldd     <UR0
1611-BD FF BB       1162 ( 6)         jsr     write_word
1614-CE 16 41       1163 ( 3)         ldx     #:MSGUR1
1617-BD FF AF       1164 ( 6)         jsr     write_line
161A-DC 9F          1165 ( 4)         ldd     <UR1
161C-BD FF BB       1166 ( 6)         jsr     write_word
161F-CE 16 47       1167 ( 3)         ldx     #:MSGUR2
1622-BD FF AF       1168 ( 6)         jsr     write_line
1625-DC A1          1169 ( 4)         ldd     <UR2
1627-BD FF BB       1170 ( 6)         jsr     write_word
162A-CE 16 4D       1171 ( 3)         ldx     #:MSGUR3
162D-BD FF AF       1172 ( 6)         jsr     write_line
1630-DC A3          1173 ( 4)         ldd     <UR3
1632-BD FF BB       1174 ( 6)         jsr     write_word
1635-BD FF B2       1175 ( 6)         jsr     write_crlf
1638-38             1176 ( 4)         pulx
1639-33             1177 ( 3)         pulb
163A-32             1178 ( 3)         pula
163B-39             1179 ( 5)         rts
163C-55 52 30 3D 
     00             1180      .MSGUR0          .az     "UR0="
1641-20 55 52 31 
     3D 00          1181      .MSGUR1          .az     " UR1="
1647-20 55 52 32 
     3D 00          1182      .MSGUR2          .az     " UR2="
164D-20 55 52 33 
     3D 00          1183      .MSGUR3          .az     " UR3="
