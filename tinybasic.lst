0000-                 14
0000-                 15      ; ***********************************************************************
0000-                 16      ;   HD6303R Internal Registers
0000-                 17      ; ***********************************************************************
0000-                 18              .in     ./HD6303R_chip.def
0000-            I     1      ; *
0000-            I     2      ; * HD6303R Internal Registers
0000-            I     3      ; *
0000-            I     4      DDR1    .eq     $00             ; Port1 Data Direction Register
0001-            I     5      DDR2    .eq     $01             ; Port2 Data Direction Register
0002-            I     6      PORT1   .eq     $02             ; Port1 Data Register
0003-            I     7      PORT2   .eq     $03             ; Port2 Data Register
0008-            I     8      TCSR    .eq     $08             ; Timer Control and Status Register
0009-            I     9      FRC     .eq     $09             ; Free Running Counter
0009-            I    10      FRCH    .eq     $09             ; Free Running Counter (High Byte)
000A-            I    11      FRCL    .eq     $0a             ; Free Running Counter (Low Byte)
000B-            I    12      OCR     .eq     $0b             ; Output Compare Register
000B-            I    13      OCRH    .eq     $0b             ; Output Compare Register (High Byte)
000C-            I    14      OCRL    .eq     $0c             ; Output Compare Register (Low Byte)
000D-            I    15      ICR     .eq     $0d             ; Input Capture Register
000D-            I    16      ICRH    .eq     $0d             ; Input Capture Register (High Byte)
000E-            I    17      ICRL    .eq     $0e             ; Intput Capture Register (Low Byte)
0010-            I    18      RMCR    .eq     $10             ; Rate and Mode Control Register
0011-            I    19      TRCSR   .eq     $11             ; Transmit/Receive Control and Status Register
0012-            I    20      RDR     .eq     $12             ; Receive Data Register
0013-            I    21      TDR     .eq     $13             ; Transmit Data Register
0014-            I    22      RAMCR   .eq     $14             ; RAM Control Register
0000-            I    23
0000-            I    24      ; *
0000-            I    25      ; * Timer Control and Status Register
0000-            I    26      ; *
0001-            I    27      OLVL    .eq     $01             ; bit 0 :Output Level
0002-            I    28      IEDG    .eq     $02             ; bit 1 :Input Edge
0004-            I    29      ETOI    .eq     $04             ; bit 2 :Enable Timer Overflow Interrupt
0008-            I    30      EOCI    .eq     $08             ; bit 3 :Enable Output Compare Interrupt
0010-            I    31      EICI    .eq     $10             ; bit 4 :Enable Input Capture Interrupt
0020-            I    32      TOF     .eq     $20             ; bit 5 :Timer Overflow Flag
0040-            I    33      OCF     .eq     $40             ; bit 6 :Output Compare Flag
0080-            I    34      ICF     .eq     $80             ; bit 7 :Input Capture Flag
0000-            I    35
0000-            I    36      ; *
0000-            I    37      ; * Rate and Mode Control Register
0000-            I    38      ; *
0000-            I    39      ; Speed select
0000-            I    40      E16     .eq     $00             ; E/16
0001-            I    41      E128    .eq     $01             ; E/128
0002-            I    42      E1024   .eq     $02             ; E/1024
0003-            I    43      E4096   .eq     $03             ; E/4096
0000-            I    44      ; Clock Control/Format Select
0004-            I    45      NRZIN   .eq     $04             ; Format:NRZ Sorce:Internal Port2:Not use
0008-            I    46      NRZIO   .eq     $08             ; Format:NRZ Sorce:Internal Port2:Output
000C-            I    47      NRZEI   .eq     $0c             ; Format:NRZ Sorce:External Port2:Input
0000-            I    48
0000-            I    49      ; *
0000-            I    50      ; * Transmit/Receive Control and Status Register
0000-            I    51      ; *
0001-            I    52      WU      .eq     $01             ; bit 0 :Wake Up
0002-            I    53      TE      .eq     $02             ; bit 1 :Transmit Enable
0004-            I    54      TIE     .eq     $04             ; bit 2 :Transmit Interrupt Enable
0008-            I    55      RE      .eq     $08             ; bit 3 :Recevie Enable
0010-            I    56      RIE     .eq     $10             ; bit 4 :Recevie Interrupt Enable
0020-            I    57      TDRE    .eq     $20             ; bit 5 :Transmit Data Register Empty
0040-            I    58      ORFE    .eq     $40             ; bit 6 :Over Run Framing Error
0080-            I    59      RDRF    .eq     $80             ; bit 7 :Receive Data Register Full
0000-            I    60
0000-            I    61      ; *
0000-            I    62      ; * RAM Control Register
0000-            I    63      ; *
0040-            I    64      RAME    .eq     $40             ; bit 6 :RAM Enable
0080-            I    65      STBYPWR .eq     $80             ; bit 7 :Standby Bit
0000-                 19
0000-                 20      ; ***********************************************************************
0000-                 21      ;   ジャンプテーブル Service routine jump table
0000-                 22      ; ***********************************************************************
FFA0-                 23      init_sbc6303            .eq     $ffa0
FFA3-                 24      mon_main                .eq     $ffa3
FFA6-                 25      read_char               .eq     $ffa6
FFA9-                 26      read_line               .eq     $ffa9
FFAC-                 27      write_char              .eq     $ffac
FFAF-                 28      write_line              .eq     $ffaf
FFB2-                 29      write_crlf              .eq     $ffb2
FFB5-                 30      write_space             .eq     $ffb5
FFB8-                 31      write_byte              .eq     $ffb8
FFBB-                 32      write_word              .eq     $ffbb
FFBE-                 33      is_alphabetic_char      .eq     $ffbe
FFC1-                 34      is_decimal_char         .eq     $ffc1
FFC4-                 35      is_hexadecimal_char     .eq     $ffc4
0000-                 36
0000-                 37      ; ***********************************************************************
0000-                 38      ;   定数 Constants
0000-                 39      ; ***********************************************************************
0000-                 40      NUL             .eq     $00     ; NUL
0008-                 41      BS              .eq     $08     ; Backspace
0020-                 42      SPACE           .eq     $20     ; Space
000D-                 43      CR              .eq     $0d     ; Carriage Return
000A-                 44      LF              .eq     $0a     ; Line Feed
007F-                 45      DEL             .eq     $7f     ; Delete
0011-                 46      XON             .eq     $11     ; DC1
0013-                 47      XOFF            .eq     $13     ; DC3
0000-                 48
0020-                 49      RAM_START       .eq     $0020
1FFF-                 50      RAM_END         .eq     $1fff
E000-                 51      ROM_START       .eq     $e000
FFFF-                 52      ROM_END         .eq     $ffff
1000-                 53      PROGRAM_START   .eq     $1000   ; プログラム開始アドレス
0FFF-                 54      STACK           .eq     $0fff
0000-                 55
0400-                 56      USER_AREA_TOP   .eq     $0400   ; ユーザーエリア開始アドレス
0DFD-                 57      USER_AREA_BTM   .eq     $0dff-2 ; ユーザーエリア終了アドレス
0000-                 58
0000-                 59      ; ***********************************************************************
0000-                 60      ;   システム変数 System variables
0000-                 61      ; ***********************************************************************
0000-                 62              .sm     RAM
0020-                 63              .or     $20
0020-                 64
0020-                 65      ; Interrupt Vector Hooking
0020-                 66      VEC_TRAP        .bs     3
0023-                 67      VEC_SCI         .bs     3
0026-                 68      VEC_TOF         .bs     3
0029-                 69      VEC_OCF         .bs     3
002C-                 70      VEC_ICF         .bs     3
002F-                 71      VEC_IRQ         .bs     3
0032-                 72      VEC_SWI         .bs     3
0035-                 73      VEC_NMI         .bs     3
0038-                 74      BreakPointFlag  .bs     1
0039-                 75      TabCount        .bs     1       ; タブ用の文字数カウンタ
003A-                 76      RxBffrQty       .bs     1       ; 受信バッファデータ数
003B-                 77      RxBffrReadPtr   .bs     2       ; 受信バッファ読み込みポインタ
003D-                 78      RxBffrWritePtr  .bs     2       ; 受信バッファ書き込みポインタ
003F-                 79      ; General-Purpose Registers
003F-                 80      R0              .bs     2
0041-                 81      R1              .bs     2
0043-                 82
0043-                 83      ; ***********************************************************************
0043-                 84      ;   システムワークエリア System work area
0043-                 85      ; ***********************************************************************
0043-                 86              .sm     RAM
0100-                 87              .or     $0100
0100-                 88      ; 各種バッファ
0100-                 89      Rx_BUFFER       .bs     64      ; 受信バッファ（$0100-$013f）
013F-                 90      Rx_BUFFER_END   .eq     *-1
0040-                 91      Rx_BFFR_SIZE    .eq     Rx_BUFFER_END-Rx_BUFFER+1
0140-                 92      TEXT_BFFR       .bs     73      ; テキストバッファ（$0140-$188: 73byte）
0188-                 93      TEXT_BFFR_END   .eq     *-1
0049-                 94      TEXT_BFFR_SIZE  .eq     TEXT_BFFR_END-TEXT_BFFR+1
0189-                 95
0189-                 96      ; ***********************************************************************
0189-                 97      ;   変数 Variables
0189-                 98      ; ***********************************************************************
0189-                 99              .sm     RAM
0080-                100              .or     $80
0080-                101
0080-                102      StackPointer    .bs     2       ; スタックポインタ初期値の退避用
0082-                103      CStackPtr       .bs     2       ; 計算スタック（Calculate stack）ポインタ
0084-                104      SignFlag        .bs     1       ; 符号フラグ '+' = 0, '-' = 1
0085-                105      QuoSignFlag     .bs     1       ; 商（Quotient）の符号フラグ '+' = 0, '-' = 1
0086-                106      RemSignFlag     .bs     1       ; 剰余（Remainder）の符号フラグ '+' = 0, '-' = 1
0087-                107      Divisor         .bs     2       ; 除数
0089-                108      Remainder       .bs     2       ; 剰余
008B-                109      VariableAddr    .bs     2       ; 変数のアドレス
008D-                110      ExePointer      .bs     2       ; 実行位置（Execute address）ポインタ
008F-                111      NewLineFlag     .bs     1       ; 改行フラグ（print文） 0 = OFF, 1以上 = ON
0090-                112      Source          .bs     2       ; 転送元アドレス
0092-                113      Destination     .bs     2       ; 転送先アドレス
0094-                114      Bytes           .bs     2       ; 転送バイト数
0096-                115      LineNumber      .bs     2       ; 行番号
0098-                116      LineLength      .bs     2       ; 行の長さ
009A-                117      PrgmEndAddr     .bs     2       ; BASICプログラムの最終アドレス
009C-                118      ExeStateFlag    .bs     1       ; 実行状態フラグ 0 = run, 1以上 = direct
009D-                119      ExeLineAddr     .bs     2       ; 実行中の行の先頭アドレス
009F-                120      ModuloMode      .bs     1       ; 剰余演算フラグ 0 = tranc, 1以上 = floor
00A0-                121      ToSubFlag       .bs     1       ; 分岐モードフラグ 0 = goto, 1 = gosub
00A1-                122      SStackPtr       .bs     2       ; サブルーチンスタック（Subroutine stack）ポインタ
00A3-                123      ArrayAddr       .bs     2       ; 配列変数の先頭アドレス
00A5-                124      MaxSubscript    .bs     2       ; 配列の最大添字数
00A7-                125
00A7-                126      ; General-Purpose Registers
00A7-                127      UR0             *
00A7-                128      UR0H            .bs     1
00A8-                129      UR0L            .bs     1
00A9-                130      UR1             *
00A9-                131      UR1H            .bs     1
00AA-                132      UR1L            .bs     1
00AB-                133      UR2             *
00AB-                134      UR2H            .bs     1
00AC-                135      UR2L            .bs     1
00AD-                136      UR3             *
00AD-                137      UR3H            .bs     1
00AE-                138      UR3L            .bs     1
00AF-                139      ; Work area
00AF-                140      COMPARE         .bs     6       ; 文字列比較用バッファ
00B5-                141
00B5-                142      ; ***********************************************************************
00B5-                143      ;   ワークエリア work area
00B5-                144      ; ***********************************************************************
00B5-                145              .sm     RAM
0200-                146              .or     $0200
0200-                147      CSTACK          .bs     40      ; 計算スタック (Calculate stack)
0227-                148      CSTACK_BTM      .eq     *-1
0028-                149      CSTACK_SIZE     .eq     CSTACK_BTM-CSTACK+1
0228-                150      SSTACK          .bs     40      ; サブルーチンスタック (Subroutine stack)
024F-                151      SSTACK_BTM      .eq     *-1
0028-                152      SSTACK_SIZE     .eq     SSTACK_BTM-SSTACK+1
02C2-                153              .or     $02c2
02C2-                154      VARIABLE        .bs     52      ; 変数26文字 ($01c2-01f5)
02F5-                155      VARIABLE_END    .eq     *-1
0034-                156      VARIABLE_SIZE   .eq     VARIABLE_END-VARIABLE+1
02F6-                157
02F6-                158      ; ***********************************************************************
02F6-                159      ;   Program Start
02F6-                160      ; ***********************************************************************
0000-                161              .sm     CODE
1000-                162              .or     PROGRAM_START
1000-                163
1000-                164      init_tinybasic:
1000-30              165 ( 1)         tsx
1001-DF 80           166 ( 4)         stx     <StackPointer
1003-                167
1003-                168
1003-                169      cold_start:
1003-                170            ; // プログラムエリアの初期化
1003-CE 04 00        171 ( 3)         ldx     #USER_AREA_TOP
1006-DF 9A           172 ( 4)         stx     <PrgmEndAddr    ; BASICプログラムエリア開始アドレス = 終了アドレス
1008-4F              173 ( 1)         clra
1009-5F              174 ( 1)         clrb
100A-ED 00           175 ( 5)         std     0,x             ; プログラムエリアの先頭を終端行（$0000）にする
100C-97 98           176 ( 3)         staa    <LineLength     ; 行の長さの上位バイトをゼロにする
100E-                177            ; // 各種フラグの初期化
100E-97 9F           178 ( 3)         staa    <ModuloMode     ; 剰余演算をtrunc（0への切捨て除算）にする
1010-97 A0           179 ( 3)         staa    <ToSubFlag      ; 分岐モードを0 = gotoにする
1012-                180            ; // 変数領域の初期化
1012-CE 02 C2        181 ( 3)         ldx     #VARIABLE
1015-ED 00           182 ( 5) .loop   std     0,x
1017-08              183 ( 1)         inx
1018-08              184 ( 1)         inx
1019-8C 02 F6        185 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
101C-26 F7           186 ( 3)         bne     :loop
101E-                187            ; // 配列変数の初期化
101E-CC 04 02        188 ( 3)         ldd     #USER_AREA_TOP+2
1021-DD A3           189 ( 4)         std     <ArrayAddr
1023-CC 09 FF        190 ( 3)         ldd     #USER_AREA_BTM+2-USER_AREA_TOP
1026-04              191 ( 1)         lsrd
1027-DD A5           192 ( 4)         std     <MaxSubscript
1029-                193            ; // スタックポインタの初期化
1029-CE 02 50        194 ( 3)         ldx     #SSTACK_BTM+1
102C-DF A1           195 ( 4)         stx     <SStackPtr
102E-                196
102E-                197
102E-                198      tb_main:
102E-72 01 9C        199 ( 6)         oim     #1,<ExeStateFlag ; 実行状態フラグをdirectに設定
1031-C6 3E           200 ( 2)         ldab    #'>'
1033-BD FF AC        201 ( 6)         jsr     write_char
1036-BD FF A9        202 ( 6)         jsr     read_line
1039-CE 01 40        203 ( 3)         ldx     #TEXT_BFFR      ; 実行位置アドレスをセット
103C-                204            ; // 行番号判定
103C-BD 14 8E        205 ( 6)         jsr     get_int_from_decimal
103F-24 0A           206 ( 3)         bcc     execute_mode    ; 先頭が数値でなければ実行モード
1041-83 00 00        207 ( 3)         subd    #0
1044-2E 08           208 ( 3)         bgt     edit_mode       ; 数値が1以上であれば編集モード
1046-86 0C           209 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1048-7E 18 56        210 ( 3)         jmp     write_err_msg
104B-                211
104B-                212      ; 実行モード（ダイレクトモード）
104B-                213      execute_mode:
104B-7E 11 84        214 ( 3)         jmp     exe_line
104E-                215
104E-                216      ; 行編集モード
104E-                217      ; 空行か否か、空行でなければ同じ行番号か否かで処理を振り分ける
104E-                218      edit_mode:
104E-DF 8D           219 ( 4)         stx     <ExePointer     ; バッファアドレスを保存（行番号の直後を指している）
1050-DD 96           220 ( 4)         std     <LineNumber     ; 行番号を保存
1052-                221            ; // 空行チェック
1052-BD 15 57        222 ( 6)         jsr     skip_space
1055-26 02           223 ( 3)         bne     :1
1057-20 1B           224 ( 3)         bra     delete_line     ; 空行だったら削除ルーチンへ
1059-                225      .1    ; // 入力行の長さチェック（Aレジスタに文字数）
1059-DE 8D           226 ( 4)         ldx     <ExePointer     ; バッファアドレスを復帰
105B-86 04           227 ( 2)         ldaa    #4              ; 行の長さの初期値（2+1+n+1, n=0）
105D-E6 00           228 ( 4) .loop   ldab    0,x
105F-27 04           229 ( 3)         beq     :2
1061-4C              230 ( 1)         inca                    ; 行の長さを+1
1062-08              231 ( 1)         inx                     ; バッファアドレスを+1
1063-20 F8           232 ( 3)         bra     :loop
1065-97 99           233 ( 3) .2      staa    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存
1067-                234            ; // 同じ行があるかどうか確認
1067-CE 04 00        235 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
106A-BD 15 BB        236 ( 6)         jsr     scan_line_num   ; 行番号検索
106D-DF 9D           237 ( 4)         stx     <ExeLineAddr    ; 検索した行アドレスをExeLineAddrに退避しておく
106F-24 29           238 ( 3)         bcc     not_same_line_num
1071-7E 10 FA        239 ( 3)         jmp     same_line_num
1074-                240
1074-                241      ; 一行削除
1074-                242      delete_line:
1074-CE 04 00        243 ( 3)         ldx     #USER_AREA_TOP  ; X:プログラム開始アドレス
1077-BD 15 BB        244 ( 6)         jsr     scan_line_num   ; 行番号検索
107A-24 1B           245 ( 3)         bcc     :end            ; 同じ行がなければ何もしない
107C-                246            ; // 転送先アドレスの設定（既存の行の先頭アドレス）
107C-DF 92           247 ( 4)         stx     <Destination
107E-                248            ; // 転送元アドレスの設定（次の行の先頭アドレス）
107E-E6 02           249 ( 4)         ldab    2,x
1080-D7 99           250 ( 3)         stab    <LineLength+1   ; 行の長さをLineLengthの下位バイトに保存しておく
1082-3A              251 ( 1)         abx
1083-DF 90           252 ( 4)         stx     <Source
1085-                253            ; // 転送バイト数の設定（プログラム終端アドレス - 次の行の先頭アドレス + 2）
1085-DC 9A           254 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1087-93 90           255 ( 4)         subd    <Source         ; - 次の行の先頭アドレス
1089-C3 00 02        256 ( 3)         addd    #2              ; + 2
108C-DD 94           257 ( 4)         std     <Bytes
108E-                258            ; // ブロック転送
108E-BD 17 36        259 ( 6)         jsr     mem_move
1091-                260            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス - 行の長さ）
1091-DC 9A           261 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1093-93 98           262 ( 4)         subd    <LineLength     ; - 行の長さ
1095-DD 9A           263 ( 4)         std     <PrgmEndAddr
1097-7E 11 52        264 ( 3) .end    jmp     array_index
109A-                265
109A-                266      ; 同じ行番号がなかった場合の処理
109A-                267      not_same_line_num:
109A-                268            ; // D:次に大きな行番号 X:次に大きな行の先頭アドレス
109A-83 00 00        269 ( 3)         subd    #0              ; tstd
109D-27 22           270 ( 3)         beq     :add            ; 最終行より後ろ（D=$0000）だったら入力行挿入
109F-                271            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
109F-DC 9A           272 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10A1-D3 98           273 ( 4)         addd    <LineLength     ; + 行の長さ
10A3-8D 48           274 ( 5)         bsr     check_pgrm_end
10A5-DD 9A           275 ( 4)         std     <PrgmEndAddr
10A7-                276            ; // 転送元アドレスの設定（次に大きな行の先頭アドレス）
10A7-DF 90           277 ( 4)         stx     <Source
10A9-                278            ; // 転送先アドレスの設定（次に大きな行の先頭アドレス + 行の長さ）
10A9-D6 99           279 ( 3)         ldab    <LineLength+1   ; 行の長さ
10AB-3A              280 ( 1)         abx                     ; + 次に大きな行の先頭アドレス
10AC-DF 92           281 ( 4)         stx     <Destination
10AE-                282            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
10AE-DC 9A           283 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10B0-93 90           284 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
10B2-C3 00 02        285 ( 3)         addd    #2              ; + 2
10B5-DD 94           286 ( 4)         std     <Bytes
10B7-                287            ; // ブロック転送
10B7-BD 17 36        288 ( 6)         jsr     mem_move
10BA-                289            ; // 入力行の挿入
10BA-DE 9D           290 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
10BC-8D 16           291 ( 5)         bsr     insert_new_line
10BE-7E 11 52        292 ( 3)         jmp     array_index
10C1-                293      .add
10C1-                294            ; // D:$0000 X:プログラム終端アドレス
10C1-                295            ; // 新しいプログラム終端アドレスの設定（プログラム終端アドレス + 行の長さ）
10C1-DC 9A           296 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
10C3-D3 98           297 ( 4)         addd    <LineLength     ; + 行の長さ
10C5-8D 26           298 ( 5)         bsr     check_pgrm_end
10C7-DD 9A           299 ( 4)         std     <PrgmEndAddr
10C9-                300            ; // 入力行の挿入
10C9-8D 09           301 ( 5)         bsr     insert_new_line
10CB-                302            ; // 終端行の挿入
10CB-DE 9A           303 ( 4)         ldx     <PrgmEndAddr
10CD-4F              304 ( 1)         clra
10CE-5F              305 ( 1)         clrb
10CF-ED 00           306 ( 5)         std     0,x             ; プログラムの最終アドレスに$0000を加える
10D1-7E 11 52        307 ( 3)         jmp     array_index
10D4-                308
10D4-                309      ; 入力行の転送
10D4-                310      insert_new_line:
10D4-DC 96           311 ( 4)         ldd     <LineNumber     ; 行番号を転送
10D6-ED 00           312 ( 5)         std     0,x
10D8-08              313 ( 1)         inx
10D9-08              314 ( 1)         inx
10DA-D6 99           315 ( 3)         ldab    <LineLength+1   ; 行の長さを転送
10DC-E7 00           316 ( 4)         stab    0,x
10DE-08              317 ( 1)         inx
10DF-                318            ; // 転送先アドレスの設定（現在の位置）
10DF-DF 92           319 ( 4)         stx     <Destination
10E1-                320            ; // 転送バイト数の設定（行の長さ - 3（行番号 - 長さ））
10E1-4F              321 ( 1)         clra                    ; 行の長さ（A=0,B=下位8bit）
10E2-C0 03           322 ( 2)         subb    #3              ; - 3
10E4-DD 94           323 ( 4)         std     <Bytes
10E6-                324            ; // 転送元アドレスの設定（入力された行）
10E6-DC 8D           325 ( 4)         ldd     <ExePointer     ; バッファアドレスを復帰（行番号の直後を指している）
10E8-DD 90           326 ( 4)         std     <Source
10EA-                327            ; // ブロック転送
10EA-7E 17 36        328 ( 3)         jmp     mem_move        ; 飛び先でrts
10ED-                329
10ED-                330      ; プログラムエリアを超えていないか確認
10ED-                331      check_pgrm_end:
10ED-18              332 ( 2)         xgdx
10EE-8C 0D FD        333 ( 3)         cpx     #USER_AREA_BTM
10F1-18              334 ( 2)         xgdx
10F2-24 01           335 ( 3)         bcc     :err14
10F4-39              336 ( 5)         rts
10F5-86 0E           337 ( 2) .err14  ldaa    #14              ; "Memory size over"
10F7-7E 18 56        338 ( 3)         jmp     write_err_msg
10FA-                339
10FA-                340      ; 同じ行番号があった場合、既存の行との長さの差で処理を振り分ける
10FA-                341      same_line_num:
10FA-                342            ; // D:行番号 X:既存の行の開始アドレス
10FA-96 99           343 ( 3)         ldaa    <LineLength+1   ; 入力行の長さを取得
10FC-A0 02           344 ( 4)         suba    2,x             ; **Aレジスタ** = 入力行の長さ - 既存行の長さ
10FE-2B 2D           345 ( 3)         bmi     short_length    ; 入力行の長さ < 既存行の長さ
1100-27 26           346 ( 3)         beq     same_length     ; 入力行の長さ = 既存行の長さ
1102-                347
1102-                348      ; 入力行が既存の行より長い場合
1102-                349      long_length:                    ; 入力行の長さ > 既存行の長さ
1102-                350            ; // 転送元アドレスの設定（次の行の先頭アドレス）
1102-E6 02           351 ( 4)         ldab    2,x
1104-3A              352 ( 1)         abx
1105-DF 90           353 ( 4)         stx     <Source
1107-                354            ; // 転送先アドレスの設定（次の行の先頭アドレス + 入力行の長さ - 既存行の長さ）
1107-16              355 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
1108-4F              356 ( 1)         clra
1109-DD A9           357 ( 4)         std     <UR1            ; 入力行の長さ - 既存行の長さを後で使うためにUR1に保存
110B-3A              358 ( 1)         abx                     ; 次の行の先頭アドレス + （入力行の長さ - 既存行の長さ）
110C-DF 92           359 ( 4)         stx     <Destination
110E-                360            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
110E-DC 9A           361 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1110-93 90           362 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1112-C3 00 02        363 ( 3)         addd    #2              ; + 2
1115-DD 94           364 ( 4)         std     <Bytes
1117-                365            ; // 新しいプログラム終端アドレスの設定
1117-                366            ; // （プログラム終端アドレス + 入力行の長さ - 既存行の長さ）
1117-DC 9A           367 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1119-D3 A9           368 ( 4)         addd    <UR1            ; + 入力行の長さ - 既存行の長さ
111B-8D D0           369 ( 5)         bsr     check_pgrm_end
111D-DD 9A           370 ( 4)         std     <PrgmEndAddr
111F-                371            ; // ブロック転送
111F-BD 17 36        372 ( 6)         jsr     mem_move
1122-                373            ; // 入力行の挿入
1122-DE 9D           374 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1124-8D AE           375 ( 5)         bsr     insert_new_line
1126-20 2A           376 ( 3)         bra     array_index
1128-                377
1128-                378      ; 入力行と既存の行が同じ長さの場合
1128-                379      same_length:
1128-8D AA           380 ( 5)         bsr     insert_new_line
112A-7E 10 2E        381 ( 3)         jmp     tb_main
112D-                382
112D-                383      ; 入力行が既存の行より短い場合
112D-                384      short_Length:
112D-                385            ; // 転送元アドレスの設定（次の行の先頭アドレス）
112D-E6 02           386 ( 4)         ldab    2,x
112F-3A              387 ( 1)         abx
1130-DF 90           388 ( 4)         stx     <Source
1132-                389            ; // 転送先アドレスの設定（次の行の先頭アドレス - 既存行の長さ + 入力行の長さ）
1132-16              390 ( 1)         tab                     ; B <- A（入力行の長さ - 既存行の長さ）
1133-50              391 ( 1)         negb                    ; 絶対値にする
1134-4F              392 ( 1)         clra
1135-DD A9           393 ( 4)         std     <UR1            ; 既存行の長さ - 入力行の長さ
1137-18              394 ( 2)         xgdx
1138-93 A9           395 ( 4)         subd    <UR1            ; 次の行の先頭アドレス - （既存行の長さ - 入力行の長さ）
113A-DD 92           396 ( 4)         std     <Destination
113C-                397            ; // 転送バイト数の設定（プログラム終端アドレス - 次に大きな行の先頭アドレス + 2）
113C-DC 9A           398 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
113E-93 90           399 ( 4)         subd    <Source         ; - 次に大きな行の先頭アドレス
1140-C3 00 02        400 ( 3)         addd    #2              ; + 2
1143-DD 94           401 ( 4)         std     <Bytes
1145-                402            ; // ブロック転送
1145-BD 17 36        403 ( 6)         jsr     mem_move
1148-                404            ; // 新しいプログラム終端アドレスの設定
1148-                405            ; // （プログラム終端アドレス - 既存行の長さ + 入力行の長さ）
1148-DC 9A           406 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
114A-93 A9           407 ( 4)         subd    <UR1            ; - （既存行の長さ - 入力行の長さ）
114C-DD 9A           408 ( 4)         std     <PrgmEndAddr
114E-                409            ; // 入力行の挿入
114E-DE 9D           410 ( 4)         ldx     <ExeLineAddr    ; 検索した行アドレスを復帰
1150-8D 82           411 ( 5)         bsr     insert_new_line
1152-                412
1152-                413      array_index:
1152-DC 9A           414 ( 4)         ldd     <PrgmEndAddr    ; プログラム終端アドレス
1154-C3 00 02        415 ( 3)         addd    #2              ; + 2
1157-DD A3           416 ( 4)         std     <ArrayAddr      ; 配列変数の先頭アドレス
1159-CC 0D FF        417 ( 3)         ldd     #USER_AREA_BTM+2
115C-93 A3           418 ( 4)         subd    <ArrayAddr
115E-04              419 ( 1)         lsrd
115F-DD A5           420 ( 4)         std     <MaxSubscript
1161-7E 10 2E        421 ( 3)         jmp     tb_main
1164-                422
1164-                423
1164-                424      ; -----------------------------------------------------------------------
1164-                425      ; マルチステートメントかどうか判定（is_multiはexe_lineの補助ルーチン）
1164-                426      ; Is a multi statement mark?
1164-                427      ;【引数】X:実行位置アドレス
1164-                428      ;【使用】B, X
1164-                429      ;【返値】なし
1164-                430      ; -----------------------------------------------------------------------
1164-                431      is_multi:
1164-BD 15 57        432 ( 6)         jsr     skip_space
1167-27 0B           433 ( 3)         beq     eol_process
1169-C1 3A           434 ( 2)         cmpb    #':'
116B-26 03           435 ( 3)         bne     :err00
116D-08              436 ( 1)         inx
116E-20 14           437 ( 3)         bra     exe_line
1170-4F              438 ( 1) .err00  clra                    ; "Syntax error"
1171-7E 18 56        439 ( 3)         jmp     write_err_msg
1174-                440
1174-                441
1174-                442      ; -----------------------------------------------------------------------
1174-                443      ; 行末の処理（eol_processはexe_lineの補助ルーチン）
1174-                444      ;  - directモードであればそのまま終了
1174-                445      ;  - runモードであれば次の行のポインタを設定してrts
1174-                446      ; End-of-line processing
1174-                447      ;  - If in direct mode, terminate execution
1174-                448      ;  - If run mode, set the pointer to the next line and rts
1174-                449      ;【引数】なし
1174-                450      ;【使用】A, B, X
1174-                451      ;【返値】なし
1174-                452      ; -----------------------------------------------------------------------
1174-                453      eol_process:
1174-                454            ; // runモードであれば次の行のポインタを設定してrts
1174-7D 00 9C        455 ( 4)         tst     <ExeStateFlag
1177-26 08           456 ( 3)         bne     :end
1179-DE 9D           457 ( 4)         ldx     <ExeLineAddr    ; 実行中の行の先頭アドレスを復帰
117B-E6 02           458 ( 4)         ldab    2,x             ; 行の長さを取得
117D-3A              459 ( 1)         abx                     ; 次の行の先頭アドレスを取得
117E-DF 9D           460 ( 4)         stx     <ExeLineAddr    ; 次の行の先頭アドレスを保存
1180-39              461 ( 5)         rts
1181-7E 10 2E        462 ( 3) .end    jmp     tb_main         ; directモードであればそのまま終了
1184-                463
1184-                464
1184-                465      ; -----------------------------------------------------------------------
1184-                466      ; 一行実行
1184-                467      ; Execute one line
1184-                468      ;【引数】X:実行位置アドレス
1184-                469      ;【使用】A, B, X
1184-                470      ;【返値】なし
1184-                471      ; -----------------------------------------------------------------------
1184-                472      exe_line:
1184-BD 15 57        473 ( 6)         jsr     skip_space
1187-27 EB           474 ( 3)         beq     eol_process     ; 終端文字（$00）ならば終了処理
1189-                475            ; // 配列変数のチェック
1189-C1 40           476 ( 2)         cmpb    #'@'
118B-26 1B           477 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
118D-E6 01           478 ( 4)         ldab    1,x
118F-C1 28           479 ( 2)         cmpb    #'('            ; 直後の文字は'('？
1191-26 4A           480 ( 3)         bne     :err00          ; No. "Syntax error"
1193-08              481 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
1194-08              482 ( 1)         inx
1195-BD 11 E6        483 ( 6)         jsr     eval_expression ; 添字を取得する
1198-24 47           484 ( 3)         bcc     :err04
119A-                485            ; // ')'の確認
119A-37              486 ( 4)         pshb                    ; 添字の下位8bitを退避
119B-E6 00           487 ( 4)         ldab    0,x
119D-C1 29           488 ( 2)         cmpb    #')'
119F-26 3C           489 ( 3)         bne     :err00
11A1-33              490 ( 3)         pulb                    ; 添字の下位8bitを復帰
11A2-08              491 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
11A3-BD 15 94        492 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
11A6-20 08           493 ( 3)         bra     :let
11A8-BD 15 42        494 ( 6) .var    jsr     is_variable     ; 変数か？
11AB-24 12           495 ( 3)         bcc     :cmd            ; No. テーブル検索へ
11AD-86 02           496 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
11AF-58              497 ( 1)         aslb                    ; B = 変数領域の下位バイト
11B0-DD 8B           498 ( 4) .let    std     <VariableAddr   ; 変数アドレスを保存
11B2-                499            ; // 代入文のチェック
11B2-BD 15 57        500 ( 6)         jsr     skip_space      ; Yes. 代入文か？
11B5-C1 3D           501 ( 2)         cmpb    #'='
11B7-26 24           502 ( 3)         bne     :err00          ; No. エラー処理へ
11B9-08              503 ( 1)         inx                     ; Yes. 代入実行
11BA-BD 15 A7        504 ( 6)         jsr     assign_to_var
11BD-20 A5           505 ( 3)         bra     is_multi
11BF-                506            ; // コマンド・ステートメントのチェック
11BF-EC 00           507 ( 5) .cmd    ldd     0,x             ; 6文字を文字列比較用バッファに転送しておく
11C1-DD AF           508 ( 4)         std     <COMPARE
11C3-EC 02           509 ( 5)         ldd     2,x
11C5-DD B1           510 ( 4)         std     <COMPARE+2
11C7-EC 04           511 ( 5)         ldd     4,x
11C9-DD B3           512 ( 4)         std     <COMPARE+4
11CB-DF 8D           513 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
11CD-7D 00 9C        514 ( 4)         tst     ExeStateFlag    ; 実行状態フラグの確認
11D0-27 05           515 ( 3)         beq     :1              ; 0 = runモードであればSMT_TABLEをセット
11D2-CE 17 E4        516 ( 3)         ldx     #CMD_TABLE      ; 1 = directモードであればCMD_TABLEをセット
11D5-20 03           517 ( 3)         bra     :2
11D7-CE 18 00        518 ( 3) .1      ldx     #SMT_TABLE
11DA-BD 17 A7        519 ( 6) .2      jsr     search_table    ; テーブル検索実行
11DD-4F              520 ( 1) .err00  clra                    ; search_tableから戻ってくるということは"Syntax error"
11DE-7E 18 56        521 ( 3)         jmp     write_err_msg
11E1-86 04           522 ( 2) .err04  ldaa    #4              ; "Illegal expression"
11E3-7E 18 56        523 ( 3)         jmp     write_err_msg
11E6-                524
11E6-                525
11E6-                526      ; -----------------------------------------------------------------------
11E6-                527      ; 式を評価する
11E6-                528      ; Evaluate the expression
11E6-                529      ;【引数】B:アスキーコード X:実行位置アドレス
11E6-                530      ;【使用】A, B, X, UR2, UR3 （下位ルーチンでUR0, UR1）
11E6-                531      ;【返値】真(C=1) / D:Integer X:次の実行位置アドレス
11E6-                532      ;        偽(C=0) / X:現在の実行位置アドレス
11E6-                533      ; -----------------------------------------------------------------------
11E6-                534      eval_expression:
00AB-                535      .SP     .eq     UR2
00AD-                536      .X      .eq     UR3
11E6-                537            ; // エラー時SPとXを元に戻すために初期値をUR2とUR3に退避しておく
11E6-DF AD           538 ( 4)         stx     <:X
11E8-30              539 ( 1)         tsx
11E9-DF AB           540 ( 4)         stx     <:SP
11EB-DE AD           541 ( 4)         ldx     <:X
11ED-                542            ; // 計算スタックの初期化
11ED-CC 02 28        543 ( 3)         ldd     #CSTACK_BTM+1
11F0-DD 82           544 ( 4)         std     <CStackPtr
11F2-                545            ; // 式評価開始
11F2-8D 08           546 ( 5)         bsr     expr_4th
11F4-                547            ; // 計算結果をスタックトップから取り出す
11F4-3C              548 ( 5)         pshx
11F5-DE 82           549 ( 4)         ldx     <CStackPtr
11F7-EC 00           550 ( 5)         ldd     0,x
11F9-38              551 ( 4)         pulx
11FA-0D              552 ( 1)         sec                     ; true:C=1
11FB-39              553 ( 5)         rts
11FC-                554
11FC-                555      expr_4th:
11FC-8D 50           556 ( 5)         bsr     expr_3rd
11FE-BD 15 57        557 ( 6) .loop   jsr     skip_space
1201-C1 3D           558 ( 2)         cmpb    #'='            ; '='?
1203-26 08           559 ( 3)         bne     :ltsign         ; NO. '<'記号のチェックへ
1205-08              560 ( 1)         inx
1206-8D 46           561 ( 5)         bsr     expr_3rd
1208-BD 14 41        562 ( 6)         jsr     CS_eq           ; EQual to
120B-20 F1           563 ( 3)         bra     :loop
120D-C1 3C           564 ( 2) .ltsign cmpb    #'<'            ; '<'?
120F-26 22           565 ( 3)         bne     :gtsign         ; NO. '>'記号のチェックへ
1211-08              566 ( 1)         inx
1212-E6 00           567 ( 4)         ldab    0,x
1214-C1 3E           568 ( 2)         cmpb    #'>'            ; '<>'?
1216-26 08           569 ( 3)         bne     :lte
1218-08              570 ( 1)         inx
1219-8D 33           571 ( 5)         bsr     expr_3rd
121B-BD 14 62        572 ( 6)         jsr     CS_ne           ; Not Equal to
121E-20 DE           573 ( 3)         bra     :loop
1220-C1 3D           574 ( 2) .lte    cmpb    #'='            ; '<='?
1222-26 08           575 ( 3)         bne     :lt
1224-08              576 ( 1)         inx
1225-8D 27           577 ( 5)         bsr     expr_3rd
1227-BD 14 57        578 ( 6)         jsr     CS_lte          ; Less Than or Equal to
122A-20 D2           579 ( 3)         bra     :loop
122C-8D 20           580 ( 5) .lt     bsr     expr_3rd
122E-BD 14 4C        581 ( 6)         jsr     CS_lt           ; Less Than
1231-20 CB           582 ( 3)         bra     :loop
1233-C1 3E           583 ( 2) .gtsign cmpb    #'>'            ; '>'?
1235-26 16           584 ( 3)         bne     :end
1237-08              585 ( 1)         inx
1238-E6 00           586 ( 4)         ldab    0,x
123A-C1 3D           587 ( 2)         cmpb    #'='            ; '>='?
123C-26 08           588 ( 3)         bne     :gt
123E-08              589 ( 1)         inx
123F-8D 0D           590 ( 5)         bsr     expr_3rd
1241-BD 14 78        591 ( 6)         jsr     CS_gte          ; Greater Than or Equal to
1244-20 B8           592 ( 3)         bra     :loop
1246-8D 06           593 ( 5) .gt     bsr     expr_3rd
1248-BD 14 6D        594 ( 6)         jsr     CS_gt           ; Greater Than
124B-20 B1           595 ( 3)         bra     :loop
124D-39              596 ( 5) .end    rts
124E-                597
124E-                598      expr_3rd:
124E-8D 1C           599 ( 5)         bsr     expr_2nd
1250-BD 15 57        600 ( 6) .loop   jsr     skip_space
1253-C1 2B           601 ( 2)         cmpb    #'+'
1255-26 08           602 ( 3)         bne     :minus
1257-08              603 ( 1)         inx
1258-8D 12           604 ( 5)         bsr     expr_2nd
125A-BD 13 0B        605 ( 6)         jsr     CS_add
125D-20 F1           606 ( 3)         bra     :loop
125F-C1 2D           607 ( 2) .minus  cmpb    #'-'
1261-26 08           608 ( 3)         bne     :end
1263-08              609 ( 1)         inx
1264-8D 06           610 ( 5)         bsr     expr_2nd
1266-BD 13 14        611 ( 6)         jsr     CS_sub
1269-20 E5           612 ( 3)         bra     :loop
126B-39              613 ( 5) .end    rts
126C-                614
126C-                615      expr_2nd:
126C-8D 28           616 ( 5)         bsr     expr_1st
126E-BD 15 57        617 ( 6) .loop   jsr     skip_space
1271-C1 2A           618 ( 2)         cmpb    #'*'
1273-26 08           619 ( 3)         bne     :div
1275-08              620 ( 1)         inx
1276-8D 1E           621 ( 5)         bsr     expr_1st
1278-BD 13 1D        622 ( 6)         jsr     CS_mul
127B-20 F1           623 ( 3)         bra     :loop
127D-C1 2F           624 ( 2) .div    cmpb    #'/'
127F-26 08           625 ( 3)         bne     :mod
1281-08              626 ( 1)         inx
1282-8D 12           627 ( 5)         bsr     expr_1st
1284-BD 13 3A        628 ( 6)         jsr     CS_div
1287-20 E5           629 ( 3)         bra     :loop
1289-C1 25           630 ( 2) .mod    cmpb    #'%'
128B-26 08           631 ( 3)         bne     :end
128D-08              632 ( 1)         inx
128E-8D 06           633 ( 5)         bsr     expr_1st
1290-BD 13 53        634 ( 6)         jsr     CS_mod
1293-20 D9           635 ( 3)         bra     :loop
1295-39              636 ( 5) .end    rts
1296-                637
1296-                638      expr_1st:
00AB-                639      .SP     .eq     UR2
00AD-                640      .X      .eq     UR3
1296-BD 15 57        641 ( 6)         jsr     skip_space
1299-BD 14 8E        642 ( 6)         jsr     get_int_from_decimal ; 数字チェックと取得
129C-24 02           643 ( 3)         bcc     :array          ; 数字でなければ配列変数のチェックへ
129E-20 43           644 ( 3)         bra     :push           ; 数字であればスタックにプッシュ
12A0-C1 40           645 ( 2) .array  cmpb    #'@'
12A2-26 22           646 ( 3)         bne     :var            ; 配列変数でなければ変数のチェックへ
12A4-E6 01           647 ( 4)         ldab    1,x
12A6-C1 28           648 ( 2)         cmpb    #'('            ; 直後の文字は'('？
12A8-26 50           649 ( 3)         bne     :err00          ; No. "Syntax error"
12AA-08              650 ( 1)         inx                     ; 実行位置ポインタを'('の直後に
12AB-08              651 ( 1)         inx
12AC-BD 11 FC        652 ( 6)         jsr     expr_4th        ; 添字を取得する
12AF-                653            ; // ')'の確認
12AF-C1 29           654 ( 2)         cmpb    #')'
12B1-26 47           655 ( 3)         bne     :err00
12B3-3C              656 ( 5)         pshx                    ; 実行位置アドレスを退避
12B4-DE 82           657 ( 4)         ldx     <CStackPtr
12B6-EC 00           658 ( 5)         ldd     0,x             ; 添字の取得
12B8-08              659 ( 1)         inx
12B9-08              660 ( 1)         inx
12BA-DF 82           661 ( 4)         stx     <CStackPtr
12BC-BD 15 94        662 ( 6)         jsr     set_array_addr  ; 配列変数アドレスの取得
12BF-18              663 ( 2)         xgdx                    ; X = 配列変数のアドレス
12C0-EC 00           664 ( 5)         ldd     0,x             ; 配列変数値を取得
12C2-38              665 ( 4)         pulx                    ; 実行位置アドレスを復帰
12C3-08              666 ( 1)         inx                     ; 実行位置ポインタを')'の直後に
12C4-20 1D           667 ( 3)         bra     :push
12C6-BD 15 42        668 ( 6) .var    jsr     is_variable     ; 変数か？
12C9-24 0A           669 ( 3)         bcc     :paren          ; 変数でなければカッコのチェックへ
12CB-                670            ; // 変数値の取得
12CB-3C              671 ( 5)         pshx                    ; 実行位置アドレスを退避
12CC-86 02           672 ( 2)         ldaa    #VARIABLE>>8    ; A = 変数領域の上位バイト
12CE-58              673 ( 1)         aslb                    ; B = 変数領域の下位バイト
12CF-18              674 ( 2)         xgdx                    ; X = 変数のアドレス
12D0-EC 00           675 ( 5)         ldd     0,x             ; D <- 変数の値
12D2-38              676 ( 4)         pulx                    ; 実行位置アドレスを復帰
12D3-20 0E           677 ( 3)         bra     :push           ; 変数の値をスタックにプッシュ
12D5-C1 28           678 ( 2) .paren  cmpb    #'('
12D7-26 1A           679 ( 3)         bne     :err
12D9-08              680 ( 1)         inx
12DA-BD 11 FC        681 ( 6)         jsr     expr_4th
12DD-C1 29           682 ( 2)         cmpb    #')'
12DF-26 12           683 ( 3)         bne     :err
12E1-08              684 ( 1)         inx
12E2-39              685 ( 5)         rts
12E3-3C              686 ( 5) .push   pshx                    ; 実行位置アドレスを退避
12E4-DE 82           687 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
12E6-09              688 ( 1)         dex
12E7-09              689 ( 1)         dex
12E8-8C 01 FE        690 ( 3)         cpx     #CSTACK-2       ; スタックオーバーフローのチェック
12EB-25 11           691 ( 3)         bcs     :err06
12ED-ED 00           692 ( 5)         std     0,x
12EF-DF 82           693 ( 4)         stx     <CStackPtr
12F1-38              694 ( 4)         pulx                    ; 実行位置アドレスを復帰
12F2-39              695 ( 5)         rts
12F3-                696            ; // 戻り先をeval_expressionの呼び出し元に戻してリターン
12F3-DE AB           697 ( 4) .err    ldx     <:SP
12F5-35              698 ( 1)         txs
12F6-DE AD           699 ( 4)         ldx     <:X
12F8-0C              700 ( 1)         clc                     ; false:C=0
12F9-39              701 ( 5)         rts
12FA-4F              702 ( 1) .err00  clra                    ; "Syntax error"
12FB-7E 18 56        703 ( 3)         jmp     write_err_msg
12FE-86 06           704 ( 2) .err06  ldaa    #6              ; "Calculate stack overflow"
1300-7E 18 56        705 ( 3)         jmp     write_err_msg
1303-                706
1303-                707      ;
1303-                708      ; Arithmetic operator
1303-                709      ;
1303-                710      CS_store:
1303-08              711 ( 1)         inx
1304-08              712 ( 1)         inx
1305-ED 00           713 ( 5)         std     0,x
1307-DF 82           714 ( 4)         stx     <CStackPtr      ; 計算スタックポインタを保存
1309-38              715 ( 4)         pulx                    ; 実行位置アドレスを復帰
130A-39              716 ( 5)         rts
130B-                717
130B-3C              718 ( 5) CS_add: pshx                    ; 実行位置アドレスを退避
130C-DE 82           719 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
130E-EC 02           720 ( 5)         ldd     2,x
1310-E3 00           721 ( 5)         addd    0,x
1312-20 EF           722 ( 3)         bra     CS_store
1314-                723
1314-3C              724 ( 5) CS_sub: pshx                    ; 実行位置アドレスを退避
1315-DE 82           725 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1317-EC 02           726 ( 5)         ldd     2,x
1319-A3 00           727 ( 5)         subd    0,x
131B-20 E6           728 ( 3)         bra     CS_store
131D-                729
131D-                730      CS_mul:
00A7-                731      .Result         .eq     UR0
131D-3C              732 ( 5)         pshx                    ; 実行位置アドレスを退避
131E-DE 82           733 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1320-                734              ; B * D
1320-A6 03           735 ( 4)         ldaa    3,x             ;「B」をAレジスタに代入
1322-E6 01           736 ( 4)         ldab    1,x             ;「D」をBレジスタに代入
1324-3D              737 ( 7)         mul                     ; B * D
1325-DD A7           738 ( 4)         std     <:Result        ;「B*D」を保存
1327-                739              ; A * D
1327-EC 01           740 ( 5)         ldd     1,x             ;「D」をAレジスタに、「A」をBレジスタに同時に代入
1329-3D              741 ( 7)         mul                     ; A * D
132A-DB A7           742 ( 3)         addb    <:Result        ;「A*D」の下位8bitをResultの上位8bitに加算
132C-D7 A7           743 ( 3)         stab    <:Result        ; Resultの上位8bitを保存
132E-                744              ; C * B
132E-A6 00           745 ( 4)         ldaa    0,x             ;「C」をAレジスタに代入
1330-E6 03           746 ( 4)         ldab    3,x             ;「B」をBレジスタに代入
1332-3D              747 ( 7)         mul                     ; C * B
1333-DB A7           748 ( 3)         addb    <:Result        ;「C*B」の下位8bitをResultの上位8bitに加算
1335-17              749 ( 1)         tba                     ; Resultの上位8bitをAレジスタに転送
1336-D6 A8           750 ( 3)         ldab    <:Result+1      ; Resultの下位8bitをBレジスタに転送
1338-20 C9           751 ( 3)         bra     CS_store
133A-                752
133A-                753      ;
133A-                754      ; trunc : 符号付き割り算の考え方
133A-                755      ; ・剰余は被除数の符号と同一
133A-                756      ;   ・ 7 / 3  = 商  2、剰余  1
133A-                757      ;   ・-7 / 3  = 商 -2、剰余 -1
133A-                758      ;   ・ 7 / -3 = 商 -2、剰余  1
133A-                759      ;   ・-7 / -3 = 商  2、剰余 -1
133A-                760      ;
133A-7D 00 9F        761 ( 4) CS_div: tst     <ModuloMode
133D-26 7A           762 ( 3)         bne     CS_div2
133F-3C              763 ( 5)         pshx                    ; 実行位置アドレスを退避
1340-DE 82           764 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1342-8D 2B           765 ( 5)         bsr     div_uint        ; 除算実行
1344-18              766 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
1345-7D 00 85        767 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
1348-27 05           768 ( 3)         beq     :end            ; '+'なら終了
134A-43              769 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
134B-53              770 ( 1)         comb
134C-C3 00 01        771 ( 3)         addd    #1
134F-DE 82           772 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
1351-20 B0           773 ( 3)         bra     CS_store
1353-                774
1353-7D 00 9F        775 ( 4) CS_mod: tst     <ModuloMode
1356-26 7E           776 ( 3)         bne     CS_mod2
1358-3C              777 ( 5)         pshx                    ; 実行位置アドレスを退避
1359-DE 82           778 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
135B-8D 12           779 ( 5)         bsr     div_uint        ; 除算実行。D = 剰余
135D-DD 89           780 ( 4)         std     <Remainder      ; 剰余はゼロか？
135F-27 0A           781 ( 3)         beq     :end            ; ゼロであれば終了
1361-7D 00 86        782 ( 4)         tst     <RemSignFlag    ; 剰余の符号チェック
1364-27 05           783 ( 3)         beq     :end            ; '+'なら終了
1366-43              784 ( 1) .sign   coma                    ; '-'なら2の補数にする
1367-53              785 ( 1)         comb
1368-C3 00 01        786 ( 3)         addd    #1
136B-DE 82           787 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
136D-20 94           788 ( 3)         bra     CS_store
136F-                789
136F-                790      div_uint:
00A7-                791      .Counter        .eq     UR0H
136F-EC 00           792 ( 5)         ldd     0,x             ; ゼロ除算チェック
1371-27 41           793 ( 3)         beq     :err08          ; 除数がゼロならエラー
1373-5F              794 ( 1)         clrb
1374-D7 85           795 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
1376-D7 86           796 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1378-C6 10           797 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
137A-D7 A7           798 ( 3)         stab    <:Counter
137C-                799              ; // 剰余の符号フラグの設定
137C-EC 02           800 ( 5)         ldd     2,x             ; Dレジスタに被除数を代入
137E-2A 03           801 ( 3)         bpl     :1              ; 被除数が正であれば剰余の符号は正（0）
1380-7C 00 86        802 ( 6)         inc     <RemSignFlag    ; 被除数が負であれば剰余の符号は負（1）
1383-                803              ; // 商の符号フラグの設定
1383-A8 00           804 ( 4) .1      eora    0,x             ; 被除数の符号と除数の符号のXORを取る
1385-2A 03           805 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
1387-7C 00 85        806 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
138A-                807              ; // 除数を絶対値にする
138A-EC 00           808 ( 5) .2      ldd     0,x             ; D <- 除数
138C-2A 05           809 ( 3)         bpl     :3
138E-43              810 ( 1)         coma                    ; 除数が負なら絶対値にする
138F-53              811 ( 1)         comb
1390-C3 00 01        812 ( 3)         addd    #1
1393-DD 87           813 ( 4) .3      std     <Divisor        ; 除数を保存
1395-                814              ; // 被除数を絶対値にする
1395-EC 02           815 ( 5)         ldd     2,x             ; D <- 被除数
1397-2A 05           816 ( 3)         bpl     :4
1399-43              817 ( 1)         coma                    ; 被除数が負なら絶対値にする
139A-53              818 ( 1)         comb
139B-C3 00 01        819 ( 3)         addd    #1
139E-                820              ; // 除算実行
139E-18              821 ( 2) .4      xgdx                    ; X <- 被除数
139F-4F              822 ( 1)         clra                    ; D（WORK）をクリア
13A0-5F              823 ( 1)         clrb
13A1-18              824 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
13A2-05              825 ( 1)         asld
13A3-18              826 ( 2)         xgdx
13A4-59              827 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
13A5-49              828 ( 1)         rola
13A6-93 87           829 ( 4)         subd    <Divisor        ; WORK - 除数
13A8-08              830 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
13A9-24 03           831 ( 3)         bcc     :5              ; WORKから除数を引けた？
13AB-D3 87           832 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
13AD-09              833 ( 1)         dex                     ; XレジスタのLSBを0に戻す
13AE-7A 00 A7        834 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
13B1-26 EE           835 ( 3)         bne     :loop
13B3-39              836 ( 5)         rts
13B4-86 08           837 ( 2) .err08  ldaa    #8              ; "Zero Divide"
13B6-7E 18 56        838 ( 3)         jmp     write_err_msg
13B9-                839
13B9-                840      ;
13B9-                841      ; floor : 符号付き割り算の考え方
13B9-                842      ; ・剰余は除数の符号と同一
13B9-                843      ;   ・ 7 / 3  = 商  2、剰余  1
13B9-                844      ;   ・-7 / 3  = 商 -3、剰余  2
13B9-                845      ;   ・ 7 / -3 = 商 -3、剰余 -2
13B9-                846      ;   ・-7 / -3 = 商  2、剰余 -1
13B9-                847      ;  商 ：1.被除数の符号と序数の符号が一致していないときには1足して符号反転する
13B9-                848      ;       2.ただし、除数がゼロの場合は1は足さない
13B9-                849      ; 剰余：1.被除数の符号と序数の符号が一致していないときには
13B9-                850      ;         除数の絶対値から剰余の絶対値を引く
13B9-                851      ;       2.その結果を除数と同じ符号にする
13B9-                852      ;       3.ただし、除数がゼロの場合は剰余もゼロ
13B9-                853      ;
13B9-                854      CS_div2:
13B9-3C              855 ( 5)         pshx                    ; 実行位置アドレスを退避
13BA-DE 82           856 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13BC-8D 39           857 ( 5)         bsr     div_uint2       ; 除算実行
13BE-18              858 ( 2)         xgdx                    ; D <- 商（Quotient） X <- 剰余（Remainder）
13BF-7D 00 85        859 ( 4)         tst     <QuoSignFlag    ; 商の符号チェック
13C2-27 0D           860 ( 3)         beq     :end            ; '+'なら終了
13C4-8C 00 00        861 ( 3)         cpx     #0              ; 剰余はゼロか？
13C7-27 03           862 ( 3)         beq     :sign
13C9-C3 00 01        863 ( 3)         addd    #1              ; ゼロでなければ商に1を足す
13CC-43              864 ( 1) .sign   coma                    ; Dレジスタの値を2の補数にする
13CD-53              865 ( 1)         comb
13CE-C3 00 01        866 ( 3)         addd    #1
13D1-DE 82           867 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
13D3-7E 13 03        868 ( 3)         jmp     CS_store
13D6-                869
13D6-                870      CS_mod2:
13D6-3C              871 ( 5)         pshx                    ; 実行位置アドレスを退避
13D7-DE 82           872 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
13D9-8D 1C           873 ( 5)         bsr     div_uint2        ; 除算実行。D = 剰余
13DB-DD 89           874 ( 4)         std     <Remainder      ; 剰余はゼロか？
13DD-27 13           875 ( 3)         beq     :end            ; ゼロであれば終了
13DF-7D 00 85        876 ( 4)         tst     <QuoSignFlag    ; 被除数・除数の符号一致チェック
13E2-27 04           877 ( 3)         beq     :sign           ; 0なら一致しているので剰余の符号チェック
13E4-DC 87           878 ( 4)         ldd     <Divisor        ; 1なら一致していないので除数 - 剰余
13E6-93 89           879 ( 4)         subd    <Remainder
13E8-7D 00 86        880 ( 4) .sign   tst     <RemSignFlag    ; 剰余の符号チェック
13EB-27 05           881 ( 3)         beq     :end            ; '+'なら終了
13ED-43              882 ( 1)         coma                    ; '-'なら2の補数にする
13EE-53              883 ( 1)         comb
13EF-C3 00 01        884 ( 3)         addd    #1
13F2-DE 82           885 ( 4) .end    ldx     <CStackPtr      ; X <- 計算スタックポインタ
13F4-7E 13 03        886 ( 3)         jmp     CS_store
13F7-                887
13F7-                888      div_uint2:
00A7-                889      .Counter        .eq     UR0H
13F7-EC 00           890 ( 5)         ldd     0,x             ; ゼロ除算チェック
13F9-27 41           891 ( 3)         beq     :err08          ; 除数がゼロならエラー
13FB-5F              892 ( 1)         clrb
13FC-D7 85           893 ( 3)         stab    <QuoSignFlag    ; 商の符号フラグを初期化
13FE-D7 86           894 ( 3)         stab    <RemSignFlag    ; 剰余の符号フラグを初期化
1400-C6 10           895 ( 2)         ldab    #16             ; ループカウンターをセット（16bit分）
1402-D7 A7           896 ( 3)         stab    <:Counter
1404-                897              ; // 剰余の符号フラグの設定
1404-EC 00           898 ( 5)         ldd     0,x             ; Dレジスタに除数を代入
1406-2A 03           899 ( 3)         bpl     :1              ; 除数が正であれば剰余の符号は正（0）
1408-7C 00 86        900 ( 6)         inc     <RemSignFlag    ; 除数が負であれば剰余の符号は負（1）
140B-                901              ; // 商の符号フラグの設定
140B-A8 02           902 ( 4) .1      eora    2,x             ; 被除数の符号と除数の符号のXORを取る
140D-2A 03           903 ( 3)         bpl     :2              ; 被除数と除数の符号が同じなら商の符号は正（0）
140F-7C 00 85        904 ( 6)         inc     <QuoSignFlag    ; 被除数と除数の符号が違えば商の符号は負（1）
1412-                905              ; // 除数を絶対値にする
1412-EC 00           906 ( 5) .2      ldd     0,x             ; D <- 除数
1414-2A 05           907 ( 3)         bpl     :3
1416-43              908 ( 1)         coma                    ; 除数が負なら絶対値にする
1417-53              909 ( 1)         comb
1418-C3 00 01        910 ( 3)         addd    #1
141B-DD 87           911 ( 4) .3      std     <Divisor        ; 除数を保存
141D-                912              ; // 被除数を絶対値にする
141D-EC 02           913 ( 5)         ldd     2,x             ; D <- 被除数
141F-2A 05           914 ( 3)         bpl     :4
1421-43              915 ( 1)         coma                    ; 被除数が負なら絶対値にする
1422-53              916 ( 1)         comb
1423-C3 00 01        917 ( 3)         addd    #1
1426-                918              ; // 除算実行
1426-18              919 ( 2) .4      xgdx                    ; X <- 被除数
1427-4F              920 ( 1)         clra                    ; D（WORK）をクリア
1428-5F              921 ( 1)         clrb
1429-18              922 ( 2) .loop   xgdx                    ; X（被除数）を左シフト
142A-05              923 ( 1)         asld
142B-18              924 ( 2)         xgdx
142C-59              925 ( 1)         rolb                    ; 被除数のMSBをWORKのLSBに代入
142D-49              926 ( 1)         rola
142E-93 87           927 ( 4)         subd    <Divisor        ; WORK - 除数
1430-08              928 ( 1)         inx                     ; XレジスタのLSBを1にセットしておく
1431-24 03           929 ( 3)         bcc     :5              ; WORKから除数を引けた？
1433-D3 87           930 ( 4)         addd    <Divisor        ; 引けなければ除数を足して...
1435-09              931 ( 1)         dex                     ; XレジスタのLSBを0に戻す
1436-7A 00 A7        932 ( 6) .5      dec     <:Counter       ; ループカウンターを1引く
1439-26 EE           933 ( 3)         bne     :loop
143B-39              934 ( 5)         rts
143C-86 08           935 ( 2) .err08  ldaa    #8              ; "Zero Divide"
143E-7E 18 56        936 ( 3)         jmp     write_err_msg
1441-                937
1441-3C              938 ( 5) CS_eq:  pshx                    ; 実行位置アドレスを退避
1442-DE 82           939 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1444-EC 02           940 ( 5)         ldd     2,x
1446-A3 00           941 ( 5)         subd    0,x
1448-27 39           942 ( 3)         beq     CS_true
144A-20 3D           943 ( 3)         bra     CS_false
144C-                944
144C-3C              945 ( 5) CS_lt:  pshx                    ; 実行位置アドレスを退避
144D-DE 82           946 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
144F-EC 02           947 ( 5)         ldd     2,x
1451-A3 00           948 ( 5)         subd    0,x
1453-2D 2E           949 ( 3)         blt     CS_true
1455-20 32           950 ( 3)         bra     CS_false
1457-                951
1457-3C              952 ( 5) CS_lte: pshx                    ; 実行位置アドレスを退避
1458-DE 82           953 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
145A-EC 02           954 ( 5)         ldd     2,x
145C-A3 00           955 ( 5)         subd    0,x
145E-2F 23           956 ( 3)         ble     CS_true
1460-20 27           957 ( 3)         bra     CS_false
1462-                958
1462-3C              959 ( 5) CS_ne:  pshx                    ; 実行位置アドレスを退避
1463-DE 82           960 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1465-EC 02           961 ( 5)         ldd     2,x
1467-A3 00           962 ( 5)         subd    0,x
1469-26 18           963 ( 3)         bne     CS_true
146B-20 1C           964 ( 3)         bra     CS_false
146D-                965
146D-3C              966 ( 5) CS_gt:  pshx                    ; 実行位置アドレスを退避
146E-DE 82           967 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
1470-EC 02           968 ( 5)         ldd     2,x
1472-A3 00           969 ( 5)         subd    0,x
1474-2E 0D           970 ( 3)         bgt     CS_true
1476-20 11           971 ( 3)         bra     CS_false
1478-                972
1478-3C              973 ( 5) CS_gte: pshx                    ; 実行位置アドレスを退避
1479-DE 82           974 ( 4)         ldx     <CStackPtr      ; X <- 計算スタックポインタ
147B-EC 02           975 ( 5)         ldd     2,x
147D-A3 00           976 ( 5)         subd    0,x
147F-2C 02           977 ( 3)         bge     CS_true
1481-20 06           978 ( 3)         bra     CS_false
1483-                979
1483-                980      CS_true:
1483-CC 00 01        981 ( 3)         ldd     #1
1486-7E 13 03        982 ( 3)         jmp     CS_store
1489-                983
1489-                984      CS_false:
1489-4F              985 ( 1)         clra
148A-5F              986 ( 1)         clrb
148B-7E 13 03        987 ( 3)         jmp     CS_store
148E-                988
148E-                989      ; -----------------------------------------------------------------------
148E-                990      ; テキストバッファの10進文字列から数値を取得する
148E-                991      ; Get a integer from a decimal string in a text buffer
148E-                992      ;【引数】X:バッファアドレス
148E-                993      ;【使用】A, B, X, UR0, UR1
148E-                994      ;【返値】真(C=1) / D:Integer X:次のバッファアドレス
148E-                995      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
148E-                996      ; -----------------------------------------------------------------------
148E-                997      get_int_from_decimal:
00A7-                998      .RetValue       .eq     UR0     ; Return Value
00A9-                999      .TempValue      .eq     UR1     ; Temporary Value
148E-4F             1000 ( 1)         clra
148F-5F             1001 ( 1)         clrb
1490-DD A7          1002 ( 4)         std     <:RetValue
1492-97 A9          1003 ( 3)         staa    <:TempValue
1494-97 84          1004 ( 3)         staa    <SignFlag
1496-E6 00          1005 ( 4)         ldab    0,x             ; 1文字取得
1498-C1 2D          1006 ( 2)         cmpb    #'-'            ; マイナス記号か？
149A-26 05          1007 ( 3)         bne     :1
149C-7C 00 84       1008 ( 6)         inc     <SignFlag       ; Yes. 符号フラグをセット
149F-20 0B          1009 ( 3)         bra     :next
14A1-C1 2B          1010 ( 2) .1      cmpb    #'+'            ; プラス記号か？
14A3-27 07          1011 ( 3)         beq     :next
14A5-BD FF C1       1012 ( 6)         jsr     is_decimal_char ; 数字か？
14A8-24 36          1013 ( 3)         bcc     :false          ; No. C=1で終了
14AA-20 13          1014 ( 3)         bra     :first
14AC-08             1015 ( 1) .next   inx                     ; 符号の次の1文字を取得
14AD-E6 00          1016 ( 4)         ldab    0,x
14AF-BD FF C1       1017 ( 6)         jsr     is_decimal_char ; 数字か？
14B2-24 40          1018 ( 3)         bcc     :err04          ; No. エラー処理へ
14B4-20 09          1019 ( 3)         bra     :first          ; Yes. これが最初の数字
14B6-DD A7          1020 ( 4) .loop   std     <:RetValue      ; 結果を退避
14B8-E6 00          1021 ( 4)         ldab    0,x             ; 1文字取得
14BA-BD FF C1       1022 ( 6)         jsr     is_decimal_char ; 数字か？
14BD-24 14          1023 ( 3)         bcc     :end
14BF-C0 30          1024 ( 2) .first  subb    #$30            ; アスキーコードを数値にする
14C1-D7 AA          1025 ( 3)         stab    <:TempValue+1
14C3-               1026            ; // RetValue * 10 + TempValue
14C3-DC A7          1027 ( 4)         ldd     <:RetValue
14C5-05             1028 ( 1)         asld                    ; * 2
14C6-05             1029 ( 1)         asld                    ; * 4
14C7-D3 A7          1030 ( 4)         addd    <:RetValue      ; * 5
14C9-05             1031 ( 1)         asld                    ; * 10
14CA-D3 A9          1032 ( 4)         addd    <:TempValue     ; += TempValue
14CC-08             1033 ( 1)         inx                     ; ポインタを進める
14CD-25 20          1034 ( 3)         bcs     :err02          ; addd <:TempValue でC=1になったら桁が大きすぎ
14CF-2B 10          1035 ( 3)         bmi     :overflow       ; 同じくN=1なら-32,768かどうか判定
14D1-20 E3          1036 ( 3)         bra     :loop
14D3-DC A7          1037 ( 4) .end    ldd     <:RetValue      ; D <- 結果の数値（Integer）
14D5-7D 00 84       1038 ( 4)         tst     <SignFlag       ; 符号チェック
14D8-27 05          1039 ( 3)         beq     :true
14DA-43             1040 ( 1)         coma                    ; 負なら2の補数に
14DB-53             1041 ( 1)         comb
14DC-C3 00 01       1042 ( 3)         addd    #1
14DF-0D             1043 ( 1) .true   sec
14E0-39             1044 ( 5) .false  rts
14E1-               1045
14E1-               1046      .overflow
14E1-               1047            ; // -32,768かどうかの判定
14E1-18             1048 ( 2)         xgdx
14E2-8C 80 00       1049 ( 3)         cpx     #$8000          ; 数値は$8000 （-32,768）か？
14E5-18             1050 ( 2)         xgdx
14E6-26 07          1051 ( 3)         bne     :err02          ; No. 範囲外
14E8-7D 00 84       1052 ( 4)         tst     <SignFlag       ; 符号チェック
14EB-27 02          1053 ( 3)         beq     :err02          ; 正ならば範囲外
14ED-20 C7          1054 ( 3)         bra     :loop           ; 負ならば-32,768で範囲内なので元に戻る
14EF-               1055
14EF-86 02          1056 ( 2) .err02  ldaa    #2              ; "Out of range"
14F1-7E 18 56       1057 ( 3)         jmp     write_err_msg
14F4-86 04          1058 ( 2) .err04  ldaa    #4              ; "Illegal expression"
14F6-7E 18 56       1059 ( 3)         jmp     write_err_msg
14F9-               1060
14F9-               1061
14F9-               1062      ; -----------------------------------------------------------------------
14F9-               1063      ; Dレジスタの数値をコンソールに出力する
14F9-               1064      ; Write Decimal Character converted from Integer
14F9-               1065      ;【引数】D:Integer
14F9-               1066      ;【使用】A, B, X
14F9-               1067      ;【返値】なし
14F9-               1068      ; -----------------------------------------------------------------------
14F9-               1069      write_integer:
00A7-               1070      .ZeroSuppress   .eq     UR0H    ; ゼロサプレスフラグ
00A8-               1071      .Counter        .eq     UR0L    ; 桁カウンター
14F9-2A 0C          1072 ( 3)         bpl     :plus           ; 符号判定
14FB-37             1073 ( 4)         pshb                    ; 負数なら'-'を出力する
14FC-C6 2D          1074 ( 2)         ldab    #'-'
14FE-BD FF AC       1075 ( 6)         jsr     write_char
1501-33             1076 ( 3)         pulb
1502-43             1077 ( 1)         coma                    ; 絶対値にする（2の補数にする）
1503-53             1078 ( 1)         comb
1504-C3 00 01       1079 ( 3)         addd    #1
1507-7F 00 A7       1080 ( 5) .plus   clr     <:ZeroSuppress
150A-CE 15 3A       1081 ( 3)         ldx     #:CONST
150D-7F 00 A8       1082 ( 5) .loop   clr     <:Counter
1510-A3 00          1083 ( 5) .digit  subd    0,x             ; Dレジスタから桁ごとの数値を引く
1512-25 05          1084 ( 3)         bcs     :write
1514-7C 00 A8       1085 ( 6)         inc     <:Counter       ; 引けた回数をカウントする
1517-20 F7          1086 ( 3)         bra     :digit
1519-               1087
1519-E3 00          1088 ( 5) .write  addd    0,x             ; Dレジスタから引きすぎた分を戻す
151B-37             1089 ( 4)         pshb
151C-D6 A8          1090 ( 3)         ldab    <:Counter
151E-27 03          1091 ( 3)         beq     :1              ; この桁はゼロか？
1520-7C 00 A7       1092 ( 6)         inc     <:ZeroSuppress  ; No. ゼロサプレスフラグをセットする
1523-7D 00 A7       1093 ( 4) .1      tst     <:ZeroSuppress  ; セロサプレスフラグが立っている？
1526-27 05          1094 ( 3)         beq     :2              ; No. この桁は表示しない
1528-CB 30          1095 ( 2)         addb    #$30            ; Yes. この桁を表示する
152A-BD FF AC       1096 ( 6)         jsr     write_char
152D-33             1097 ( 3) .2      pulb
152E-08             1098 ( 1)         inx                     ; 次の引く数へ
152F-08             1099 ( 1)         inx
1530-8C 15 42       1100 ( 3)         cpx     #:CONST+8
1533-26 D8          1101 ( 3)         bne     :loop
1535-CB 30          1102 ( 2)         addb    #$30            ; 一の桁の数値を表示
1537-7E FF AC       1103 ( 3)         jmp     write_char
153A-               1104      ; Dから引いていく数
153A-27 10          1105      .CONST  .dw     $2710           ; 10,000
153C-03 E8          1106              .dw     $03e8           ; 1,000
153E-00 64          1107              .dw     $0064           ; 100
1540-00 0A          1108              .dw     $000a           ; 10
1542-               1109
1542-               1110
1542-               1111      ; -----------------------------------------------------------------------
1542-               1112      ; テキストバッファの英文字が変数か判定する
1542-               1113      ; Is a character retrieved from a text buffer a variable?
1542-               1114      ;【引数】X:バッファアドレス
1542-               1115      ;【使用】A, B, X
1542-               1116      ;【返値】真(C=1) / B:変数のアスキーコード X:次のバッファアドレス
1542-               1117      ;        偽(C=0) / B:現在の位置のアスキーコード X:現在のバッファアドレス
1542-               1118      ; -----------------------------------------------------------------------
1542-               1119      is_variable:
1542-E6 00          1120 ( 4)         ldab    0,x
1544-BD FF BE       1121 ( 6)         jsr     is_alphabetic_char
1547-24 0D          1122 ( 3)         bcc     :end
1549-17             1123 ( 1)         tba                             ; 1文字目のアスキーコードを退避
154A-E6 01          1124 ( 4)         ldab    1,x                     ; 2文字目を取得
154C-BD FF BE       1125 ( 6)         jsr     is_alphabetic_char      ; 2文字もアルファベットか？
154F-16             1126 ( 1)         tab                             ; 1文字目のアスキーコードを復帰
1550-24 02          1127 ( 3)         bcc     :var                    ; No. 英文字1字なので変数である
1552-0C             1128 ( 1)         clc                             ; Yes. 変数ではない。C=0
1553-39             1129 ( 5)         rts
1554-08             1130 ( 1) .var    inx                             ; ポインタを進める
1555-0D             1131 ( 1)         sec                             ; C=1
1556-39             1132 ( 5) .end    rts
1557-               1133
1557-               1134
1557-               1135      ; -----------------------------------------------------------------------
1557-               1136      ; 空白を読み飛ばす
1557-               1137      ; Skip Space
1557-               1138      ;【引数】X:実行位置アドレス
1557-               1139      ;【使用】B, X
1557-               1140      ;【返値】B:アスキーコード（$00の時Z=1）
1557-               1141      ;        X:実行位置アドレス
1557-               1142      ; -----------------------------------------------------------------------
1557-               1143      skip_space:
1557-E6 00          1144 ( 4)         ldab    0,x
1559-27 07          1145 ( 3)         beq     :end
155B-C1 20          1146 ( 2)         cmpb    #SPACE
155D-22 03          1147 ( 3)         bhi     :end
155F-08             1148 ( 1)         inx
1560-20 F5          1149 ( 3)         bra     skip_space
1562-39             1150 ( 5) .end    rts
1563-               1151
1563-               1152
1563-               1153      ; -----------------------------------------------------------------------
1563-               1154      ; 引用符付きの文字列を出力する
1563-               1155      ; Write Quoted Stirng
1563-               1156      ;【引数】B:アスキーコード X:実行位置アドレス
1563-               1157      ;【使用】A, B, X
1563-               1158      ;【返値】真(C=1) / X:次の実行位置アドレス
1563-               1159      ;        偽：引用符がない(C=0) / X:現在の実行位置アドレス
1563-               1160      ; -----------------------------------------------------------------------
1563-               1161      write_quoted_str:
1563-C1 22          1162 ( 2)         cmpb    #$22            ; 一重引用符か？
1565-27 04          1163 ( 3)         beq     :1
1567-C1 27          1164 ( 2)         cmpb    #$27            ; 二重引用符か？
1569-26 19          1165 ( 3)         bne     :false          ; 引用符がなければC=0にしてリターン
156B-17             1166 ( 1) .1      tba                     ; Aレジスタに引用符の種類を保存しておく
156C-               1167            ; // 終端の引用符をチェック
156C-3C             1168 ( 5)         pshx
156D-08             1169 ( 1) .check  inx
156E-E6 00          1170 ( 4)         ldab    0,x
1570-27 14          1171 ( 3)         beq     :err10          ; 終端文字なら"Print Statement Error"
1572-11             1172 ( 1)         cba
1573-26 F8          1173 ( 3)         bne     :check
1575-38             1174 ( 4)         pulx
1576-               1175            ; // 文字列の出力
1576-08             1176 ( 1) .loop   inx
1577-E6 00          1177 ( 4)         ldab    0,x
1579-11             1178 ( 1)         cba                     ; 保存した引用符との比較
157A-27 05          1179 ( 3)         beq     :true           ; 文字列前後の引用符が一致すれば終了処理
157C-BD FF AC       1180 ( 6)         jsr     write_char
157F-20 F5          1181 ( 3)         bra     :loop
1581-08             1182 ( 1) .true   inx
1582-0D             1183 ( 1)         sec
1583-39             1184 ( 5)         rts
1584-0C             1185 ( 1) .false  clc
1585-39             1186 ( 5)         rts
1586-86 0A          1187 ( 2) .err10  ldaa    #10             ; "Print statement error"
1588-7E 18 56       1188 ( 3)         jmp     write_err_msg
158B-               1189
158B-               1190
158B-               1191      ; -----------------------------------------------------------------------
158B-               1192      ; タブを出力する
158B-               1193      ; Write tabs
158B-               1194      ;【引数】なし
158B-               1195      ;【使用】B
158B-               1196      ;【返値】なし
158B-               1197      ; -----------------------------------------------------------------------
158B-               1198      write_tab:
158B-BD FF B5       1199 ( 6) .top    jsr     write_space
158E-7B 07 39       1200 ( 4)         tim     #7,<TabCount
1591-26 F8          1201 ( 3)         bne     :top
1593-39             1202 ( 5)         rts
1594-               1203
1594-               1204
1594-               1205      ; -----------------------------------------------------------------------
1594-               1206      ; 配列変数のアドレスを取得する
1594-               1207      ; Set the address of the array variable
1594-               1208      ;【引数】D:添字
1594-               1209      ;【使用】A, B
1594-               1210      ;【返値】D:配列変数のアドレス
1594-               1211      ; -----------------------------------------------------------------------
1594-               1212      set_array_addr:
1594-18             1213 ( 2)         xgdx
1595-9C A5          1214 ( 4)         cpx     <MaxSubscript   ; 取得した添字 > 添字の最大値？
1597-22 09          1215 ( 3)         bhi     :err22          ; Yes. エラー処理
1599-18             1216 ( 2)         xgdx
159A-05             1217 ( 1)         asld                    ; 添字を2倍にする
159B-D3 A3          1218 ( 4)         addd    <ArrayAddr
159D-39             1219 ( 5)         rts
159E-4F             1220 ( 1) .err00  clra                    ; "Syntax error"
159F-7E 18 56       1221 ( 3)         jmp     write_err_msg
15A2-86 16          1222 ( 2) .err22  ldaa    #22             ; "Subscript is out of range"
15A4-7E 18 56       1223 ( 3)         jmp     write_err_msg
15A7-               1224
15A7-               1225
15A7-               1226      ; -----------------------------------------------------------------------
15A7-               1227      ; 式を評価して変数に値を代入する
15A7-               1228      ; Evaluate an expression and assign a value to a variable
15A7-               1229      ;【引数】X:実行位置アドレス *VarAddress:変数のアドレス
15A7-               1230      ;【使用】A, B, X（関連ルーチンでUR0, UR1, UR2, UR3）
15A7-               1231      ;【返値】D:Integer X:次の実行位置アドレス
15A7-               1232      ; -----------------------------------------------------------------------
15A7-               1233      assign_to_var:
15A7-BD 15 57       1234 ( 6)         jsr     skip_space
15AA-BD 11 E6       1235 ( 6)         jsr     eval_expression
15AD-24 07          1236 ( 3)         bcc     :err04
15AF-3C             1237 ( 5)         pshx                    ; 実行位置アドレスを退避
15B0-DE 8B          1238 ( 4)         ldx     <VariableAddr
15B2-ED 00          1239 ( 5)         std     0,x             ; 変数に結果を保存
15B4-38             1240 ( 4)         pulx                    ; 実行位置アドレスを復帰
15B5-39             1241 ( 5)         rts
15B6-86 04          1242 ( 2) .err04  ldaa    #4              ; "Illegal expression"
15B8-7E 18 56       1243 ( 3)         jmp     write_err_msg
15BB-               1244
15BB-               1245
15BB-               1246      ; -----------------------------------------------------------------------
15BB-               1247      ; 同じ行番号を検索する
15BB-               1248      ; Scan equal line number
15BB-               1249      ;【引数】LineNumber:検索対象の行番号 X:検索を開始する行頭アドレス
15BB-               1250      ;【使用】A, B, X
15BB-               1251      ;【返値】真(C=1) / D:行番号 X:その行の開始アドレス
15BB-               1252      ;        偽(C=0) / D:次に大きな行番号 X:次に大きな行の開始アドレス
15BB-               1253      ;                  またはD:$0000 X:プログラム終了アドレス
15BB-               1254      ; -----------------------------------------------------------------------
15BB-               1255      scan_line_num:
15BB-EC 00          1256 ( 5) .loop   ldd     0,x             ; D:行番号
15BD-27 0F          1257 ( 3)         beq     :false          ; プログラム終端まで来たので偽
15BF-18             1258 ( 2)         xgdx
15C0-9C 96          1259 ( 4)         cpx     <LineNumber
15C2-18             1260 ( 2)         xgdx
15C3-27 07          1261 ( 3)         beq     :true           ; 同一の行番号が見つかったので真
15C5-2E 07          1262 ( 3)         bgt     :false          ; 対象の行番号より大きくなったので偽
15C7-E6 02          1263 ( 4)         ldab    2,x
15C9-3A             1264 ( 1)         abx
15CA-20 EF          1265 ( 3)         bra     :loop
15CC-0D             1266 ( 1) .true   sec
15CD-39             1267 ( 5)         rts
15CE-0C             1268 ( 1) .false  clc
15CF-39             1269 ( 5)         rts
15D0-               1270
15D0-               1271
15D0-               1272      ; -----------------------------------------------------------------------
15D0-               1273      ; runコマンドを実行する
15D0-               1274      ; Execute 'run' command
15D0-               1275      ;【引数】なし
15D0-               1276      ;【使用】A, B, X
15D0-               1277      ;【返値】なし
15D0-               1278      ; -----------------------------------------------------------------------
15D0-               1279      exe_run:
15D0-               1280            ; // 変数領域の初期化
15D0-CE 02 C2       1281 ( 3)         ldx     #VARIABLE
15D3-4F             1282 ( 1)         clra
15D4-5F             1283 ( 1)         clrb
15D5-ED 00          1284 ( 5) .1      std     0,x
15D7-08             1285 ( 1)         inx
15D8-08             1286 ( 1)         inx
15D9-8C 02 F6       1287 ( 3)         cpx     #VARIABLE+VARIABLE_SIZE
15DC-26 F7          1288 ( 3)         bne     :1
15DE-7F 00 9C       1289 ( 5)         clr     <ExeStateFlag   ; 実行状態フラグをrunに設定
15E1-CE 04 00       1290 ( 3)         ldx     #USER_AREA_TOP
15E4-DF 9D          1291 ( 4) .loop   stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
15E6-EC 00          1292 ( 5)         ldd     0,x
15E8-27 08          1293 ( 3)         beq     :end            ; 行番号が$0000なら終了
15EA-08             1294 ( 1)         inx
15EB-08             1295 ( 1)         inx
15EC-08             1296 ( 1)         inx
15ED-BD 11 84       1297 ( 6)         jsr     exe_line        ; 一行実行
15F0-20 F2          1298 ( 3)         bra     :loop
15F2-7E 10 2E       1299 ( 3) .end    jmp     tb_main
15F5-               1300
15F5-               1301
15F5-               1302      ; -----------------------------------------------------------------------
15F5-               1303      ; listコマンドを実行する
15F5-               1304      ; Execute 'list' command
15F5-               1305      ;【引数】なし
15F5-               1306      ;【使用】A, B, X
15F5-               1307      ;【返値】なし
15F5-               1308      ; -----------------------------------------------------------------------
15F5-               1309      exe_list:
15F5-CE 04 00       1310 ( 3)         ldx     #USER_AREA_TOP
15F8-               1311            ; // 行番号出力
15F8-EC 00          1312 ( 5) .loop   ldd     0,x
15FA-27 11          1313 ( 3)         beq     :end            ; 行番号が$0000（終端）なら終了
15FC-3C             1314 ( 5)         pshx
15FD-BD 14 F9       1315 ( 6)         jsr     write_integer
1600-38             1316 ( 4)         pulx
1601-               1317            ; // 本文出力
1601-08             1318 ( 1)         inx                     ; 本文までスキップ
1602-08             1319 ( 1)         inx
1603-08             1320 ( 1)         inx
1604-BD FF AF       1321 ( 6)         jsr     write_line
1607-BD FF B2       1322 ( 6)         jsr     write_crlf
160A-08             1323 ( 1)         inx                     ; 次の行番号へ
160B-20 EB          1324 ( 3)         bra     :loop
160D-7E 10 2E       1325 ( 3) .end    jmp     tb_main         ; コマンドは実行したら終了
1610-               1326
1610-               1327
1610-               1328      ; -----------------------------------------------------------------------
1610-               1329      ; Print文を実行する
1610-               1330      ; Execute 'print' statement
1610-               1331      ;【引数】X:実行位置アドレス
1610-               1332      ;【使用】B, X（下位ルーチンでA）
1610-               1333      ;【返値】なし
1610-               1334      ; -----------------------------------------------------------------------
1610-               1335      exe_print:
1610-72 01 8F       1336 ( 6)         oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
1613-BD 15 57       1337 ( 6) .loop   jsr     skip_space
1616-27 37          1338 ( 3)         beq     :finish         ; 終端文字なら改行して終了
1618-BD 15 63       1339 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
161B-25 1B          1340 ( 3)         bcs     :nlon
161D-BD 11 E6       1341 ( 6)         jsr     eval_expression
1620-25 11          1342 ( 3)         bcs     :int
1622-               1343            ; // eval_expressionの返値がC=0だった場合は式が存在したのか確認する
1622-               1344            ; // 'print'の次の文字がセミコロンとカンマ、コロンであれば式は無かったとする
1622-C1 3B          1345 ( 2) .check  cmpb    #';'
1624-27 23          1346 ( 3)         beq     :nloff
1626-C1 2C          1347 ( 2)         cmpb    #','
1628-27 1C          1348 ( 3)         beq     :tab
162A-C1 3A          1349 ( 2)         cmpb    #':'
162C-27 21          1350 ( 3)         beq     :finish
162E-86 04          1351 ( 2)         ldaa    #4              ; "Illegal expression"
1630-7E 18 56       1352 ( 3)         jmp     write_err_msg
1633-3C             1353 ( 5) .int    pshx                    ; 実行位置アドレスを退避
1634-BD 14 F9       1354 ( 6)         jsr     write_integer   ; 評価した式を出力
1637-38             1355 ( 4)         pulx                    ; 実行位置アドレスを復帰
1638-72 01 8F       1356 ( 6) .nlon   oim     #1,<NewLineFlag ; 改行フラグを'ON'にする
163B-BD 15 57       1357 ( 6)         jsr     skip_space
163E-C1 3B          1358 ( 2)         cmpb    #';'
1640-27 07          1359 ( 3)         beq     :nloff
1642-C1 2C          1360 ( 2)         cmpb    #','
1644-26 09          1361 ( 3)         bne     :finish
1646-BD 15 8B       1362 ( 6) .tab    jsr     write_tab       ; タブ出力
1649-7F 00 8F       1363 ( 5) .nloff  clr     <NewLineFlag    ; 改行フラグを'OFF'にする
164C-08             1364 ( 1)         inx                     ; 次の文字へ
164D-20 C4          1365 ( 3)         bra     :loop
164F-7D 00 8F       1366 ( 4) .finish tst     <NewLineFlag
1652-27 03          1367 ( 3)         beq     :end            ; 改行フラグが'OFF'なら終了
1654-BD FF B2       1368 ( 6)         jsr     write_crlf      ; 改行フラグが'ON'なら改行出力
1657-7E 11 64       1369 ( 3) .end    jmp     is_multi
165A-               1370
165A-               1371
165A-               1372      ; -----------------------------------------------------------------------
165A-               1373      ; input文を実行する
165A-               1374      ; Execute 'input' statement
165A-               1375      ; -----------------------------------------------------------------------
165A-               1376      exe_input:
165A-BD 15 57       1377 ( 6)         jsr     skip_space
165D-27 31          1378 ( 3)         beq     :end            ; 終端文字なら改行して終了
165F-BD 15 63       1379 ( 6)         jsr     write_quoted_str ; 引用符があれば文字列を出力する
1662-24 0A          1380 ( 3)         bcc     :1
1664-E6 00          1381 ( 4)         ldab    0,x
1666-C1 3B          1382 ( 2)         cmpb    #';'
1668-26 29          1383 ( 3)         bne     :err00
166A-08             1384 ( 1)         inx
166B-BD 15 57       1385 ( 6)         jsr     skip_space
166E-BD 15 42       1386 ( 6) .1      jsr     is_variable
1671-24 20          1387 ( 3)         bcc     :err00
1673-86 02          1388 ( 2)         ldaa    #VARIABLE>>8    ; Yes. A = 変数領域の上位バイト
1675-58             1389 ( 1)         aslb                    ; B = 変数領域の下位バイト
1676-DD 8B          1390 ( 4)         std     <VariableAddr   ; 変数アドレスを保存
1678-               1391            ; // 変数の後に余計な文字がないか確認
1678-               1392            ; // 例えば "input a+b" など
1678-DF 8D          1393 ( 4)         stx     <ExePointer     ; 実行位置アドレスを退避
167A-BD 15 57       1394 ( 6)         jsr     skip_space
167D-27 06          1395 ( 3)         beq     :read           ; 終端文字なら入力へ
167F-C1 3A          1396 ( 2)         cmpb    #':'            ; ":"なら入力へ
1681-26 10          1397 ( 3)         bne     :err00          ; それ以外の文字ならエラー
1683-DE 8D          1398 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1685-BD FF A9       1399 ( 6) .read   jsr     read_line
1688-CE 01 40       1400 ( 3)         ldx     #TEXT_BFFR
168B-BD 15 A7       1401 ( 6)         jsr     assign_to_var   ; 入力された内容を変数に代入
168E-DE 8D          1402 ( 4)         ldx     <ExePointer     ; 実行位置アドレスを復帰
1690-7E 11 64       1403 ( 3) .end    jmp     is_multi
1693-4F             1404 ( 1) .err00  clra                    ; "Syntax error"
1694-7E 18 56       1405 ( 3)         jmp     write_err_msg
1697-               1406
1697-               1407
1697-               1408      ; -----------------------------------------------------------------------
1697-               1409      ; if文を実行する
1697-               1410      ; Execute 'if' statement
1697-               1411      ;【引数】X:実行位置アドレス
1697-               1412      ;【使用】B, X
1697-               1413      ;【返値】なし
1697-               1414      ; -----------------------------------------------------------------------
1697-BD 15 57       1415 ( 6) exe_if: jsr     skip_space      ; 空白を読み飛ばし
169A-27 0B          1416 ( 3)         beq     :end            ; 終端文字なら終了
169C-BD 11 E6       1417 ( 6)         jsr     eval_expression ; 式評価
169F-24 09          1418 ( 3)         bcc     :err04
16A1-5D             1419 ( 1)         tstb                    ; 真偽値はゼロか否かなので下位8bitのみで判断
16A2-27 03          1420 ( 3)         beq     :end
16A4-7E 11 84       1421 ( 3)         jmp     exe_line        ; True
16A7-7E 11 74       1422 ( 3) .end    jmp     eol_process     ; Falseならば全て無視され行末の処理へ
16AA-86 04          1423 ( 2) .err04  ldaa    #4              ; "Illegal expression"
16AC-7E 18 56       1424 ( 3)         jmp     write_err_msg
16AF-               1425
16AF-               1426
16AF-               1427      ; -----------------------------------------------------------------------
16AF-               1428      ; gosub文を実行する
16AF-               1429      ; Execute 'gosub' statement
16AF-               1430      ;【引数】X:実行位置アドレス
16AF-               1431      ;【使用】A, B, X
16AF-               1432      ;【返値】なし
16AF-               1433      ; -----------------------------------------------------------------------
16AF-               1434      exe_gosub:
16AF-72 01 A0       1435 ( 6)         oim     #1,<ToSubFlag   ; 分岐モードを1 = gosubにする
16B2-               1436              ; そのままexe_gotoに続く
16B2-               1437
16B2-               1438
16B2-               1439      ; -----------------------------------------------------------------------
16B2-               1440      ; goto文を実行する
16B2-               1441      ; Execute 'goto' statement
16B2-               1442      ;【引数】X:実行位置アドレス
16B2-               1443      ;【使用】A, B, X
16B2-               1444      ;【返値】なし
16B2-               1445      ; -----------------------------------------------------------------------
16B2-               1446      exe_goto:
16B2-BD 15 57       1447 ( 6)         jsr     skip_space      ; 空白を読み飛ばし
16B5-27 3F          1448 ( 3)         beq     :err00          ; 終端文字"Syntax error"
16B7-BD 11 E6       1449 ( 6)         jsr     eval_expression ; 式評価
16BA-24 3E          1450 ( 3)         bcc     :err04          ; "Illegal expression"
16BC-2B 41          1451 ( 3)         bmi     :err12          ; "Invalid line number"
16BE-DD 96          1452 ( 4)         std     <LineNumber     ; 飛び先になる行番号を一時保存
16C0-7D 00 A0       1453 ( 4)         tst     ToSubFlag
16C3-27 17          1454 ( 3)         beq     :to             ; 分岐モードが0=gotoなら:toへ
16C5-18             1455 ( 2)         xgdx                    ; D = ExePointer
16C6-DE A1          1456 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
16C8-8C 02 28       1457 ( 3)         cpx     #SSTACK         ; 既にスタック最上位か？
16CB-27 3C          1458 ( 3)         beq     :err18          ; Yes. "Subroutine stack overflow"
16CD-09             1459 ( 1)         dex
16CE-09             1460 ( 1)         dex
16CF-ED 00          1461 ( 5)         std     0,x             ; ExePointerをスタックに積む
16D1-DC 9D          1462 ( 4)         ldd     <ExeLineAddr
16D3-09             1463 ( 1)         dex
16D4-09             1464 ( 1)         dex
16D5-ED 00          1465 ( 5)         std     0,x             ; ExeLineAddrをスタックに積む
16D7-DF A1          1466 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
16D9-7F 00 A0       1467 ( 5)         clr     ToSubFlag       ; 分岐モードを0 = gotoに戻す
16DC-DE 9D          1468 ( 4) .to     ldx     <ExeLineAddr    ; X <- 実行中の行の先頭アドレス
16DE-EC 00          1469 ( 5)         ldd     0,x             ; 今実行している行の行番号を取得
16E0-18             1470 ( 2)         xgdx
16E1-9C 96          1471 ( 4)         cpx     <LineNumber     ; 現在の行番号と飛び先の行番号を比較
16E3-18             1472 ( 2)         xgdx
16E4-25 03          1473 ( 3)         bcs     :1              ; 現在の行番号 > 飛び先の行番号 = ここから検索
16E6-CE 04 00       1474 ( 3)         ldx     #USER_AREA_TOP  ; 現在の行番号 < 飛び先の行番号 = 先頭から検索
16E9-BD 15 BB       1475 ( 6) .1      jsr     scan_line_num   ; 同じ行番号を探す
16EC-24 16          1476 ( 3)         bcc     :err16          ; "Undefined line number"
16EE-DF 9D          1477 ( 4)         stx     <ExeLineAddr    ; 実行中の行の先頭アドレスを保存
16F0-08             1478 ( 1)         inx
16F1-08             1479 ( 1)         inx
16F2-08             1480 ( 1)         inx
16F3-7E 11 84       1481 ( 3)         jmp     exe_line
16F6-               1482
16F6-4F             1483 ( 1) .err00  clra                    ; "Syntax error"
16F7-7E 18 56       1484 ( 3)         jmp     write_err_msg
16FA-86 04          1485 ( 2) .err04  ldaa    #4              ; "Illegal expression"
16FC-7E 18 56       1486 ( 3)         jmp     write_err_msg
16FF-86 0C          1487 ( 2) .err12  ldaa    #12             ; "Invalid line number"
1701-7E 18 56       1488 ( 3)         jmp     write_err_msg
1704-86 10          1489 ( 2) .err16  ldaa    #16             ; "Undefined line number"
1706-7E 18 56       1490 ( 3)         jmp     write_err_msg
1709-86 12          1491 ( 2) .err18  ldaa    #18             ; "Subroutine stack overflow"
170B-7E 18 56       1492 ( 3)         jmp     write_err_msg
170E-               1493
170E-               1494
170E-               1495      ; -----------------------------------------------------------------------
170E-               1496      ; return文を実行する
170E-               1497      ; Execute 'return' statement
170E-               1498      ;【引数】X:実行位置アドレス
170E-               1499      ;【使用】A, B, X
170E-               1500      ;【返値】なし
170E-               1501      ; -----------------------------------------------------------------------
170E-               1502      exe_return:
170E-DE A1          1503 ( 4)         ldx     <SStackPtr      ; サブルーチンスタックポインタ代入
1710-8C 02 50       1504 ( 3)         cpx     #SSTACK_BTM+1   ; 既にスタックの底か？
1713-27 10          1505 ( 3)         beq     :err20          ; Yes. "Return without gosub"
1715-EC 00          1506 ( 5)         ldd     0,x
1717-DD 9D          1507 ( 4)         std     <ExeLineAddr    ; ExeLineAddrをスタックから復帰
1719-08             1508 ( 1)         inx
171A-08             1509 ( 1)         inx
171B-EC 00          1510 ( 5)         ldd     0,x             ; D = ExePointer
171D-08             1511 ( 1)         inx
171E-08             1512 ( 1)         inx
171F-DF A1          1513 ( 4)         stx     <SStackPtr      ; サブルーチンスタックポインタ退避
1721-18             1514 ( 2)         xgdx                    ; X = ExePointer
1722-7E 11 64       1515 ( 3)         jmp     is_multi
1725-               1516
1725-86 14          1517 ( 2) .err20  ldaa    #20             ; "Return without gosub"
1727-7E 18 56       1518 ( 3)         jmp     write_err_msg
172A-               1519
172A-               1520
172A-               1521      ; -----------------------------------------------------------------------
172A-               1522      ; trunc文を実行する
172A-               1523      ; Execute 'trunc' statement
172A-               1524      ;【引数】X:実行位置アドレス
172A-               1525      ;【使用】B, X
172A-               1526      ;【返値】なし
172A-               1527      ; -----------------------------------------------------------------------
172A-               1528      exe_trunc:
172A-7F 00 9F       1529 ( 5)         clr     <ModuloMode     ; tranc = 0 にする
172D-7E 11 64       1530 ( 3)         jmp     is_multi
1730-               1531
1730-               1532
1730-               1533      ; -----------------------------------------------------------------------
1730-               1534      ; floor文を実行する
1730-               1535      ; Execute 'trunc' statement
1730-               1536      ;【引数】X:実行位置アドレス
1730-               1537      ;【使用】B, X
1730-               1538      ;【返値】なし
1730-               1539      ; -----------------------------------------------------------------------
1730-               1540      exe_floor:
1730-72 01 9F       1541 ( 6)         oim     #1,<ModuloMode  ; floor = 1以上 にする
1733-7E 11 64       1542 ( 3)         jmp     is_multi
1736-               1543
1736-               1544
1736-               1545      ; ------------------------------------------------
1736-               1546      ; ブロック転送
1736-               1547      ; Move memory
1736-               1548      ;【引数】Source:転送元アドレス
1736-               1549      ;        Destination:転送先アドレス
1736-               1550      ;        Bytes:転送バイト数
1736-               1551      ;【使用】A, B, X, UR0
1736-               1552      ;【返値】なし
1736-               1553      ; ------------------------------------------------
1736-               1554      mem_move:
1736-DC 94          1555 ( 4)         ldd     <Bytes
1738-27 0A          1556 ( 3)         beq     :end            ; 転送バイト数が0ならば即終了
173A-DC 90          1557 ( 4)         ldd     <Source
173C-93 92          1558 ( 4)         subd    <Destination    ; Source - Destination
173E-27 04          1559 ( 3)         beq     :end            ; 転送元と転送先が同じなら即終了
1740-24 03          1560 ( 3)         bcc     LDIR            ; Source > Destination
1742-20 31          1561 ( 3)         bra     LDDR            ; Source < Destination
1744-39             1562 ( 5) .end    rts
1745-               1563
1745-               1564      ; ------------------------------------------------
1745-               1565      ; 前方から転送（LDIR）
1745-               1566      ; Load, Increment and Repeat
1745-               1567      ;【引数】Source:転送元アドレス
1745-               1568      ;        Destination:転送先アドレス
1745-               1569      ;        Bytes:転送バイト数
1745-               1570      ;【使用】A, B, X, UR0
1745-               1571      ;【返値】なし
1745-               1572      ; ------------------------------------------------
1745-               1573      LDIR:
00A7-               1574      .Offset .eq     UR0
1745-               1575             ; // オフセットの計算。既にDレジスタに入っている
1745-DD A7          1576 ( 4)        std     <:Offset        ; Offset = Source - Destination
1747-               1577            ; // 終了判定用のアドレスを計算
1747-DC 90          1578 ( 4)         ldd     <Source         ; 転送終了アドレス = Source - Bytes
1749-D3 94          1579 ( 4)         addd    <Bytes
174B-DD 92          1580 ( 4)         std     <Destination    ; 転送終了アドレスをDestinationに代入
174D-               1581            ; // 転送開始
174D-DE 90          1582 ( 4)         ldx     <Source         ; 転送開始アドレスをXに代入
174F-               1583            ; // 転送するバイト数が奇数か偶数か判断。
174F-               1584            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
174F-DC 94          1585 ( 4)         ldd     <Bytes
1751-04             1586 ( 1)         lsrd                    ; 転送バイト数 / 2, 奇数ならC=1
1752-24 0E          1587 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
1754-               1588            ; // Byte転送
1754-A6 00          1589 ( 4)         ldaa    0,x             ; A <- [Source]
1756-18             1590 ( 2)         xgdx                    ; D = address, X = data
1757-93 A7          1591 ( 4)         subd    <:Offset        ; Source - Offset = Destination
1759-18             1592 ( 2)         xgdx                    ; D = data, X = address
175A-A7 00          1593 ( 4)         staa    0,x             ; [Destination] <- A
175C-18             1594 ( 2)         xgdx                    ; D = address, X = data
175D-D3 A7          1595 ( 4)         addd    <:Offset        ; Destination + Offset = Source
175F-18             1596 ( 2)         xgdx                    ; D = data, X = address
1760-20 0D          1597 ( 3)         bra     :odd            ; 飛び先でinx
1762-               1598            ; // Word転送
1762-EC 00          1599 ( 5) .loop   ldd     0,x
1764-18             1600 ( 2)         xgdx
1765-93 A7          1601 ( 4)         subd    <:Offset
1767-18             1602 ( 2)         xgdx
1768-ED 00          1603 ( 5)         std     0,x
176A-18             1604 ( 2)         xgdx
176B-D3 A7          1605 ( 4)         addd    <:Offset
176D-18             1606 ( 2)         xgdx
176E-08             1607 ( 1)         inx
176F-08             1608 ( 1) .odd    inx
1770-9C 92          1609 ( 4)         cpx     <Destination    ; 転送終了アドレスと現在のアドレスを比較
1772-26 EE          1610 ( 3)         bne     :loop
1774-39             1611 ( 5)         rts
1775-               1612
1775-               1613      ; ------------------------------------------------
1775-               1614      ; 後方から転送（LDDR）
1775-               1615      ; Load, Decrement and Repeat
1775-               1616      ;【引数】Source:転送元アドレス
1775-               1617      ;        Destination:転送先アドレス
1775-               1618      ;        Bytes:転送バイト数
1775-               1619      ;【使用】A, B, X, UR0
1775-               1620      ;【返値】なし
1775-               1621      ; ------------------------------------------------
1775-               1622      LDDR:
00A7-               1623      .Offset .eq     UR0
1775-               1624            ; // オフセットの計算
1775-DC 92          1625 ( 4)         ldd     <Destination
1777-93 90          1626 ( 4)         subd    <Source
1779-DD A7          1627 ( 4)         std     <:Offset         ; Offset = Destination - Source
177B-               1628            ; // 転送終了アドレスは既にDestinationに代入済み
177B-               1629            ; // 転送開始アドレスの計算。一番後ろから
177B-DC 90          1630 ( 4)         ldd     <Source         ; 転送開始アドレス = Source + Bytes
177D-D3 94          1631 ( 4)         addd    <Bytes
177F-18             1632 ( 2)         xgdx                    ; X = 転送開始アドレス
1780-               1633            ; // 転送するバイト数が奇数か偶数か判断。
1780-               1634            ; // 奇数ならByte転送x1 + Word転送、偶数ならWord転送
1780-DC 94          1635 ( 4)         ldd     <Bytes
1782-04             1636 ( 1)         lsrd                    ; Bytes / 2, 奇数ならC=1
1783-24 0F          1637 ( 3)         bcc     :loop           ; 偶数ならWord転送へ
1785-               1638            ; // Byte転送
1785-09             1639 ( 1)         dex
1786-A6 00          1640 ( 4)         ldaa    0,x             ; A <- [Source]
1788-18             1641 ( 2)         xgdx                    ; D = address, X = data
1789-D3 A7          1642 ( 4)         addd    <:Offset        ; Source + Offset = Destination
178B-18             1643 ( 2)         xgdx                    ; D = data, X = address
178C-A7 00          1644 ( 4)         staa    0,x             ; [Destination] <- A
178E-18             1645 ( 2)         xgdx                    ; D = address, X = data
178F-93 A7          1646 ( 4)         subd    <:Offset        ; Destination - Offset = Source
1791-18             1647 ( 2)         xgdx                    ; D = data, X = address
1792-20 0E          1648 ( 3)         bra     :odd
1794-               1649            ; // Word転送
1794-09             1650 ( 1) .loop   dex
1795-09             1651 ( 1)         dex
1796-EC 00          1652 ( 5)         ldd     0,x
1798-18             1653 ( 2)         xgdx
1799-D3 A7          1654 ( 4)         addd    <:Offset
179B-18             1655 ( 2)         xgdx
179C-ED 00          1656 ( 5)         std     0,x
179E-18             1657 ( 2)         xgdx
179F-93 A7          1658 ( 4)         subd    <:Offset
17A1-18             1659 ( 2)         xgdx
17A2-9C 90          1660 ( 4) .odd    cpx     <Source         ; 転送終了アドレスと現在のアドレスを比較
17A4-26 EE          1661 ( 3)         bne     :loop
17A6-39             1662 ( 5)         rts
17A7-               1663
17A7-               1664
17A7-               1665      ; -----------------------------------------------------------------------
17A7-               1666      ; テーブル検索
17A7-               1667      ; Search the keyword table
17A7-               1668      ;【引数】X:テーブルの先頭アドレス, *ExePointer:実行位置アドレス
17A7-               1669      ;【使用】A, B, X
17A7-               1670      ;【結果】真(C=1) / 命令文実行. X:次の実行位置アドレス
17A7-               1671      ;        偽(C=0) / 何もせずにリターン X:引数*ExePointer（実行位置アドレス）
17A7-               1672      ; -----------------------------------------------------------------------
17A7-               1673      search_table:
17A7-EC 05          1674 ( 5) .top    ldd     5,x             ; キーワードの初めの2文字をDレジスタに
17A9-91 AF          1675 ( 3)         cmpa    <COMPARE        ; 1文字目を比較
17AB-26 2F          1676 ( 3)         bne     :false
17AD-D1 B0          1677 ( 3)         cmpb    <COMPARE+1      ; 2文字目を比較
17AF-26 2B          1678 ( 3)         bne     :false
17B1-EC 07          1679 ( 5)         ldd     7,x             ; 次の2文字をDレジスタに
17B3-4D             1680 ( 1)         tsta                    ; $00（終端記号）か？
17B4-27 1B          1681 ( 3)         beq     :true
17B6-91 B1          1682 ( 3)         cmpa    <COMPARE+2      ; 3文字目を比較
17B8-26 22          1683 ( 3)         bne     :false
17BA-5D             1684 ( 1)         tstb                    ; $00（終端記号）か？
17BB-27 14          1685 ( 3)         beq     :true
17BD-D1 B2          1686 ( 3)         cmpb    <COMPARE+3      ; 4文字目を比較
17BF-26 1B          1687 ( 3)         bne     :false
17C1-EC 09          1688 ( 5)         ldd     9,x             ; 次の2文字をDレジスタに
17C3-4D             1689 ( 1)         tsta                    ; $00（終端記号）か？
17C4-27 0B          1690 ( 3)         beq     :true
17C6-91 B3          1691 ( 3)         cmpa    <COMPARE+4      ; 5文字目を比較
17C8-26 12          1692 ( 3)         bne     :false
17CA-5D             1693 ( 1)         tstb                    ; $00（終端記号）か？
17CB-27 04          1694 ( 3)         beq     :true
17CD-D1 B4          1695 ( 3)         cmpb    <COMPARE+5      ; 6文字目を比較
17CF-26 0B          1696 ( 3)         bne     :false
17D1-E6 02          1697 ( 4) .true   ldab    2,x             ; B = 語長
17D3-EE 03          1698 ( 5)         ldx     3,x             ; X = 命令ルーチンのアドレス
17D5-31             1699 ( 1)         ins                     ; 元のリターンアドレスを削除
17D6-31             1700 ( 1)         ins
17D7-3C             1701 ( 5)         pshx                    ; スタックトップにリターンアドレスを積む
17D8-DE 8D          1702 ( 4)         ldx     <ExePointer
17DA-3A             1703 ( 1)         abx                     ; 実行位置アドレスを文字数分プラスする
17DB-39             1704 ( 5)         rts                     ; 命令ルーチンにジャンプ
17DC-EE 00          1705 ( 5) .false  ldx     0,x             ; リンクポインタを読み込み、次のキーワードに
17DE-26 C7          1706 ( 3)         bne     :top
17E0-DE 8D          1707 ( 4)         ldx     <ExePointer     ; マッチしなければ実行位置ポインタを元に戻す
17E2-0C             1708 ( 1)         clc                     ; false: C=0
17E3-39             1709 ( 5)         rts
17E4-               1710
17E4-               1711
17E4-               1712      ; ***********************************************************************
17E4-               1713      ;   キーワードテーブル Keyword table
17E4-               1714      ; ***********************************************************************
17E4-               1715      ; レコードの構造 Record structure
17E4-               1716      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
17E4-               1717      ; | リンクポインタ  |  語長  |命令ルーチン位置 |   キーワード    |  終端  |
17E4-               1718      ; |   Link pointer  | Length |Execution address|     Keyword     |  $00   |
17E4-               1719      ; +--------+--------+--------+--------+--------+------+-~-+------+--------+
17E4-               1720      ; キーワードは2文字以上6文字以下
17E4-               1721      CMD_TABLE
17E4-17 ED          1722      .run            .dw     :new
17E6-03             1723                      .db     3
17E7-15 D0          1724                      .dw     exe_run
17E9-72 75 6E 00    1725                      .az     "run"
17ED-17 F6          1726      .new            .dw     :list
17EF-03             1727                      .db     3
17F0-10 03          1728                      .dw     cold_start
17F2-6E 65 77 00    1729                      .az     "new"
17F6-18 00          1730      .list           .dw     SMT_TABLE:print
17F8-04             1731                      .db     4
17F9-15 F5          1732                      .dw     exe_list
17FB-6C 69 73 74 
     00             1733                      .az     "list"
1800-               1734      SMT_TABLE
1800-18 0B          1735      .print          .dw     :input
1802-05             1736                      .db     5
1803-16 10          1737                      .dw     exe_print
1805-70 72 69 6E 
     74 00          1738                      .az     "print"
180B-18 16          1739      .input          .dw     :if
180D-05             1740                      .db     5
180E-16 5A          1741                      .dw     exe_input
1810-69 6E 70 75 
     74 00          1742                      .az     "input"
1816-18 1E          1743      .if             .dw     :goto
1818-02             1744                      .db     2
1819-16 97          1745                      .dw     exe_if
181B-69 66 00       1746                      .az     "if"
181E-18 28          1747      .goto           .dw     :gosub
1820-04             1748                      .db     4
1821-16 B2          1749                      .dw     exe_goto
1823-67 6F 74 6F 
     00             1750                      .az     "goto"
1828-18 33          1751      .gosub          .dw     :return
182A-05             1752                      .db     5
182B-16 AF          1753                      .dw     exe_gosub
182D-67 6F 73 75 
     62 00          1754                      .az     "gosub"
1833-18 3E          1755      .return         .dw     :trunc
1835-06             1756                      .db     6
1836-17 0E          1757                      .dw     exe_return
1838-72 65 74 75 
     72 6E          1758                      .as     "return"        ; 6文字なので終端不要。'.as'を使用する
183E-18 49          1759      .trunc          .dw     :floor
1840-05             1760                      .db     5
1841-17 2A          1761                      .dw     exe_trunc
1843-74 72 75 6E 
     63 00          1762                      .az     "trunc"
1849-18 54          1763      .floor          .dw     :bottom
184B-05             1764                      .db     5
184C-17 30          1765                      .dw     exe_floor
184E-66 6C 6F 6F 
     72 00          1766                      .az     "floor"
1854-00 00          1767      .bottom         .dw     $0000           ; リンクポインタ$0000はテーブルの終端
1856-               1768
1856-               1769
1856-               1770      ; -----------------------------------------------------------------------
1856-               1771      ; エラーメッセージを表示する
1856-               1772      ; Write Error Messege
1856-               1773      ;【引数】A: エラーコード
1856-               1774      ;【使用】A, B, X
1856-               1775      ;【返値】なし
1856-               1776      ; -----------------------------------------------------------------------
1856-               1777      write_err_msg:
1856-7D 00 39       1778 ( 4)         tst     <TabCount       ; タブ位置がゼロでなければ改行する
1859-27 03          1779 ( 3)         beq     :1
185B-BD FF B2       1780 ( 6)         jsr     write_crlf
185E-CE 18 89       1781 ( 3) .1      ldx     #ERRMSG1
1861-BD FF AF       1782 ( 6)         jsr     write_line
1864-16             1783 ( 1)         tab
1865-CE 18 95       1784 ( 3)         ldx     #ERRCODE
1868-3A             1785 ( 1)         abx
1869-EE 00          1786 ( 5)         ldx     0,x
186B-BD FF AF       1787 ( 6)         jsr     write_line
186E-7D 00 9C       1788 ( 4)         tst     ExeStateFlag    ; 実行モードか？
1871-26 0D          1789 ( 3)         bne     :2              ; No. 行番号を表示せずにスキップ
1873-CE 18 90       1790 ( 3)         ldx     #ERRMSG2        ; Yes. 行番号を表示する
1876-BD FF AF       1791 ( 6)         jsr     write_line
1879-DE 9D          1792 ( 4)         ldx     <ExeLineAddr
187B-EC 00          1793 ( 5)         ldd     0,x
187D-BD 14 F9       1794 ( 6)         jsr     write_integer
1880-BD FF B2       1795 ( 6) .2      jsr     write_crlf
1883-DE 80          1796 ( 4)         ldx     <StackPointer
1885-35             1797 ( 1)         txs
1886-7E 10 2E       1798 ( 3)         jmp     tb_main
1889-               1799
1889-4F 6F 70 73 
     21 20 00       1800      ERRMSG1 .az     "Oops! "
1890-20 69 6E 20 
     00             1801      ERRMSG2 .az     " in "
1895-18 AD          1802      ERRCODE .dw     .err00
1897-18 BA          1803              .dw     .err02
1899-18 CD          1804              .dw     .err04
189B-18 E0          1805              .dw     .err06
189D-18 F9          1806              .dw     .err08
189F-19 05          1807              .dw     .err10
18A1-19 1B          1808              .dw     .err12
18A3-19 2F          1809              .dw     .err14
18A5-19 40          1810              .dw     .err16
18A7-19 56          1811              .dw     .err18
18A9-19 70          1812              .dw     .err20
18AB-19 85          1813              .dw     .err22
18AD-53 79 6E 74 
     61 78 20 65 
     72 72 6F 72 
     00             1814      .err00  .az     "Syntax error"
18BA-4F 75 74 20 
     6F 66 20 72 
     61 6E 67 65 
     20 76 61 6C 
     75 65 00       1815      .err02  .az     "Out of range value"
18CD-49 6C 6C 65 
     67 61 6C 20 
     65 78 70 72 
     65 73 73 69 
     6F 6E 00       1816      .err04  .az     "Illegal expression"
18E0-43 61 6C 63 
     75 6C 61 74 
     65 20 73 74 
     61 63 6B 20 
     6F 76 65 72 
     66 6C 6F 77 
     00             1817      .err06  .az     "Calculate stack overflow"
18F9-5A 65 72 6F 
     20 44 69 76 
     69 64 65 00    1818      .err08  .az     "Zero Divide"
1905-50 72 69 6E 
     74 20 73 74 
     61 74 65 6D 
     65 6E 74 20 
     65 72 72 6F 
     72 00          1819      .err10  .az     "Print statement error"
191B-49 6E 76 61 
     6C 69 64 20 
     6C 69 6E 65 
     20 6E 75 6D 
     62 65 72 00    1820      .err12  .az     "Invalid line number"
192F-4D 65 6D 6F 
     72 79 20 73 
     69 7A 65 20 
     6F 76 65 72 
     00             1821      .err14  .az     "Memory size over"
1940-55 6E 64 65 
     66 69 6E 65 
     64 20 6C 69 
     6E 65 20 6E 
     75 6D 62 65 
     72 00          1822      .err16  .az     "Undefined line number"
1956-53 75 62 72 
     6F 75 74 69 
     6E 65 20 73 
     74 61 63 6B 
     20 6F 76 65 
     72 66 6C 6F 
     77 00          1823      .err18  .az     "Subroutine stack overflow"
1970-52 65 74 75 
     72 6E 20 77 
     69 74 68 6F 
     75 74 20 67 
     6F 73 75 62 
     00             1824      .err20  .az     "Return without gosub"
1985-53 75 62 73 
     63 72 69 70 
     74 20 69 73 
     20 6F 75 74 
     20 6F 66 20 
     72 61 6E 67 
     65 00          1825      .err22  .az     "Subscript is out of range"
199F-               1826
199F-               1827
199F-               1828      ; ***********************************************************************
199F-               1829      ;   デバック用ルーチン Debugging routines
199F-               1830      ; ***********************************************************************
199F-               1831      ; -----------------------------------------------------------------------
199F-               1832      ; ユーザーレジスタを表示する
199F-               1833      ; Display user registers
199F-               1834      ; -----------------------------------------------------------------------
199F-36             1835 ( 4) PUTUR:  psha
19A0-37             1836 ( 4)         pshb
19A1-3C             1837 ( 5)         pshx
19A2-CE 19 D5       1838 ( 3)         ldx     #:MSGUR0
19A5-BD FF AF       1839 ( 6)         jsr     write_line
19A8-DC A7          1840 ( 4)         ldd     <UR0
19AA-BD FF BB       1841 ( 6)         jsr     write_word
19AD-CE 19 DA       1842 ( 3)         ldx     #:MSGUR1
19B0-BD FF AF       1843 ( 6)         jsr     write_line
19B3-DC A9          1844 ( 4)         ldd     <UR1
19B5-BD FF BB       1845 ( 6)         jsr     write_word
19B8-CE 19 E0       1846 ( 3)         ldx     #:MSGUR2
19BB-BD FF AF       1847 ( 6)         jsr     write_line
19BE-DC AB          1848 ( 4)         ldd     <UR2
19C0-BD FF BB       1849 ( 6)         jsr     write_word
19C3-CE 19 E6       1850 ( 3)         ldx     #:MSGUR3
19C6-BD FF AF       1851 ( 6)         jsr     write_line
19C9-DC AD          1852 ( 4)         ldd     <UR3
19CB-BD FF BB       1853 ( 6)         jsr     write_word
19CE-BD FF B2       1854 ( 6)         jsr     write_crlf
19D1-38             1855 ( 4)         pulx
19D2-33             1856 ( 3)         pulb
19D3-32             1857 ( 3)         pula
19D4-39             1858 ( 5)         rts
19D5-55 52 30 3D 
     00             1859      .MSGUR0          .az     "UR0="
19DA-20 55 52 31 
     3D 00          1860      .MSGUR1          .az     " UR1="
19E0-20 55 52 32 
     3D 00          1861      .MSGUR2          .az     " UR2="
19E6-20 55 52 33 
     3D 00          1862      .MSGUR3          .az     " UR3="
